package com.android.server.pm;

import android.app.ActivityManager;
import android.app.ActivityManagerInternal;
import android.app.AppOpsManager;
import android.app.IActivityManager;
import android.app.ResourcesManager;
import android.app.admin.IDevicePolicyManager;
import android.app.admin.SecurityLog;
import android.app.backup.IBackupManager;
import android.common.HwFrameworkFactory;
import android.common.HwFrameworkMonitor;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.IIntentReceiver;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.IntentFilter.AuthorityEntry;
import android.content.IntentSender;
import android.content.IntentSender.SendIntentException;
import android.content.ServiceConnection;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.AppsQueryHelper;
import android.content.pm.AuxiliaryResolveInfo;
import android.content.pm.AuxiliaryResolveInfo.AuxiliaryFilter;
import android.content.pm.ChangedPackages;
import android.content.pm.ComponentInfo;
import android.content.pm.FeatureInfo;
import android.content.pm.IDexModuleRegisterCallback;
import android.content.pm.IOnPermissionsChangeListener;
import android.content.pm.IPackageDataObserver;
import android.content.pm.IPackageDeleteObserver;
import android.content.pm.IPackageDeleteObserver2;
import android.content.pm.IPackageInstallObserver2;
import android.content.pm.IPackageInstaller;
import android.content.pm.IPackageManagerNative;
import android.content.pm.IPackageMoveObserver;
import android.content.pm.IPackageStatsObserver;
import android.content.pm.InstantAppInfo;
import android.content.pm.InstantAppRequest;
import android.content.pm.InstantAppResolveInfo;
import android.content.pm.InstrumentationInfo;
import android.content.pm.IntentFilterVerificationInfo;
import android.content.pm.KeySet;
import android.content.pm.PackageCleanItem;
import android.content.pm.PackageInfo;
import android.content.pm.PackageInfoLite;
import android.content.pm.PackageInstaller.SessionInfo;
import android.content.pm.PackageInstaller.SessionParams;
import android.content.pm.PackageList;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.LegacyPackageDeleteObserver;
import android.content.pm.PackageManagerInternal;
import android.content.pm.PackageManagerInternal.ExternalSourcesPolicy;
import android.content.pm.PackageManagerInternal.PackageListObserver;
import android.content.pm.PackageManagerInternal.PackagesProvider;
import android.content.pm.PackageManagerInternal.SyncAdapterPackagesProvider;
import android.content.pm.PackageParser;
import android.content.pm.PackageParser.Activity;
import android.content.pm.PackageParser.ActivityIntentInfo;
import android.content.pm.PackageParser.Callback;
import android.content.pm.PackageParser.Instrumentation;
import android.content.pm.PackageParser.Package;
import android.content.pm.PackageParser.PackageParserException;
import android.content.pm.PackageParser.Permission;
import android.content.pm.PackageParser.PermissionGroup;
import android.content.pm.PackageParser.Provider;
import android.content.pm.PackageParser.ProviderIntentInfo;
import android.content.pm.PackageParser.Service;
import android.content.pm.PackageParser.ServiceIntentInfo;
import android.content.pm.PackageParser.SigningDetails;
import android.content.pm.PackageParser.SigningDetails.CertCapabilities;
import android.content.pm.PackageStats;
import android.content.pm.PackageUserState;
import android.content.pm.ParceledListSlice;
import android.content.pm.PermissionGroupInfo;
import android.content.pm.PermissionInfo;
import android.content.pm.ProviderInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.SELinuxUtil;
import android.content.pm.ServiceInfo;
import android.content.pm.SharedLibraryInfo;
import android.content.pm.Signature;
import android.content.pm.UserInfo;
import android.content.pm.VerifierDeviceIdentity;
import android.content.pm.VerifierInfo;
import android.content.pm.VersionedPackage;
import android.content.pm.dex.ArtManager;
import android.content.pm.dex.DexMetadataHelper;
import android.content.pm.dex.IArtManager;
import android.database.ContentObserver;
import android.graphics.Bitmap;
import android.hardware.biometrics.fingerprint.V2_1.RequestStatus;
import android.hardware.display.DisplayManager;
import android.hdm.HwDeviceManager;
import android.hwtheme.HwThemeManager;
import android.iawareperf.UniPerf;
import android.installerMgr.InstallerMgr;
import android.net.Uri;
import android.os.Binder;
import android.os.Build;
import android.os.Build.VERSION;
import android.os.Bundle;
import android.os.Debug;
import android.os.Environment;
import android.os.Environment.UserEnvironment;
import android.os.FileUtils;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.os.Message;
import android.os.Parcel;
import android.os.ParcelFileDescriptor;
import android.os.PersistableBundle;
import android.os.Process;
import android.os.RemoteCallbackList;
import android.os.RemoteException;
import android.os.ResultReceiver;
import android.os.SELinux;
import android.os.ServiceManager;
import android.os.ShellCallback;
import android.os.SystemClock;
import android.os.SystemProperties;
import android.os.Trace;
import android.os.UserHandle;
import android.os.UserManager;
import android.os.UserManagerInternal;
import android.os.storage.IStorageManager;
import android.os.storage.StorageEventListener;
import android.os.storage.StorageManager;
import android.os.storage.VolumeInfo;
import android.provider.Settings.Global;
import android.provider.Settings.Secure;
import android.security.KeyStore;
import android.security.SystemKeyStore;
import android.system.ErrnoException;
import android.system.Os;
import android.system.OsConstants;
import android.text.TextUtils;
import android.util.ArrayMap;
import android.util.ArraySet;
import android.util.Base64;
import android.util.ByteStringUtils;
import android.util.DisplayMetrics;
import android.util.EventLog;
import android.util.ExceptionUtils;
import android.util.Flog;
import android.util.Jlog;
import android.util.Log;
import android.util.LogPrinter;
import android.util.LongSparseArray;
import android.util.LongSparseLongArray;
import android.util.MathUtils;
import android.util.PackageUtils;
import android.util.Pair;
import android.util.PrintStreamPrinter;
import android.util.PrintWriterPrinter;
import android.util.Slog;
import android.util.SparseArray;
import android.util.SparseBooleanArray;
import android.util.SparseIntArray;
import android.util.TimingsTraceLog;
import android.util.Xml;
import android.util.jar.StrictJarFile;
import android.util.proto.ProtoOutputStream;
import android.view.WindowManager.LayoutParams;
import android.widget.Toast;
import com.android.internal.annotations.GuardedBy;
import com.android.internal.app.IMediaContainerService;
import com.android.internal.app.IMediaContainerService.Stub;
import com.android.internal.app.IntentForwarderActivity;
import com.android.internal.app.ResolverActivity;
import com.android.internal.content.NativeLibraryHelper;
import com.android.internal.content.NativeLibraryHelper.Handle;
import com.android.internal.content.PackageHelper;
import com.android.internal.logging.MetricsLogger;
import com.android.internal.os.IParcelFileDescriptorFactory;
import com.android.internal.os.SomeArgs;
import com.android.internal.telephony.CarrierAppUtils;
import com.android.internal.util.ArrayUtils;
import com.android.internal.util.ConcurrentUtils;
import com.android.internal.util.DumpUtils;
import com.android.internal.util.FastXmlSerializer;
import com.android.internal.util.IndentingPrintWriter;
import com.android.internal.util.Preconditions;
import com.android.internal.util.XmlUtils;
import com.android.server.AttributeCache;
import com.android.server.DeviceIdleController.LocalService;
import com.android.server.EventLogTags;
import com.android.server.HwServiceExFactory;
import com.android.server.HwServiceFactory;
import com.android.server.HwServiceFactory.IHwUserManagerService;
import com.android.server.IntentResolver;
import com.android.server.LocalServices;
import com.android.server.LockGuard;
import com.android.server.ServiceThread;
import com.android.server.SmartShrinker;
import com.android.server.SystemConfig;
import com.android.server.SystemServerInitThreadPool;
import com.android.server.UiThread;
import com.android.server.am.HwBroadcastRadarUtil;
import com.android.server.job.controllers.JobStatus;
import com.android.server.lights.LightsManager;
import com.android.server.net.NetworkPolicyManagerInternal;
import com.android.server.pm.Installer.InstallerException;
import com.android.server.pm.PackageDexOptimizer.ForcedUpdatePackageDexOptimizer;
import com.android.server.pm.Settings.VersionInfo;
import com.android.server.pm.dex.ArtManagerService;
import com.android.server.pm.dex.DexManager;
import com.android.server.pm.dex.DexManager.RegisterDexModuleResult;
import com.android.server.pm.dex.DexoptOptions;
import com.android.server.pm.dex.PackageDexUsage.PackageUseInfo;
import com.android.server.pm.permission.BasePermission;
import com.android.server.pm.permission.DefaultPermissionGrantPolicy;
import com.android.server.pm.permission.DefaultPermissionGrantPolicy.DefaultPermissionGrantedCallback;
import com.android.server.pm.permission.PermissionManagerInternal;
import com.android.server.pm.permission.PermissionManagerInternal.PermissionCallback;
import com.android.server.pm.permission.PermissionManagerService;
import com.android.server.pm.permission.PermissionsState;
import com.android.server.pm.permission.PermissionsState.PermissionState;
import com.android.server.security.VerityUtils;
import com.android.server.security.VerityUtils.SetupResult;
import com.android.server.security.securityprofile.ISecurityProfileController;
import com.android.server.slice.SliceClientPermissions.SliceAuthority;
import com.android.server.storage.DeviceStorageMonitorInternal;
import com.android.server.usage.UnixCalendar;
import com.android.server.usb.descriptors.UsbTerminalTypes;
import com.android.server.utils.PriorityDump;
import com.android.server.zrhung.IZRHungService;
import com.huawei.android.content.pm.IHwPackageManager;
import dalvik.system.CloseGuard;
import dalvik.system.VMRuntime;
import huawei.android.app.HwCustEmergDataManager;
import huawei.android.bootanimation.IBootAnmation;
import huawei.android.security.IHwBehaviorCollectManager.BehaviorId;
import huawei.cust.HwCustUtils;
import java.io.BufferedOutputStream;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.nio.charset.StandardCharsets;
import java.security.DigestException;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Predicate;
import libcore.io.IoUtils;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.XmlSerializer;

public class PackageManagerService extends AbsPackageManagerService implements PackageSender, IHwPackageManagerInner {
    private static final String ATTR_IS_GRANTED = "g";
    private static final String ATTR_PACKAGE_NAME = "pkg";
    private static final String ATTR_PERMISSION_NAME = "name";
    private static final String ATTR_REVOKE_ON_UPGRADE = "rou";
    private static final String ATTR_USER_FIXED = "fixed";
    private static final String ATTR_USER_SET = "set";
    private static final int BLUETOOTH_UID = 1002;
    static final int BROADCAST_DELAY = 10000;
    static final int CHECK_PENDING_VERIFICATION = 16;
    private static final long CLEAR_DATA_THRESHOLD_MS = 1000;
    static final boolean CLEAR_RUNTIME_PERMISSIONS_ON_UPGRADE = false;
    public static final String COMPRESSED_EXTENSION = ".gz";
    private static final boolean DEBUG_ABI_SELECTION = false;
    private static final boolean DEBUG_APP_DATA = false;
    private static final boolean DEBUG_BACKUP = DEBUG_FLAG;
    private static final boolean DEBUG_BROADCASTS = DEBUG_FLAG;
    public static final boolean DEBUG_COMPRESSION = Build.IS_DEBUGGABLE;
    private static final boolean DEBUG_DELAPP = false;
    public static final boolean DEBUG_DEXOPT = false;
    static final boolean DEBUG_DOMAIN_VERIFICATION = DEBUG_FLAG;
    private static final boolean DEBUG_FILTERS = DEBUG_FLAG;
    static final boolean DEBUG_FLAG = SystemProperties.get("ro.dbg.pms_log", "0").equals("on");
    public static final boolean DEBUG_INSTALL = DEBUG_FLAG;
    private static final boolean DEBUG_INSTANT = Build.IS_DEBUGGABLE;
    private static final boolean DEBUG_INTENT_MATCHING = DEBUG_FLAG;
    private static final boolean DEBUG_PACKAGE_INFO = DEBUG_FLAG;
    public static final boolean DEBUG_PACKAGE_SCANNING = DEBUG_FLAG;
    public static final boolean DEBUG_PERMISSIONS = DEBUG_FLAG;
    static final boolean DEBUG_PREFERRED = DEBUG_FLAG;
    public static final boolean DEBUG_REMOVE = DEBUG_FLAG;
    static final boolean DEBUG_SD_INSTALL = false;
    public static final boolean DEBUG_SETTINGS = DEBUG_FLAG;
    private static final boolean DEBUG_SHARED_LIBRARIES = DEBUG_FLAG;
    private static final boolean DEBUG_SHOW_INFO = DEBUG_FLAG;
    private static final boolean DEBUG_TRIAGED_MISSING = false;
    static final boolean DEBUG_UPGRADE = DEBUG_FLAG;
    private static final boolean DEBUG_VERIFY = DEBUG_FLAG;
    public static final ComponentName DEFAULT_CONTAINER_COMPONENT = new ComponentName(DEFAULT_CONTAINER_PACKAGE, "com.android.defcontainer.DefaultContainerService");
    public static final String DEFAULT_CONTAINER_PACKAGE = "com.android.defcontainer";
    private static final long DEFAULT_MANDATORY_FSTRIM_INTERVAL = 259200000;
    private static final boolean DEFAULT_PACKAGE_PARSER_CACHE_ENABLED = true;
    private static final long DEFAULT_UNUSED_STATIC_SHARED_LIB_MIN_CACHE_PERIOD = 7200000;
    private static final int DEFAULT_VERIFICATION_RESPONSE = 1;
    private static final long DEFAULT_VERIFICATION_TIMEOUT = 10000;
    private static final boolean DEFAULT_VERIFY_ENABLE = true;
    static final int DEF_CONTAINER_BIND = 21;
    private static final int[] EMPTY_INT_ARRAY = new int[0];
    private static final boolean ENABLE_FREE_CACHE_V2 = SystemProperties.getBoolean("fw.free_cache_v2", true);
    static final int END_COPY = 4;
    static final int FIND_INSTALL_LOC = 8;
    private static final int HBS_UID = 5508;
    private static final boolean HIDE_EPHEMERAL_APIS = false;
    protected static final boolean HWFLOW;
    static final int INIT_COPY = 5;
    private static final String INSTALL_PACKAGE_SUFFIX = "-";
    private static final String[] INSTANT_APP_BROADCAST_PERMISSION = new String[]{"android.permission.ACCESS_INSTANT_APPS"};
    static final int INSTANT_APP_RESOLUTION_PHASE_TWO = 20;
    static final int INTENT_FILTER_VERIFIED = 18;
    private static final boolean IS_FPGA = boardname.contains("fpga");
    private static final String KILL_APP_REASON_GIDS_CHANGED = "permission grant or revoke changed gids";
    private static final String KILL_APP_REASON_PERMISSIONS_REVOKED = "permissions revoked";
    private static final int LOG_UID = 1007;
    private static final int MAX_PERMISSION_TREE_FOOTPRINT = 32768;
    static final int MCS_BOUND = 3;
    static final int MCS_GIVE_UP = 11;
    static final int MCS_RECONNECT = 10;
    static final int MCS_UNBIND = 6;
    static final int MSG_LAN_ENGLISH = 256;
    static final int MSG_OPER_DATA_UPDATE = 2;
    static final int MSG_OPER_STOP = 1;
    private static final int NFC_UID = 1027;
    private static final String PACKAGE_MIME_TYPE = "application/vnd.android.package-archive";
    private static final String PACKAGE_NAME_BASICADMINRECEIVER_CTS_DEIVCEOWNER = "com.android.cts.deviceowner";
    private static final String PACKAGE_NAME_BASICADMINRECEIVER_CTS_DEVICEANDPROFILEOWNER = "com.android.cts.deviceandprofileowner";
    private static final String PACKAGE_NAME_BASICADMINRECEIVER_CTS_PACKAGEINSTALLER = "com.android.cts.packageinstaller";
    private static final String PACKAGE_PARSER_CACHE_VERSION = "1";
    private static final String PACKAGE_SCHEME = "package";
    static final int PACKAGE_VERIFIED = 15;
    public static final String PLATFORM_PACKAGE_NAME = "android";
    static final int POST_INSTALL = 9;
    private static final int PRIME_DOMAIN_DEFAULT = 0;
    private static final int PRIME_DOMAIN_UPGRADE = 1;
    private static final String PRODUCT_OVERLAY_DIR = "/product/overlay";
    private static final Set<String> PROTECTED_ACTIONS = new ArraySet();
    private static final int RADIO_UID = 1001;
    public static final int REASON_AB_OTA = 4;
    public static final int REASON_BACKGROUND_DEXOPT = 3;
    public static final int REASON_BG_SPEED_DEXOPT = 7;
    public static final int REASON_BOOT = 1;
    public static final int REASON_FIRST_BOOT = 0;
    public static final int REASON_INACTIVE_PACKAGE_DOWNGRADE = 5;
    public static final int REASON_INSTALL = 2;
    public static final int REASON_LAST = 7;
    public static final int REASON_SHARED = 6;
    public static final int REASON_UNKNOWN = -1;
    static final int SCAN_AS_FULL_APP = 32768;
    static final int SCAN_AS_INSTANT_APP = 16384;
    static final int SCAN_AS_OEM = 524288;
    public static final int SCAN_AS_PRIVILEGED = 262144;
    static final int SCAN_AS_PRODUCT = 2097152;
    public static final int SCAN_AS_SYSTEM = 131072;
    static final int SCAN_AS_VENDOR = 1048576;
    static final int SCAN_AS_VIRTUAL_PRELOAD = 65536;
    static final int SCAN_BOOTING = 16;
    static final int SCAN_CHECK_ONLY = 1024;
    static final int SCAN_DELETE_DATA_ON_FAILURES = 64;
    static final int SCAN_DONT_KILL_APP = 2048;
    static final int SCAN_FIRST_BOOT_OR_UPGRADE = 8192;
    static final int SCAN_IGNORE_FROZEN = 4096;
    static final int SCAN_INITIAL = 512;
    static final int SCAN_MOVE = 256;
    static final int SCAN_NEW_INSTALL = 4;
    static final int SCAN_NO_DEX = 1;
    static final int SCAN_REQUIRE_KNOWN = 128;
    static final int SCAN_UPDATE_SIGNATURE = 2;
    static final int SCAN_UPDATE_TIME = 8;
    private static final String SD_ENCRYPTION_ALGORITHM = "AES";
    private static final String SD_ENCRYPTION_KEYSTORE_NAME = "AppsOnSD";
    static final int SEND_PENDING_BROADCAST = 1;
    private static final int SE_UID = 1068;
    private static final int SHELL_UID = 2000;
    private static final int SPI_UID = 1054;
    static final int START_CLEANING_PACKAGE = 7;
    static final int START_INTENT_FILTER_VERIFICATIONS = 17;
    private static final String STATIC_SHARED_LIB_DELIMITER = "_";
    public static final String STUB_SUFFIX = "-Stub";
    private static final String SUW_FRP_STATE = "hw_suw_frp_state";
    private static final String SYSTEM_ROOT_DIR = "/system";
    private static final int SYSTEM_RUNTIME_GRANT_MASK = 52;
    static final String TAG = "PackageManager";
    private static final String TAG_ALL_GRANTS = "rt-grants";
    private static final String TAG_DEFAULT_APPS = "da";
    private static final String TAG_GRANT = "grant";
    private static final String TAG_INTENT_FILTER_VERIFICATION = "iv";
    private static final String TAG_PERMISSION = "perm";
    private static final String TAG_PERMISSION_BACKUP = "perm-grant-backup";
    private static final String TAG_PREFERRED_BACKUP = "pa";
    private static final int TYPE_ACTIVITY = 1;
    private static final int TYPE_PROVIDER = 4;
    private static final int TYPE_RECEIVER = 2;
    private static final int TYPE_SERVICE = 3;
    private static final int TYPE_UNKNOWN = 0;
    private static final int USER_RUNTIME_GRANT_MASK = 11;
    private static final String VENDOR_OVERLAY_DIR = "/vendor/overlay";
    static final long WATCHDOG_TIMEOUT = (IS_FPGA ? 1200000 : 600000);
    static final int WRITE_PACKAGE_LIST = 19;
    static final int WRITE_PACKAGE_RESTRICTIONS = 14;
    static final int WRITE_SETTINGS = 13;
    static final int WRITE_SETTINGS_DELAY = 10000;
    private static String boardname = SystemProperties.get("ro.board.boardname", "0");
    private static boolean mOptimizeBootOn = SystemProperties.getBoolean("ro.config.hw_optimizeBoot", true);
    private static final Comparator<ProviderInfo> mProviderInitOrderSorter = new Comparator<ProviderInfo>() {
        public int compare(ProviderInfo p1, ProviderInfo p2) {
            int v1 = p1.initOrder;
            int v2 = p2.initOrder;
            if (v1 > v2) {
                return -1;
            }
            return v1 < v2 ? 1 : 0;
        }
    };
    private static final Comparator<ResolveInfo> mResolvePrioritySorter = new Comparator<ResolveInfo>() {
        public int compare(ResolveInfo r1, ResolveInfo r2) {
            int v1 = r1.priority;
            int v2 = r2.priority;
            int i = 1;
            if (v1 != v2) {
                if (v1 > v2) {
                    i = -1;
                }
                return i;
            }
            v1 = r1.preferredOrder;
            v2 = r2.preferredOrder;
            if (v1 != v2) {
                if (v1 > v2) {
                    i = -1;
                }
                return i;
            } else if (r1.isDefault != r2.isDefault) {
                if (r1.isDefault) {
                    i = -1;
                }
                return i;
            } else {
                v1 = r1.match;
                v2 = r2.match;
                if (v1 != v2) {
                    if (v1 > v2) {
                        i = -1;
                    }
                    return i;
                } else if (r1.system != r2.system) {
                    if (r1.system) {
                        i = -1;
                    }
                    return i;
                } else if (r1.activityInfo != null) {
                    return r1.activityInfo.packageName.compareTo(r2.activityInfo.packageName);
                } else {
                    if (r1.serviceInfo != null) {
                        return r1.serviceInfo.packageName.compareTo(r2.serviceInfo.packageName);
                    }
                    if (r1.providerInfo != null) {
                        return r1.providerInfo.packageName.compareTo(r2.providerInfo.packageName);
                    }
                    return 0;
                }
            }
        }
    };
    private static final int mThreadnum = (Runtime.getRuntime().availableProcessors() + 1);
    private static final File sAppInstallDir = new File(Environment.getDataDirectory(), "app");
    protected static final File sAppLib32InstallDir = new File(Environment.getDataDirectory(), "app-lib");
    private static final Intent sBrowserIntent = new Intent();
    private static final File sDrmAppPrivateInstallDir = new File(Environment.getDataDirectory(), "app-private");
    static UserManagerService sUserManager;
    ExecutorService clearDirectoryThread = Executors.newSingleThreadExecutor();
    final ActivityIntentResolver mActivities = new ActivityIntentResolver();
    private ActivityManagerInternal mActivityManagerInternal;
    ApplicationInfo mAndroidApplication;
    final ArtManagerService mArtManagerService;
    @GuardedBy("mAvailableFeatures")
    final ArrayMap<String, FeatureInfo> mAvailableFeatures;
    private File mCacheDir;
    private Map<Integer, ParceledListSlice<PackageInfo>> mCacheInstalledPackages = new HashMap();
    @GuardedBy("mPackages")
    final SparseArray<SparseArray<String>> mChangedPackages = new SparseArray();
    @GuardedBy("mPackages")
    int mChangedPackagesSequenceNumber;
    @GuardedBy("mPackages")
    final SparseArray<Map<String, Integer>> mChangedPackagesSequenceNumbers = new SparseArray();
    private final CompilerStats mCompilerStats = new CompilerStats();
    private IMediaContainerService mContainerService = null;
    final Context mContext;
    protected boolean mCotaFlag = false;
    private HwCustPackageManagerService mCustPms = ((HwCustPackageManagerService) HwCustUtils.createObj(HwCustPackageManagerService.class, new Object[0]));
    ComponentName mCustomResolverComponentName;
    private final DefaultContainerConnection mDefContainerConn = new DefaultContainerConnection();
    final int mDefParseFlags;
    @GuardedBy("mPackages")
    boolean mDefaultContainerWhitelisted = false;
    protected final DefaultPermissionGrantPolicy mDefaultPermissionPolicy;
    private boolean mDeferProtectedFilters = true;
    private LocalService mDeviceIdleController;
    private final DexManager mDexManager;
    @GuardedBy("mPackages")
    private boolean mDexOptDialogShown;
    private ArraySet<Integer> mDirtyUsers = new ArraySet();
    ExecutorService mExecutorService = Executors.newSingleThreadExecutor();
    private final ArraySet<String> mExistingSystemPackages = new ArraySet();
    private final ArrayMap<String, File> mExpectingBetter = new ArrayMap();
    ExternalSourcesPolicy mExternalSourcesPolicy;
    final boolean mFactoryTest;
    boolean mFirstBoot;
    @GuardedBy("mPackages")
    final ArraySet<String> mFrozenPackages = new ArraySet();
    final PackageHandler mHandler;
    final ServiceThread mHandlerThread;
    volatile boolean mHasSystemUidErrors;
    HwInnerPackageManagerService mHwInnerService = new HwInnerPackageManagerService(this);
    IHwPackageManagerServiceEx mHwPMSEx = null;
    IBootAnmation mIBootAnmation = null;
    final Object mInstallLock = new Object();
    @GuardedBy("mInstallLock")
    final Installer mInstaller;
    final PackageInstallerService mInstallerService;
    ActivityInfo mInstantAppInstallerActivity;
    final ResolveInfo mInstantAppInstallerInfo = new ResolveInfo();
    private final InstantAppRegistry mInstantAppRegistry;
    final InstantAppResolverConnection mInstantAppResolverConnection;
    final ComponentName mInstantAppResolverSettingsComponent;
    final ArrayMap<ComponentName, Instrumentation> mInstrumentation = new ArrayMap();
    final SparseArray<IntentFilterVerificationState> mIntentFilterVerificationStates = new SparseArray();
    private int mIntentFilterVerificationToken = 0;
    private final IntentFilterVerifier<ActivityIntentInfo> mIntentFilterVerifier;
    private final ComponentName mIntentFilterVerifierComponent;
    protected boolean mIsDefaultGoogleCalendar = SystemProperties.getBoolean("ro.default_GoogleCalendar", false);
    protected boolean mIsDefaultPreferredActivityChanged = false;
    boolean mIsPackageScanMultiThread = SystemProperties.getBoolean("ro.config.hw_packagescan_multi", false);
    final boolean mIsPreNMR1Upgrade;
    final boolean mIsPreNUpgrade;
    final boolean mIsPrePUpgrade;
    final boolean mIsUpgrade;
    @GuardedBy("mPackages")
    final SparseIntArray mIsolatedOwners = new SparseIntArray();
    private List<String> mKeepUninstalledPackages;
    final ArrayMap<String, Set<String>> mKnownCodebase = new ArrayMap();
    @GuardedBy("mLoadedVolumes")
    final ArraySet<String> mLoadedVolumes = new ArraySet();
    private boolean mMediaMounted = false;
    final DisplayMetrics mMetrics;
    private HwFrameworkMonitor mMonitor = HwFrameworkFactory.getHwFrameworkMonitor();
    private final MoveCallbacks mMoveCallbacks;
    public boolean mNeedClearDeviceForCTS = false;
    int mNextInstallToken = 1;
    private AtomicInteger mNextMoveId = new AtomicInteger();
    private final OnPermissionChangeListeners mOnPermissionChangeListeners;
    final boolean mOnlyCore;
    protected final PackageDexOptimizer mPackageDexOptimizer;
    @GuardedBy("mPackages")
    private final ArraySet<PackageListObserver> mPackageListObservers = new ArraySet();
    final Callback mPackageParserCallback = new PackageParserCallback();
    private final PackageUsage mPackageUsage = new PackageUsage();
    @GuardedBy("mPackages")
    final ArrayMap<String, Package> mPackages = new ArrayMap();
    final ParallelPackageParserCallback mParallelPackageParserCallback = new ParallelPackageParserCallback();
    final PendingPackageBroadcasts mPendingBroadcasts = new PendingPackageBroadcasts();
    final SparseArray<PackageVerificationState> mPendingVerification = new SparseArray();
    private int mPendingVerificationToken = 0;
    protected PermissionCallback mPermissionCallback = new PermissionCallback() {
        public void onGidsChanged(final int appId, final int userId) {
            PackageManagerService.this.mHandler.post(new Runnable() {
                public void run() {
                    PackageManagerService.this.killUid(appId, userId, PackageManagerService.KILL_APP_REASON_GIDS_CHANGED);
                }
            });
        }

        public void onPermissionGranted(int uid, int userId) {
            PackageManagerService.this.mOnPermissionChangeListeners.onPermissionsChanged(uid);
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
            }
        }

        public void onInstallPermissionGranted() {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.scheduleWriteSettingsLocked();
            }
        }

        public void onPermissionRevoked(int uid, int userId) {
            PackageManagerService.this.mOnPermissionChangeListeners.onPermissionsChanged(uid);
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mSettings.writeRuntimePermissionsForUserLPr(userId, true);
            }
            PackageManagerService.this.killUid(UserHandle.getAppId(uid), userId, PackageManagerService.KILL_APP_REASON_PERMISSIONS_REVOKED);
        }

        public void onInstallPermissionRevoked() {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.scheduleWriteSettingsLocked();
            }
        }

        public void onPermissionUpdated(int[] updatedUserIds, boolean sync) {
            synchronized (PackageManagerService.this.mPackages) {
                for (int userId : updatedUserIds) {
                    PackageManagerService.this.mSettings.writeRuntimePermissionsForUserLPr(userId, sync);
                }
            }
        }

        public void onInstallPermissionUpdated() {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.scheduleWriteSettingsLocked();
            }
        }

        public void onPermissionRemoved() {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mSettings.writeLPr();
            }
        }
    };
    protected final PermissionManagerInternal mPermissionManager;
    final boolean mPermissionReviewRequired;
    Package mPlatformPackage;
    private ArrayList<Message> mPostSystemReadyMessages;
    private Future<?> mPrepareAppDataFuture;
    private final ProcessLoggingHandler mProcessLoggingHandler;
    boolean mPromoteSystemApps;
    @GuardedBy("mProtectedBroadcasts")
    final ArraySet<String> mProtectedBroadcasts = new ArraySet();
    private final List<ActivityIntentInfo> mProtectedFilters = new ArrayList();
    final ProtectedPackages mProtectedPackages;
    final ProviderIntentResolver mProviders = new ProviderIntentResolver(this, null);
    final ArrayMap<String, Provider> mProvidersByAuthority = new ArrayMap();
    final ActivityIntentResolver mReceivers = new ActivityIntentResolver();
    final String mRequiredInstallerPackage;
    final String mRequiredUninstallerPackage;
    final String mRequiredVerifierPackage;
    final ActivityInfo mResolveActivity = new ActivityInfo();
    ComponentName mResolveComponentName;
    final ResolveInfo mResolveInfo = new ResolveInfo();
    boolean mResolverReplaced = false;
    final SparseArray<PostInstallData> mRunningInstalls = new SparseArray();
    volatile boolean mSafeMode;
    final int mSdkVersion = VERSION.SDK_INT;
    final String[] mSeparateProcesses;
    final ServiceIntentResolver mServices = new ServiceIntentResolver(this, null);
    final String mServicesSystemSharedLibraryPackageName;
    @GuardedBy("mPackages")
    final Settings mSettings;
    final String mSetupWizardPackage;
    final ArrayMap<String, LongSparseArray<SharedLibraryEntry>> mSharedLibraries = new ArrayMap();
    final String mSharedSystemSharedLibraryPackageName;
    private boolean mShouldRestoreconSdAppData = false;
    private long mStartTimer = 0;
    final ArrayMap<String, LongSparseArray<SharedLibraryEntry>> mStaticLibsByDeclaringPackage = new ArrayMap();
    private StorageEventListener mStorageListener = new StorageEventListener() {
        public void onVolumeStateChanged(VolumeInfo vol, int oldState, int newState) {
            if (vol.type == 1) {
                if (vol.state == 2) {
                    String volumeUuid = vol.getFsUuid();
                    PackageManagerService.sUserManager.reconcileUsers(volumeUuid);
                    PackageManagerService.this.reconcileApps(volumeUuid);
                    PackageManagerService.this.mInstallerService.onPrivateVolumeMounted(volumeUuid);
                    PackageManagerService.this.loadPrivatePackages(vol);
                } else if (vol.state == 5) {
                    PackageManagerService.this.unloadPrivatePackages(vol);
                }
            }
            if (((vol.type == 0 && vol.isPrimary()) || (PackageManagerService.this.mCustPms != null && PackageManagerService.this.mCustPms.isSdVol(vol))) && vol.state != 2) {
                int i = vol.state;
            }
        }

        public void onVolumeForgotten(String fsUuid) {
            if (TextUtils.isEmpty(fsUuid)) {
                Slog.e(PackageManagerService.TAG, "Forgetting internal storage is probably a mistake; ignoring");
                return;
            }
            synchronized (PackageManagerService.this.mPackages) {
                for (PackageSetting ps : PackageManagerService.this.mSettings.getVolumePackagesLPr(fsUuid)) {
                    String str = PackageManagerService.TAG;
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("Destroying ");
                    stringBuilder.append(ps.name);
                    stringBuilder.append(" because volume was forgotten");
                    Slog.d(str, stringBuilder.toString());
                    PackageManagerService.this.deletePackageVersioned(new VersionedPackage(ps.name, -1), new LegacyPackageDeleteObserver(null).getBinder(), 0, 2);
                    AttributeCache.instance().removePackage(ps.name);
                }
                PackageManagerService.this.mSettings.onVolumeForgotten(fsUuid);
                PackageManagerService.this.mSettings.writeLPr();
            }
        }
    };
    final String mStorageManagerPackage;
    volatile boolean mSystemReady;
    final String mSystemTextClassifierPackage;
    protected ArrayList<Package> mTempPkgList = new ArrayList();
    private int mTimerCounter = 0;
    final ArraySet<String> mTransferedPackages = new ArraySet();
    private UserManagerInternal mUserManagerInternal;
    SparseBooleanArray mUserNeedsBadging = new SparseBooleanArray();
    private volatile boolean mWebInstantAppsDisabled;
    int tSdkVersion = -1;

    private interface BlobXmlRestorer {
        void apply(XmlPullParser xmlPullParser, int i) throws IOException, XmlPullParserException;
    }

    private final class ClearStorageConnection implements ServiceConnection {
        IMediaContainerService mContainerService;

        private ClearStorageConnection() {
        }

        /* synthetic */ ClearStorageConnection(PackageManagerService x0, AnonymousClass1 x1) {
            this();
        }

        public void onServiceConnected(ComponentName name, IBinder service) {
            synchronized (this) {
                this.mContainerService = Stub.asInterface(Binder.allowBlocking(service));
                notifyAll();
            }
        }

        public void onServiceDisconnected(ComponentName name) {
            synchronized (this) {
                if (this.mContainerService == null) {
                    Slog.w(PackageManagerService.TAG, "onServiceDisconnected unknown reason");
                    notifyAll();
                }
            }
        }
    }

    @Retention(RetentionPolicy.SOURCE)
    public @interface ComponentType {
    }

    private static class CrossProfileDomainInfo {
        int bestDomainVerificationStatus;
        ResolveInfo resolveInfo;

        private CrossProfileDomainInfo() {
        }

        /* synthetic */ CrossProfileDomainInfo(AnonymousClass1 x0) {
            this();
        }
    }

    class DefaultContainerConnection implements ServiceConnection {
        DefaultContainerConnection() {
        }

        public void onServiceConnected(ComponentName name, IBinder service) {
            PackageManagerService.this.mHandler.sendMessage(PackageManagerService.this.mHandler.obtainMessage(3, Stub.asInterface(Binder.allowBlocking(service))));
        }

        public void onServiceDisconnected(ComponentName name) {
        }
    }

    private abstract class HandlerParams {
        private static final int MAX_RETRIES = 4;
        private int mRetries = 0;
        private final UserHandle mUser;
        int traceCookie;
        String traceMethod;

        abstract void handleReturnCode();

        abstract void handleServiceError();

        abstract void handleStartCopy() throws RemoteException;

        HandlerParams(UserHandle user) {
            this.mUser = user;
        }

        UserHandle getUser() {
            return this.mUser;
        }

        HandlerParams setTraceMethod(String traceMethod) {
            this.traceMethod = traceMethod;
            return this;
        }

        HandlerParams setTraceCookie(int traceCookie) {
            this.traceCookie = traceCookie;
            return this;
        }

        final boolean startCopy() {
            boolean res = false;
            try {
                if (PackageManagerService.DEBUG_INSTALL) {
                    String str = PackageManagerService.TAG;
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("startCopy ");
                    stringBuilder.append(this.mUser);
                    stringBuilder.append(": ");
                    stringBuilder.append(this);
                    Slog.i(str, stringBuilder.toString());
                }
                int i = this.mRetries + 1;
                this.mRetries = i;
                if (i > 4) {
                    Slog.w(PackageManagerService.TAG, "Failed to invoke remote methods on default container service. Giving up");
                    PackageManagerService.this.mHandler.sendEmptyMessage(11);
                    handleServiceError();
                    return false;
                }
                handleStartCopy();
                res = true;
                handleReturnCode();
                return res;
            } catch (RemoteException e) {
                if (PackageManagerService.DEBUG_INSTALL) {
                    Slog.i(PackageManagerService.TAG, "Posting install MCS_RECONNECT");
                }
                PackageManagerService.this.mHandler.sendEmptyMessage(10);
                res = false;
            } catch (Exception e2) {
                Log.e(PackageManagerService.TAG, "Posting install MCS_GIVE_UP");
                PackageManagerService.this.mHandler.sendEmptyMessage(11);
            }
        }

        final void serviceError() {
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.i(PackageManagerService.TAG, "serviceError");
            }
            handleServiceError();
            handleReturnCode();
        }
    }

    public class HwInnerPackageManagerService extends IHwPackageManager.Stub {
        PackageManagerService mPMS;

        HwInnerPackageManagerService(PackageManagerService pms) {
            this.mPMS = pms;
        }

        public boolean isPerfOptEnable(String packageName, int optType) {
            return PackageManagerService.this.mHwPMSEx.isPerfOptEnable(packageName, optType);
        }

        public int getAppUseNotchMode(String packageName) {
            return PackageManagerService.this.mHwPMSEx.getAppUseNotchMode(packageName);
        }

        public void setAppUseNotchMode(String packageName, int mode) {
            PackageManagerService.this.mHwPMSEx.setAppUseNotchMode(packageName, mode);
        }

        public void setAppCanUninstall(String packageName, boolean canUninstall) {
            PackageManagerService.this.mHwPMSEx.setAppCanUninstall(packageName, canUninstall);
        }
    }

    private static class IFVerificationParams {
        Package pkg;
        boolean replacing;
        int userId;
        int verifierUid;

        public IFVerificationParams(Package _pkg, boolean _replacing, int _userId, int _verifierUid) {
            this.pkg = _pkg;
            this.replacing = _replacing;
            this.userId = _userId;
            this.replacing = _replacing;
            this.verifierUid = _verifierUid;
        }
    }

    static abstract class InstallArgs {
        final String abiOverride;
        final int installFlags;
        final String[] installGrantPermissions;
        final int installReason;
        final String installerPackageName;
        String[] instructionSets;
        final MoveInfo move;
        final IPackageInstallObserver2 observer;
        final OriginInfo origin;
        String packageName;
        int packageVersion;
        final SigningDetails signingDetails;
        final int traceCookie;
        final String traceMethod;
        final UserHandle user;
        final String volumeUuid;

        abstract void cleanUpResourcesLI();

        abstract int copyApk(IMediaContainerService iMediaContainerService, boolean z) throws RemoteException;

        abstract boolean doPostDeleteLI(boolean z);

        abstract int doPostInstall(int i, int i2);

        abstract int doPreInstall(int i);

        abstract boolean doRename(int i, Package packageR, String str);

        abstract String getCodePath();

        abstract String getResourcePath();

        InstallArgs(OriginInfo origin, MoveInfo move, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, String volumeUuid, UserHandle user, String[] instructionSets, String abiOverride, String[] installGrantPermissions, String traceMethod, int traceCookie, SigningDetails signingDetails, int installReason) {
            this.origin = origin;
            this.move = move;
            this.installFlags = installFlags;
            this.observer = observer;
            this.installerPackageName = installerPackageName;
            this.volumeUuid = volumeUuid;
            this.user = user;
            this.instructionSets = instructionSets;
            this.abiOverride = abiOverride;
            this.installGrantPermissions = installGrantPermissions;
            this.traceMethod = traceMethod;
            this.traceCookie = traceCookie;
            this.signingDetails = signingDetails;
            this.installReason = installReason;
        }

        int doPreCopy() {
            return 1;
        }

        int doPostCopy(int uid) {
            return 1;
        }

        protected boolean isFwdLocked() {
            return (this.installFlags & 1) != 0;
        }

        protected boolean isExternalAsec() {
            return (this.installFlags & 8) != 0;
        }

        protected boolean isEphemeral() {
            return (this.installFlags & 2048) != 0;
        }

        UserHandle getUser() {
            return this.user;
        }
    }

    private interface IntentFilterVerifier<T extends IntentFilter> {
        boolean addOneIntentFilterVerification(int i, int i2, int i3, T t, String str);

        void receiveVerificationResponse(int i);

        void startVerifications(int i);
    }

    private static class MoveCallbacks extends Handler {
        private static final int MSG_CREATED = 1;
        private static final int MSG_STATUS_CHANGED = 2;
        private final RemoteCallbackList<IPackageMoveObserver> mCallbacks = new RemoteCallbackList();
        private final SparseIntArray mLastStatus = new SparseIntArray();

        public MoveCallbacks(Looper looper) {
            super(looper);
        }

        public void register(IPackageMoveObserver callback) {
            this.mCallbacks.register(callback);
        }

        public void unregister(IPackageMoveObserver callback) {
            this.mCallbacks.unregister(callback);
        }

        public void handleMessage(Message msg) {
            SomeArgs args = msg.obj;
            int n = this.mCallbacks.beginBroadcast();
            for (int i = 0; i < n; i++) {
                try {
                    invokeCallback((IPackageMoveObserver) this.mCallbacks.getBroadcastItem(i), msg.what, args);
                } catch (RemoteException e) {
                }
            }
            this.mCallbacks.finishBroadcast();
            args.recycle();
        }

        private void invokeCallback(IPackageMoveObserver callback, int what, SomeArgs args) throws RemoteException {
            switch (what) {
                case 1:
                    callback.onCreated(args.argi1, (Bundle) args.arg2);
                    return;
                case 2:
                    callback.onStatusChanged(args.argi1, args.argi2, ((Long) args.arg3).longValue());
                    return;
                default:
                    return;
            }
        }

        private void notifyCreated(int moveId, Bundle extras) {
            String str = PackageManagerService.TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Move ");
            stringBuilder.append(moveId);
            stringBuilder.append(" created ");
            stringBuilder.append(extras.toString());
            Slog.v(str, stringBuilder.toString());
            SomeArgs args = SomeArgs.obtain();
            args.argi1 = moveId;
            args.arg2 = extras;
            obtainMessage(1, args).sendToTarget();
        }

        private void notifyStatusChanged(int moveId, int status) {
            notifyStatusChanged(moveId, status, -1);
        }

        private void notifyStatusChanged(int moveId, int status, long estMillis) {
            String str = PackageManagerService.TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Move ");
            stringBuilder.append(moveId);
            stringBuilder.append(" status ");
            stringBuilder.append(status);
            Slog.v(str, stringBuilder.toString());
            SomeArgs args = SomeArgs.obtain();
            args.argi1 = moveId;
            args.argi2 = status;
            args.arg3 = Long.valueOf(estMillis);
            obtainMessage(2, args).sendToTarget();
            synchronized (this.mLastStatus) {
                this.mLastStatus.put(moveId, status);
            }
        }
    }

    static class MoveInfo {
        final int appId;
        final String dataAppName;
        final String fromUuid;
        final int moveId;
        final String packageName;
        final String seinfo;
        final int targetSdkVersion;
        final String toUuid;

        public MoveInfo(int moveId, String fromUuid, String toUuid, String packageName, String dataAppName, int appId, String seinfo, int targetSdkVersion) {
            this.moveId = moveId;
            this.fromUuid = fromUuid;
            this.toUuid = toUuid;
            this.packageName = packageName;
            this.dataAppName = dataAppName;
            this.appId = appId;
            this.seinfo = seinfo;
            this.targetSdkVersion = targetSdkVersion;
        }
    }

    private static final class OnPermissionChangeListeners extends Handler {
        private static final int MSG_ON_PERMISSIONS_CHANGED = 1;
        private final RemoteCallbackList<IOnPermissionsChangeListener> mPermissionListeners = new RemoteCallbackList();

        public OnPermissionChangeListeners(Looper looper) {
            super(looper);
        }

        public void handleMessage(Message msg) {
            if (msg.what == 1) {
                handleOnPermissionsChanged(msg.arg1);
            }
        }

        public void addListenerLocked(IOnPermissionsChangeListener listener) {
            this.mPermissionListeners.register(listener);
        }

        public void removeListenerLocked(IOnPermissionsChangeListener listener) {
            this.mPermissionListeners.unregister(listener);
        }

        public void onPermissionsChanged(int uid) {
            if (this.mPermissionListeners.getRegisteredCallbackCount() > 0) {
                obtainMessage(1, uid, 0).sendToTarget();
            }
        }

        private void handleOnPermissionsChanged(int uid) {
            int count = this.mPermissionListeners.beginBroadcast();
            for (int i = 0; i < count; i++) {
                try {
                    ((IOnPermissionsChangeListener) this.mPermissionListeners.getBroadcastItem(i)).onPermissionsChanged(uid);
                } catch (RemoteException e) {
                    Log.e(PackageManagerService.TAG, "Permission listener is dead", e);
                } catch (Throwable th) {
                    this.mPermissionListeners.finishBroadcast();
                }
            }
            this.mPermissionListeners.finishBroadcast();
        }
    }

    static class OriginInfo {
        final boolean existing;
        final File file;
        final File resolvedFile;
        final String resolvedPath;
        final boolean staged;

        static OriginInfo fromNothing() {
            return new OriginInfo(null, false, false);
        }

        static OriginInfo fromUntrustedFile(File file) {
            return new OriginInfo(file, false, false);
        }

        static OriginInfo fromExistingFile(File file) {
            return new OriginInfo(file, false, true);
        }

        static OriginInfo fromStagedFile(File file) {
            return new OriginInfo(file, true, false);
        }

        private OriginInfo(File file, boolean staged, boolean existing) {
            this.file = file;
            this.staged = staged;
            this.existing = existing;
            if (file != null) {
                this.resolvedPath = file.getAbsolutePath();
                this.resolvedFile = file;
                return;
            }
            this.resolvedPath = null;
            this.resolvedFile = null;
        }
    }

    private class PackageFreezer implements AutoCloseable {
        private final PackageFreezer[] mChildren;
        private final CloseGuard mCloseGuard;
        private final AtomicBoolean mClosed;
        private final String mPackageName;
        private final boolean mWeFroze;

        public PackageFreezer() {
            this.mClosed = new AtomicBoolean();
            this.mCloseGuard = CloseGuard.get();
            this.mPackageName = null;
            this.mChildren = null;
            this.mWeFroze = false;
            this.mCloseGuard.open("close");
        }

        public PackageFreezer(String packageName, int userId, String killReason) {
            this.mClosed = new AtomicBoolean();
            this.mCloseGuard = CloseGuard.get();
            synchronized (PackageManagerService.this.mPackages) {
                this.mPackageName = packageName;
                this.mWeFroze = PackageManagerService.this.mFrozenPackages.add(this.mPackageName);
                String str = PackageManagerService.TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("mFrozenPackages add package:");
                stringBuilder.append(this.mPackageName);
                Slog.d(str, stringBuilder.toString());
                PackageSetting ps = (PackageSetting) PackageManagerService.this.mSettings.mPackages.get(this.mPackageName);
                if (ps != null) {
                    PackageManagerService.this.killApplication(ps.name, ps.appId, userId, killReason);
                }
                Package p = (Package) PackageManagerService.this.mPackages.get(packageName);
                if (p == null || p.childPackages == null) {
                    this.mChildren = null;
                } else {
                    int N = p.childPackages.size();
                    this.mChildren = new PackageFreezer[N];
                    for (int i = 0; i < N; i++) {
                        this.mChildren[i] = new PackageFreezer(((Package) p.childPackages.get(i)).packageName, userId, killReason);
                    }
                }
            }
            this.mCloseGuard.open("close");
        }

        protected void finalize() throws Throwable {
            try {
                if (this.mCloseGuard != null) {
                    this.mCloseGuard.warnIfOpen();
                }
                close();
            } finally {
                super.finalize();
            }
        }

        public void close() {
            this.mCloseGuard.close();
            int i = 0;
            if (this.mClosed.compareAndSet(false, true)) {
                synchronized (PackageManagerService.this.mPackages) {
                    if (this.mWeFroze) {
                        PackageManagerService.this.mFrozenPackages.remove(this.mPackageName);
                        String str = PackageManagerService.TAG;
                        StringBuilder stringBuilder = new StringBuilder();
                        stringBuilder.append("mFrozenPackages remove package:");
                        stringBuilder.append(this.mPackageName);
                        Slog.d(str, stringBuilder.toString());
                    }
                    if (this.mChildren != null) {
                        PackageFreezer[] packageFreezerArr = this.mChildren;
                        int length = packageFreezerArr.length;
                        while (i < length) {
                            packageFreezerArr[i].close();
                            i++;
                        }
                    }
                }
            }
        }
    }

    class PackageHandler extends Handler {
        private boolean mBound = false;
        final ArrayList<HandlerParams> mPendingInstalls = new ArrayList();

        private boolean connectToService() {
            if (PackageManagerService.DEBUG_INSTALL) {
                Log.i(PackageManagerService.TAG, "Trying to bind to DefaultContainerService");
            }
            Intent service = new Intent().setComponent(PackageManagerService.DEFAULT_CONTAINER_COMPONENT);
            Process.setThreadPriority(0);
            if (PackageManagerService.this.mContext.bindServiceAsUser(service, PackageManagerService.this.mDefContainerConn, 1, UserHandle.SYSTEM)) {
                Process.setThreadPriority(10);
                this.mBound = true;
                return true;
            }
            Process.setThreadPriority(10);
            return false;
        }

        private void disconnectService() {
            PackageManagerService.this.mContainerService = null;
            this.mBound = false;
            Process.setThreadPriority(0);
            PackageManagerService.this.mContext.unbindService(PackageManagerService.this.mDefContainerConn);
            Process.setThreadPriority(10);
        }

        PackageHandler(Looper looper) {
            super(looper);
        }

        public void handleMessage(Message msg) {
            try {
                doHandleMessage(msg);
            } finally {
                Process.setThreadPriority(10);
            }
        }

        /* JADX WARNING: Missing block: B:273:0x076e, code skipped:
            r4 = r5;
            r5 = r9;
            r28 = 0;
     */
        /* JADX WARNING: Missing block: B:274:0x0772, code skipped:
            r6 = r28;
     */
        /* JADX WARNING: Missing block: B:275:0x0774, code skipped:
            if (r6 >= r3) goto L_0x0784;
     */
        /* JADX WARNING: Missing block: B:276:0x0776, code skipped:
            r1.this$0.sendPackageChangedBroadcast(r0[r6], true, r4[r6], r5[r6]);
            r28 = r6 + 1;
     */
        /* JADX WARNING: Missing block: B:277:0x0784, code skipped:
            android.os.Process.setThreadPriority(10);
     */
        /* Code decompiled incorrectly, please refer to instructions dump. */
        void doHandleMessage(Message msg) {
            Message message = msg;
            boolean andCode = true;
            int i = 0;
            int size;
            int i2;
            HandlerParams params;
            Iterator it;
            HandlerParams params2;
            String str;
            StringBuilder stringBuilder;
            String packageName;
            int length;
            String str2;
            String installFailReason;
            PackageVerificationState state;
            InstallArgs args;
            Uri originUri;
            int ret;
            StringBuilder stringBuilder2;
            switch (message.what) {
                case 1:
                    Process.setThreadPriority(0);
                    synchronized (PackageManagerService.this.mPackages) {
                        try {
                            if (PackageManagerService.this.mPendingBroadcasts != null) {
                                size = PackageManagerService.this.mPendingBroadcasts.size();
                                if (size > 0) {
                                    String[] packages = new String[size];
                                    ArrayList<String>[] components = new ArrayList[size];
                                    int[] uids = new int[size];
                                    i2 = 0;
                                    for (int n = 0; n < PackageManagerService.this.mPendingBroadcasts.userIdCount(); n++) {
                                        int packageUserId = PackageManagerService.this.mPendingBroadcasts.userIdAt(n);
                                        Iterator<Entry<String, ArrayList<String>>> it2 = PackageManagerService.this.mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
                                        while (it2.hasNext() && i2 < size) {
                                            Entry<String, ArrayList<String>> ent = (Entry) it2.next();
                                            packages[i2] = (String) ent.getKey();
                                            components[i2] = (ArrayList) ent.getValue();
                                            PackageSetting ps = (PackageSetting) PackageManagerService.this.mSettings.mPackages.get(ent.getKey());
                                            if (ps != null) {
                                                i = UserHandle.getUid(packageUserId, ps.appId);
                                            } else {
                                                i = -1;
                                            }
                                            uids[i2] = i;
                                            i2++;
                                        }
                                    }
                                    size = i2;
                                    PackageManagerService.this.mPendingBroadcasts.clear();
                                    break;
                                }
                                return;
                            }
                            return;
                        } catch (Throwable th) {
                            while (true) {
                                throw th;
                                break;
                            }
                        }
                    }
                    break;
                case 3:
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Slog.i(PackageManagerService.TAG, "mcs_bound");
                    }
                    if (message.obj != null) {
                        PackageManagerService.this.mContainerService = (IMediaContainerService) message.obj;
                        Trace.asyncTraceEnd(262144, "bindingMCS", System.identityHashCode(PackageManagerService.this.mHandler));
                    }
                    if (PackageManagerService.this.mContainerService != null) {
                        if (this.mPendingInstalls.size() <= 0) {
                            Slog.w(PackageManagerService.TAG, "Empty queue");
                            break;
                        }
                        params = (HandlerParams) this.mPendingInstalls.get(0);
                        if (params != null) {
                            Trace.asyncTraceEnd(262144, "queueInstall", System.identityHashCode(params));
                            Trace.traceBegin(262144, "startCopy");
                            if (params.startCopy()) {
                                if (this.mPendingInstalls.size() > 0) {
                                    this.mPendingInstalls.remove(0);
                                }
                                if (this.mPendingInstalls.size() != 0) {
                                    PackageManagerService.this.mHandler.sendEmptyMessage(3);
                                } else if (this.mBound) {
                                    removeMessages(6);
                                    sendMessageDelayed(obtainMessage(6), 10000);
                                }
                            }
                            Trace.traceEnd(262144);
                            break;
                        }
                    } else if (!this.mBound) {
                        Slog.e(PackageManagerService.TAG, "Cannot bind to media container service");
                        it = this.mPendingInstalls.iterator();
                        while (it.hasNext()) {
                            params2 = (HandlerParams) it.next();
                            params2.serviceError();
                            Trace.asyncTraceEnd(262144, "queueInstall", System.identityHashCode(params2));
                            if (params2.traceMethod != null) {
                                Trace.asyncTraceEnd(262144, params2.traceMethod, params2.traceCookie);
                            }
                        }
                        this.mPendingInstalls.clear();
                        break;
                    } else {
                        Slog.w(PackageManagerService.TAG, "Waiting to connect to media container service");
                        break;
                    }
                    break;
                case 5:
                    params = message.obj;
                    size = this.mPendingInstalls.size();
                    if (PackageManagerService.DEBUG_INSTALL) {
                        str = PackageManagerService.TAG;
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("init_copy idx=");
                        stringBuilder.append(size);
                        stringBuilder.append(": ");
                        stringBuilder.append(params);
                        Slog.i(str, stringBuilder.toString());
                    }
                    if (!this.mBound) {
                        Trace.asyncTraceBegin(262144, "bindingMCS", System.identityHashCode(PackageManagerService.this.mHandler));
                        if (connectToService()) {
                            this.mPendingInstalls.add(size, params);
                            break;
                        }
                        Slog.e(PackageManagerService.TAG, "Failed to bind to media container service");
                        params.serviceError();
                        Trace.asyncTraceEnd(262144, "bindingMCS", System.identityHashCode(PackageManagerService.this.mHandler));
                        if (params.traceMethod != null) {
                            Trace.asyncTraceEnd(262144, params.traceMethod, params.traceCookie);
                        }
                        return;
                    }
                    this.mPendingInstalls.add(size, params);
                    if (size == 0) {
                        PackageManagerService.this.mHandler.sendEmptyMessage(3);
                        break;
                    }
                    break;
                case 6:
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Slog.i(PackageManagerService.TAG, "mcs_unbind");
                    }
                    if (this.mPendingInstalls.size() != 0 || PackageManagerService.this.mPendingVerification.size() != 0) {
                        if (this.mPendingInstalls.size() > 0) {
                            PackageManagerService.this.mHandler.sendEmptyMessage(3);
                            break;
                        }
                    } else if (this.mBound) {
                        if (PackageManagerService.DEBUG_INSTALL) {
                            Slog.i(PackageManagerService.TAG, "calling disconnectService()");
                        }
                        disconnectService();
                        break;
                    }
                    break;
                case 7:
                    Process.setThreadPriority(0);
                    packageName = message.obj;
                    int userId = message.arg1;
                    if (message.arg2 == 0) {
                        andCode = false;
                    }
                    synchronized (PackageManagerService.this.mPackages) {
                        if (userId == -1) {
                            try {
                                int[] users = PackageManagerService.sUserManager.getUserIds();
                                length = users.length;
                                while (i < length) {
                                    PackageManagerService.this.mSettings.addPackageToCleanLPw(new PackageCleanItem(users[i], packageName, andCode));
                                    i++;
                                }
                            } catch (Throwable th2) {
                                while (true) {
                                    throw th2;
                                    break;
                                }
                            }
                        }
                        PackageManagerService.this.mSettings.addPackageToCleanLPw(new PackageCleanItem(userId, packageName, andCode));
                    }
                    Process.setThreadPriority(10);
                    PackageManagerService.this.startCleaningPackages();
                    break;
                case 9:
                    if (PackageManagerService.DEBUG_INSTALL) {
                        str2 = PackageManagerService.TAG;
                        StringBuilder stringBuilder3 = new StringBuilder();
                        stringBuilder3.append("Handling post-install for ");
                        stringBuilder3.append(message.arg1);
                        Log.v(str2, stringBuilder3.toString());
                    }
                    PostInstallData data = (PostInstallData) PackageManagerService.this.mRunningInstalls.get(message.arg1);
                    boolean didRestore = message.arg2 != 0;
                    PackageManagerService.this.mRunningInstalls.delete(message.arg1);
                    if (data != null) {
                        InstallArgs args2 = data.args;
                        PackageInstalledInfo parentRes = data.res;
                        if (1 != parentRes.returnCode) {
                            installFailReason = new StringBuilder();
                            installFailReason.append("{pkg:");
                            installFailReason.append(parentRes.name);
                            installFailReason.append("pkgName:");
                            installFailReason.append(args2.packageName);
                            installFailReason.append(",Ver:");
                            installFailReason.append(args2.packageVersion);
                            installFailReason.append(",ErrNum:");
                            installFailReason.append(parentRes.returnCode);
                            installFailReason.append(",Intaller:");
                            installFailReason.append(args2.installerPackageName);
                            installFailReason.append(",Msg:");
                            installFailReason.append(parentRes.returnMsg);
                            installFailReason.append("}");
                            PackageManagerService.this.uploadInstallErrRadar(installFailReason.toString());
                        }
                        boolean grantPermissions = (args2.installFlags & 256) != 0;
                        if (parentRes.pkg != null) {
                            PackageManagerService.this.addGrantedInstalledPkg(parentRes.pkg.packageName, grantPermissions);
                        }
                        boolean killApp = (args2.installFlags & 4096) == 0;
                        boolean virtualPreload = (args2.installFlags & 65536) != 0;
                        String[] grantedPermissions = args2.installGrantPermissions;
                        PackageManagerService.this.handlePackagePostInstall(parentRes, grantPermissions, killApp, virtualPreload, grantedPermissions, didRestore, args2.installerPackageName, args2.observer);
                        int childCount = parentRes.addedChildPackages != null ? parentRes.addedChildPackages.size() : 0;
                        while (i < childCount) {
                            PackageManagerService.this.handlePackagePostInstall((PackageInstalledInfo) parentRes.addedChildPackages.valueAt(i), grantPermissions, killApp, virtualPreload, grantedPermissions, false, args2.installerPackageName, args2.observer);
                            i++;
                        }
                        if (!(parentRes.pkg == null || (PackageManagerService.isSystemApp(parentRes.pkg) && (parentRes.pkg.applicationInfo.hwFlags & DumpState.DUMP_HANDLE) == 0 && (parentRes.pkg.applicationInfo.hwFlags & 67108864) == 0))) {
                            PackageManagerService.this.parseInstalledPkgInfo(args2, parentRes);
                        }
                        SmartShrinker.reclaim(Process.myPid(), 3);
                        if (args2.traceMethod != null) {
                            Trace.asyncTraceEnd(262144, args2.traceMethod, args2.traceCookie);
                        }
                    } else {
                        packageName = PackageManagerService.TAG;
                        StringBuilder stringBuilder4 = new StringBuilder();
                        stringBuilder4.append("Bogus post-install token ");
                        stringBuilder4.append(message.arg1);
                        Slog.e(packageName, stringBuilder4.toString());
                    }
                    Trace.asyncTraceEnd(262144, "postInstall", message.arg1);
                    break;
                case 10:
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Slog.i(PackageManagerService.TAG, "mcs_reconnect");
                    }
                    if (this.mPendingInstalls.size() > 0) {
                        if (this.mBound) {
                            disconnectService();
                        }
                        if (!connectToService()) {
                            Slog.e(PackageManagerService.TAG, "Failed to bind to media container service");
                            it = this.mPendingInstalls.iterator();
                            while (it.hasNext()) {
                                params2 = (HandlerParams) it.next();
                                params2.serviceError();
                                Trace.asyncTraceEnd(262144, "queueInstall", System.identityHashCode(params2));
                            }
                            this.mPendingInstalls.clear();
                            break;
                        }
                    }
                    break;
                case 11:
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Slog.i(PackageManagerService.TAG, "mcs_giveup too many retries");
                    }
                    Trace.asyncTraceEnd(262144, "queueInstall", System.identityHashCode((HandlerParams) this.mPendingInstalls.remove(0)));
                    break;
                case 13:
                    Process.setThreadPriority(0);
                    synchronized (PackageManagerService.this.mPackages) {
                        try {
                            removeMessages(13);
                            removeMessages(14);
                            PackageManagerService.this.mSettings.writeLPr();
                            PackageManagerService.this.mDirtyUsers.clear();
                        } catch (Throwable th22) {
                            while (true) {
                                throw th22;
                                break;
                            }
                        }
                    }
                    Process.setThreadPriority(10);
                    break;
                case 14:
                    Process.setThreadPriority(0);
                    synchronized (PackageManagerService.this.mPackages) {
                        try {
                            removeMessages(14);
                            it = PackageManagerService.this.mDirtyUsers.iterator();
                            while (it.hasNext()) {
                                PackageManagerService.this.mSettings.writePackageRestrictionsLPr(((Integer) it.next()).intValue());
                            }
                            PackageManagerService.this.mDirtyUsers.clear();
                        } catch (Throwable th222) {
                            while (true) {
                                throw th222;
                                break;
                            }
                        }
                    }
                    Process.setThreadPriority(10);
                    break;
                case 15:
                    size = message.arg1;
                    state = (PackageVerificationState) PackageManagerService.this.mPendingVerification.get(size);
                    if (state != null) {
                        PackageVerificationResponse response = message.obj;
                        state.setVerifierResponse(response.callerUid, response.code);
                        if (state.isVerificationComplete()) {
                            PackageManagerService.this.mPendingVerification.remove(size);
                            args = state.getInstallArgs();
                            originUri = Uri.fromFile(args.origin.resolvedFile);
                            if (state.isInstallAllowed()) {
                                i2 = RequestStatus.SYS_ETIMEDOUT;
                                PackageManagerService.this.broadcastPackageVerified(size, originUri, response.code, state.getInstallArgs().getUser());
                                try {
                                    i2 = args.copyApk(PackageManagerService.this.mContainerService, true);
                                } catch (RemoteException e) {
                                    Slog.e(PackageManagerService.TAG, "Could not contact the ContainerService");
                                }
                            } else {
                                i2 = -22;
                            }
                            ret = i2;
                            Trace.asyncTraceEnd(262144, "verification", size);
                            PackageManagerService.this.processPendingInstall(args, ret);
                            PackageManagerService.this.mHandler.sendEmptyMessage(6);
                            break;
                        }
                    }
                    str2 = PackageManagerService.TAG;
                    stringBuilder2 = new StringBuilder();
                    stringBuilder2.append("Invalid verification token ");
                    stringBuilder2.append(size);
                    stringBuilder2.append(" received");
                    Slog.w(str2, stringBuilder2.toString());
                    break;
                    break;
                case 16:
                    size = message.arg1;
                    state = (PackageVerificationState) PackageManagerService.this.mPendingVerification.get(size);
                    if (!(state == null || state.timeoutExtended())) {
                        args = state.getInstallArgs();
                        originUri = Uri.fromFile(args.origin.resolvedFile);
                        str2 = PackageManagerService.TAG;
                        StringBuilder stringBuilder5 = new StringBuilder();
                        stringBuilder5.append("Verification timed out for ");
                        stringBuilder5.append(originUri);
                        Slog.i(str2, stringBuilder5.toString());
                        PackageManagerService.this.mPendingVerification.remove(size);
                        i2 = -22;
                        UserHandle user = args.getUser();
                        if (PackageManagerService.this.getDefaultVerificationResponse(user) == 1) {
                            str2 = PackageManagerService.TAG;
                            stringBuilder = new StringBuilder();
                            stringBuilder.append("Continuing with installation of ");
                            stringBuilder.append(originUri);
                            Slog.i(str2, stringBuilder.toString());
                            state.setVerifierResponse(Binder.getCallingUid(), 2);
                            PackageManagerService.this.broadcastPackageVerified(size, originUri, 1, user);
                            try {
                                i2 = args.copyApk(PackageManagerService.this.mContainerService, true);
                            } catch (RemoteException e2) {
                                Slog.e(PackageManagerService.TAG, "Could not contact the ContainerService");
                            }
                        } else {
                            PackageManagerService.this.broadcastPackageVerified(size, originUri, -1, user);
                        }
                        Trace.asyncTraceEnd(262144, "verification", size);
                        PackageManagerService.this.processPendingInstall(args, i2);
                        PackageManagerService.this.mHandler.sendEmptyMessage(6);
                        break;
                    }
                case 17:
                    IFVerificationParams params3 = message.obj;
                    PackageManagerService.this.verifyIntentFiltersIfNeeded(params3.userId, params3.verifierUid, params3.replacing, params3.pkg);
                    break;
                case 18:
                    ret = message.arg1;
                    IntentFilterVerificationState state2 = (IntentFilterVerificationState) PackageManagerService.this.mIntentFilterVerificationStates.get(ret);
                    if (state2 != null) {
                        StringBuilder stringBuilder6;
                        length = state2.getUserId();
                        if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            str = PackageManagerService.TAG;
                            stringBuilder6 = new StringBuilder();
                            stringBuilder6.append("Processing IntentFilter verification with token:");
                            stringBuilder6.append(ret);
                            stringBuilder6.append(" and userId:");
                            stringBuilder6.append(length);
                            Slog.d(str, stringBuilder6.toString());
                        }
                        IntentFilterVerificationResponse response2 = message.obj;
                        state2.setVerifierResponse(response2.callerUid, response2.code);
                        if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            String str3 = PackageManagerService.TAG;
                            StringBuilder stringBuilder7 = new StringBuilder();
                            stringBuilder7.append("IntentFilter verification with token:");
                            stringBuilder7.append(ret);
                            stringBuilder7.append(" and userId:");
                            stringBuilder7.append(length);
                            stringBuilder7.append(" is settings verifier response with response code:");
                            stringBuilder7.append(response2.code);
                            Slog.d(str3, stringBuilder7.toString());
                        }
                        if (response2.code == -1 && PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            installFailReason = PackageManagerService.TAG;
                            stringBuilder6 = new StringBuilder();
                            stringBuilder6.append("Domains failing verification: ");
                            stringBuilder6.append(response2.getFailedDomainsString());
                            Slog.d(installFailReason, stringBuilder6.toString());
                        }
                        if (!state2.isVerificationComplete()) {
                            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                                installFailReason = PackageManagerService.TAG;
                                stringBuilder6 = new StringBuilder();
                                stringBuilder6.append("IntentFilter verification with token:");
                                stringBuilder6.append(ret);
                                stringBuilder6.append(" was not said to be complete");
                                Slog.d(installFailReason, stringBuilder6.toString());
                                break;
                            }
                        }
                        PackageManagerService.this.mIntentFilterVerifier.receiveVerificationResponse(ret);
                        break;
                    }
                    String str4 = PackageManagerService.TAG;
                    stringBuilder2 = new StringBuilder();
                    stringBuilder2.append("Invalid IntentFilter verification token ");
                    stringBuilder2.append(ret);
                    stringBuilder2.append(" received");
                    Slog.w(str4, stringBuilder2.toString());
                    break;
                    break;
                case 19:
                    Process.setThreadPriority(0);
                    synchronized (PackageManagerService.this.mPackages) {
                        try {
                            removeMessages(19);
                            PackageManagerService.this.mSettings.writePackageListLPr(message.arg1);
                        } catch (Throwable th2222) {
                            while (true) {
                                throw th2222;
                                break;
                            }
                        }
                    }
                    Process.setThreadPriority(10);
                    break;
                case 20:
                    InstantAppResolver.doInstantAppResolutionPhaseTwo(PackageManagerService.this.mContext, PackageManagerService.this.mInstantAppResolverConnection, (InstantAppRequest) message.obj, PackageManagerService.this.mInstantAppInstallerActivity, PackageManagerService.this.mHandler);
                    break;
                case 21:
                    if (!this.mBound) {
                        Trace.asyncTraceBegin(262144, "earlyBindingMCS", System.identityHashCode(PackageManagerService.this.mHandler));
                        if (!connectToService()) {
                            Slog.e(PackageManagerService.TAG, "Failed to bind to media container service");
                        }
                        Trace.asyncTraceEnd(262144, "earlyBindingMCS", System.identityHashCode(PackageManagerService.this.mHandler));
                        break;
                    }
                    break;
            }
        }
    }

    static class PackageInstalledInfo {
        ArrayMap<String, PackageInstalledInfo> addedChildPackages;
        String installerPackageName;
        String name;
        int[] newUsers;
        String origPackage;
        String origPermission;
        int[] origUsers;
        Package pkg;
        PackageRemovedInfo removedInfo;
        int returnCode;
        String returnMsg;
        int uid;

        PackageInstalledInfo() {
        }

        public void setError(int code, String msg) {
            setReturnCode(code);
            setReturnMessage(msg);
            Slog.w(PackageManagerService.TAG, msg);
        }

        public void setError(String msg, PackageParserException e) {
            setReturnCode(e.error);
            setReturnMessage(ExceptionUtils.getCompleteMessage(msg, e));
            int i = 0;
            int childCount = this.addedChildPackages != null ? this.addedChildPackages.size() : 0;
            while (i < childCount) {
                ((PackageInstalledInfo) this.addedChildPackages.valueAt(i)).setError(msg, e);
                i++;
            }
            Slog.w(PackageManagerService.TAG, msg, e);
        }

        public void setError(String msg, PackageManagerException e) {
            this.returnCode = e.error;
            setReturnMessage(ExceptionUtils.getCompleteMessage(msg, e));
            int i = 0;
            int childCount = this.addedChildPackages != null ? this.addedChildPackages.size() : 0;
            while (i < childCount) {
                ((PackageInstalledInfo) this.addedChildPackages.valueAt(i)).setError(msg, e);
                i++;
            }
            Slog.w(PackageManagerService.TAG, msg, e);
        }

        public void setReturnCode(int returnCode) {
            this.returnCode = returnCode;
            int i = 0;
            int childCount = this.addedChildPackages != null ? this.addedChildPackages.size() : 0;
            while (i < childCount) {
                ((PackageInstalledInfo) this.addedChildPackages.valueAt(i)).returnCode = returnCode;
                i++;
            }
        }

        private void setReturnMessage(String returnMsg) {
            this.returnMsg = returnMsg;
            int i = 0;
            int childCount = this.addedChildPackages != null ? this.addedChildPackages.size() : 0;
            while (i < childCount) {
                ((PackageInstalledInfo) this.addedChildPackages.valueAt(i)).returnMsg = returnMsg;
                i++;
            }
        }
    }

    private class PackageManagerInternalImpl extends PackageManagerInternal {
        private PackageManagerInternalImpl() {
        }

        /* synthetic */ PackageManagerInternalImpl(PackageManagerService x0, AnonymousClass1 x1) {
            this();
        }

        public void updatePermissionFlagsTEMP(String permName, String packageName, int flagMask, int flagValues, int userId) {
            PackageManagerService.this.updatePermissionFlags(permName, packageName, flagMask, flagValues, userId);
        }

        public boolean isDataRestoreSafe(byte[] restoringFromSigHash, String packageName) {
            SigningDetails sd = getSigningDetails(packageName);
            if (sd == null) {
                return false;
            }
            return sd.hasSha256Certificate(restoringFromSigHash, 1);
        }

        public boolean isDataRestoreSafe(Signature restoringFromSig, String packageName) {
            SigningDetails sd = getSigningDetails(packageName);
            if (sd == null) {
                return false;
            }
            return sd.hasCertificate(restoringFromSig, 1);
        }

        public boolean hasSignatureCapability(int serverUid, int clientUid, @CertCapabilities int capability) {
            SigningDetails serverSigningDetails = getSigningDetails(serverUid);
            SigningDetails clientSigningDetails = getSigningDetails(clientUid);
            return serverSigningDetails.checkCapability(clientSigningDetails, capability) || clientSigningDetails.hasAncestorOrSelf(serverSigningDetails);
        }

        private SigningDetails getSigningDetails(String packageName) {
            synchronized (PackageManagerService.this.mPackages) {
                Package p = (Package) PackageManagerService.this.mPackages.get(packageName);
                if (p == null) {
                    return null;
                }
                SigningDetails signingDetails = p.mSigningDetails;
                return signingDetails;
            }
        }

        private SigningDetails getSigningDetails(int uid) {
            synchronized (PackageManagerService.this.mPackages) {
                SigningDetails signingDetails;
                PackageSetting obj = PackageManagerService.this.mSettings.getUserIdLPr(UserHandle.getAppId(uid));
                if (obj != null) {
                    if (obj instanceof SharedUserSetting) {
                        signingDetails = ((SharedUserSetting) obj).signatures.mSigningDetails;
                        return signingDetails;
                    } else if (obj instanceof PackageSetting) {
                        SigningDetails signingDetails2 = obj.signatures.mSigningDetails;
                        return signingDetails2;
                    }
                }
                signingDetails = SigningDetails.UNKNOWN;
                return signingDetails;
            }
        }

        public int getPermissionFlagsTEMP(String permName, String packageName, int userId) {
            return PackageManagerService.this.getPermissionFlags(permName, packageName, userId);
        }

        public boolean isInstantApp(String packageName, int userId) {
            return PackageManagerService.this.isInstantApp(packageName, userId);
        }

        public String getInstantAppPackageName(int uid) {
            return PackageManagerService.this.getInstantAppPackageName(uid);
        }

        public boolean filterAppAccess(Package pkg, int callingUid, int userId) {
            boolean access$7300;
            synchronized (PackageManagerService.this.mPackages) {
                access$7300 = PackageManagerService.this.filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, userId);
            }
            return access$7300;
        }

        public Package getPackage(String packageName) {
            Package packageR;
            synchronized (PackageManagerService.this.mPackages) {
                packageR = (Package) PackageManagerService.this.mPackages.get(PackageManagerService.this.resolveInternalPackageNameLPr(packageName, -1));
            }
            return packageR;
        }

        public PackageList getPackageList(PackageListObserver observer) {
            PackageList packageList;
            synchronized (PackageManagerService.this.mPackages) {
                int N = PackageManagerService.this.mPackages.size();
                ArrayList<String> list = new ArrayList(N);
                for (int i = 0; i < N; i++) {
                    list.add((String) PackageManagerService.this.mPackages.keyAt(i));
                }
                packageList = new PackageList(list, observer);
                if (observer != null) {
                    PackageManagerService.this.mPackageListObservers.add(packageList);
                }
            }
            return packageList;
        }

        public void removePackageListObserver(PackageListObserver observer) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mPackageListObservers.remove(observer);
            }
        }

        public Package getDisabledPackage(String packageName) {
            Package packageR;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.getDisabledSystemPkgLPr(packageName);
                packageR = ps != null ? ps.pkg : null;
            }
            return packageR;
        }

        public String getKnownPackageName(int knownPackage, int userId) {
            switch (knownPackage) {
                case 0:
                    return PackageManagerService.PLATFORM_PACKAGE_NAME;
                case 1:
                    return PackageManagerService.this.mSetupWizardPackage;
                case 2:
                    return PackageManagerService.this.mRequiredInstallerPackage;
                case 3:
                    return PackageManagerService.this.mRequiredVerifierPackage;
                case 4:
                    return PackageManagerService.this.getDefaultBrowserPackageName(userId);
                case 5:
                    return PackageManagerService.this.mSystemTextClassifierPackage;
                default:
                    return null;
            }
        }

        public boolean isResolveActivityComponent(ComponentInfo component) {
            return PackageManagerService.this.mResolveActivity.packageName.equals(component.packageName) && PackageManagerService.this.mResolveActivity.name.equals(component.name);
        }

        public void setLocationPackagesProvider(PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setLocationPackagesProvider(provider);
        }

        public void setVoiceInteractionPackagesProvider(PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setVoiceInteractionPackagesProvider(provider);
        }

        public void setSmsAppPackagesProvider(PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setSmsAppPackagesProvider(provider);
        }

        public void setDialerAppPackagesProvider(PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setDialerAppPackagesProvider(provider);
        }

        public void setSimCallManagerPackagesProvider(PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setSimCallManagerPackagesProvider(provider);
        }

        public void setUseOpenWifiAppPackagesProvider(PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setUseOpenWifiAppPackagesProvider(provider);
        }

        public void setSyncAdapterPackagesprovider(SyncAdapterPackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setSyncAdapterPackagesProvider(provider);
        }

        public void grantDefaultPermissionsToDefaultSmsApp(String packageName, int userId) {
            PackageManagerService.this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultSmsApp(packageName, userId);
        }

        public void grantDefaultPermissionsToDefaultDialerApp(String packageName, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mSettings.setDefaultDialerPackageNameLPw(packageName, userId);
            }
            PackageManagerService.this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultDialerApp(packageName, userId);
        }

        public void grantDefaultPermissionsToDefaultSimCallManager(String packageName, int userId) {
            PackageManagerService.this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultSimCallManager(packageName, userId);
        }

        public void grantDefaultPermissionsToDefaultUseOpenWifiApp(String packageName, int userId) {
            PackageManagerService.this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultUseOpenWifiApp(packageName, userId);
        }

        /* JADX WARNING: Missing block: B:28:0x006a, code skipped:
            return;
     */
        /* Code decompiled incorrectly, please refer to instructions dump. */
        public void setKeepUninstalledPackages(List<String> packageList) {
            Throwable th;
            Preconditions.checkNotNull(packageList);
            List<String> removedFromList = null;
            synchronized (PackageManagerService.this.mPackages) {
                try {
                    int packagesCount;
                    int i = 0;
                    if (PackageManagerService.this.mKeepUninstalledPackages != null) {
                        packagesCount = PackageManagerService.this.mKeepUninstalledPackages.size();
                        List<String> removedFromList2 = null;
                        int i2 = 0;
                        while (i2 < packagesCount) {
                            try {
                                String oldPackage = (String) PackageManagerService.this.mKeepUninstalledPackages.get(i2);
                                if (packageList == null || !packageList.contains(oldPackage)) {
                                    if (removedFromList2 == null) {
                                        removedFromList2 = new ArrayList();
                                    }
                                    removedFromList2.add(oldPackage);
                                }
                                i2++;
                            } catch (Throwable th2) {
                                th = th2;
                                removedFromList = removedFromList2;
                                throw th;
                            }
                        }
                        removedFromList = removedFromList2;
                    }
                    PackageManagerService.this.mKeepUninstalledPackages = new ArrayList(packageList);
                    if (removedFromList != null) {
                        packagesCount = removedFromList.size();
                        while (i < packagesCount) {
                            PackageManagerService.this.deletePackageIfUnusedLPr((String) removedFromList.get(i));
                            i++;
                        }
                    }
                } catch (Throwable th3) {
                    th = th3;
                    throw th;
                }
            }
        }

        public boolean isPermissionsReviewRequired(String packageName, int userId) {
            boolean isPermissionsReviewRequired;
            synchronized (PackageManagerService.this.mPackages) {
                isPermissionsReviewRequired = PackageManagerService.this.mPermissionManager.isPermissionsReviewRequired((Package) PackageManagerService.this.mPackages.get(packageName), userId);
            }
            return isPermissionsReviewRequired;
        }

        public PackageInfo getPackageInfo(String packageName, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getPackageInfoInternal(packageName, -1, flags, filterCallingUid, userId);
        }

        public Bundle getSuspendedPackageLauncherExtras(String packageName, int userId) {
            Bundle bundle;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = (PackageSetting) PackageManagerService.this.mSettings.mPackages.get(packageName);
                PersistableBundle launcherExtras = null;
                if (ps != null) {
                    launcherExtras = ps.readUserState(userId).suspendedLauncherExtras;
                }
                bundle = launcherExtras != null ? new Bundle(launcherExtras.deepCopy()) : null;
            }
            return bundle;
        }

        public boolean isPackageSuspended(String packageName, int userId) {
            boolean suspended;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = (PackageSetting) PackageManagerService.this.mSettings.mPackages.get(packageName);
                suspended = ps != null ? ps.getSuspended(userId) : false;
            }
            return suspended;
        }

        public String getSuspendingPackage(String suspendedPackage, int userId) {
            String str;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = (PackageSetting) PackageManagerService.this.mSettings.mPackages.get(suspendedPackage);
                str = ps != null ? ps.readUserState(userId).suspendingPackage : null;
            }
            return str;
        }

        public String getSuspendedDialogMessage(String suspendedPackage, int userId) {
            String str;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = (PackageSetting) PackageManagerService.this.mSettings.mPackages.get(suspendedPackage);
                str = ps != null ? ps.readUserState(userId).dialogMessage : null;
            }
            return str;
        }

        public int getPackageUid(String packageName, int flags, int userId) {
            return PackageManagerService.this.getPackageUid(packageName, flags, userId);
        }

        public ApplicationInfo getApplicationInfo(String packageName, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getApplicationInfoInternal(packageName, flags, filterCallingUid, userId);
        }

        public ActivityInfo getActivityInfo(ComponentName component, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getActivityInfoInternal(component, flags, filterCallingUid, userId);
        }

        public List<ResolveInfo> queryIntentActivities(Intent intent, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.queryIntentActivitiesInternal(intent, intent.resolveTypeIfNeeded(PackageManagerService.this.mContext.getContentResolver()), flags, filterCallingUid, userId, false, true);
        }

        public List<ResolveInfo> queryIntentServices(Intent intent, int flags, int callingUid, int userId) {
            return PackageManagerService.this.queryIntentServicesInternal(intent, intent.resolveTypeIfNeeded(PackageManagerService.this.mContext.getContentResolver()), flags, userId, callingUid, false);
        }

        public ComponentName getHomeActivitiesAsUser(List<ResolveInfo> allHomeCandidates, int userId) {
            return PackageManagerService.this.getHomeActivitiesAsUser(allHomeCandidates, userId);
        }

        public ComponentName getDefaultHomeActivity(int userId) {
            return PackageManagerService.this.getDefaultHomeActivity(userId);
        }

        public void setDeviceAndProfileOwnerPackages(int deviceOwnerUserId, String deviceOwnerPackage, SparseArray<String> profileOwnerPackages) {
            PackageManagerService.this.mProtectedPackages.setDeviceAndProfileOwnerPackages(deviceOwnerUserId, deviceOwnerPackage, profileOwnerPackages);
            ArraySet<Integer> usersWithPoOrDo = new ArraySet();
            if (deviceOwnerPackage != null) {
                usersWithPoOrDo.add(Integer.valueOf(deviceOwnerUserId));
            }
            int sz = profileOwnerPackages.size();
            for (int i = 0; i < sz; i++) {
                if (profileOwnerPackages.valueAt(i) != null) {
                    usersWithPoOrDo.add(Integer.valueOf(profileOwnerPackages.keyAt(i)));
                }
            }
            PackageManagerService.this.unsuspendForNonSystemSuspendingPackages(usersWithPoOrDo);
        }

        public boolean isPackageDataProtected(int userId, String packageName) {
            return PackageManagerService.this.mProtectedPackages.isPackageDataProtected(userId, packageName);
        }

        public boolean isPackageStateProtected(String packageName, int userId) {
            return PackageManagerService.this.mProtectedPackages.isPackageStateProtected(userId, packageName);
        }

        public boolean isPackageEphemeral(int userId, String packageName) {
            boolean instantApp;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = (PackageSetting) PackageManagerService.this.mSettings.mPackages.get(packageName);
                instantApp = ps != null ? ps.getInstantApp(userId) : false;
            }
            return instantApp;
        }

        public boolean wasPackageEverLaunched(String packageName, int userId) {
            boolean wasPackageEverLaunchedLPr;
            synchronized (PackageManagerService.this.mPackages) {
                wasPackageEverLaunchedLPr = PackageManagerService.this.mSettings.wasPackageEverLaunchedLPr(packageName, userId);
            }
            return wasPackageEverLaunchedLPr;
        }

        public void grantRuntimePermission(String packageName, String permName, int userId, boolean overridePolicy) {
            PackageManagerService.this.mPermissionManager.grantRuntimePermission(permName, packageName, overridePolicy, Binder.getCallingUid(), userId, PackageManagerService.this.mPermissionCallback);
        }

        public void revokeRuntimePermission(String packageName, String permName, int userId, boolean overridePolicy) {
            PackageManagerService.this.mPermissionManager.revokeRuntimePermission(permName, packageName, overridePolicy, Binder.getCallingUid(), userId, PackageManagerService.this.mPermissionCallback);
        }

        public String getNameForUid(int uid) {
            return PackageManagerService.this.getNameForUid(uid);
        }

        public void requestInstantAppResolutionPhaseTwo(AuxiliaryResolveInfo responseObj, Intent origIntent, String resolvedType, String callingPackage, Bundle verificationBundle, int userId) {
            PackageManagerService.this.requestInstantAppResolutionPhaseTwo(responseObj, origIntent, resolvedType, callingPackage, verificationBundle, userId);
        }

        public void grantEphemeralAccess(int userId, Intent intent, int targetAppId, int ephemeralAppId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mInstantAppRegistry.grantInstantAccessLPw(userId, intent, targetAppId, ephemeralAppId);
            }
        }

        public boolean isInstantAppInstallerComponent(ComponentName component) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                z = PackageManagerService.this.mInstantAppInstallerActivity != null && PackageManagerService.this.mInstantAppInstallerActivity.getComponentName().equals(component);
            }
            return z;
        }

        public void pruneInstantApps() {
            PackageManagerService.this.mInstantAppRegistry.pruneInstantApps();
        }

        public String getSetupWizardPackageName() {
            return PackageManagerService.this.mSetupWizardPackage;
        }

        public void setExternalSourcesPolicy(ExternalSourcesPolicy policy) {
            if (policy != null) {
                PackageManagerService.this.mExternalSourcesPolicy = policy;
            }
        }

        public boolean isPackagePersistent(String packageName) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                Package pkg = (Package) PackageManagerService.this.mPackages.get(packageName);
                z = false;
                if (pkg != null) {
                    if ((pkg.applicationInfo.flags & 9) == 9) {
                        z = true;
                    }
                }
            }
            return z;
        }

        public boolean isLegacySystemApp(Package pkg) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = pkg.mExtras;
                z = PackageManagerService.this.mPromoteSystemApps && ps.isSystem() && PackageManagerService.this.mExistingSystemPackages.contains(ps.name);
            }
            return z;
        }

        public List<PackageInfo> getOverlayPackages(int userId) {
            ArrayList<PackageInfo> overlayPackages = new ArrayList();
            synchronized (PackageManagerService.this.mPackages) {
                for (Package p : PackageManagerService.this.mPackages.values()) {
                    if (p.mOverlayTarget != null) {
                        PackageInfo pkg = PackageManagerService.this.generatePackageInfo((PackageSetting) p.mExtras, 0, userId);
                        if (pkg != null) {
                            overlayPackages.add(pkg);
                        }
                    }
                }
            }
            return overlayPackages;
        }

        public List<String> getTargetPackageNames(int userId) {
            List<String> targetPackages = new ArrayList();
            synchronized (PackageManagerService.this.mPackages) {
                for (Package p : PackageManagerService.this.mPackages.values()) {
                    if (p.mOverlayTarget == null) {
                        targetPackages.add(p.packageName);
                    }
                }
            }
            return targetPackages;
        }

        public boolean setEnabledOverlayPackages(int userId, String targetPackageName, List<String> overlayPackageNames) {
            synchronized (PackageManagerService.this.mPackages) {
                if (targetPackageName != null) {
                    try {
                        if (PackageManagerService.this.mPackages.get(targetPackageName) != null) {
                            ArrayList<String> overlayPaths = null;
                            if (overlayPackageNames != null && overlayPackageNames.size() > 0) {
                                int N = overlayPackageNames.size();
                                overlayPaths = new ArrayList(N);
                                for (int i = 0; i < N; i++) {
                                    String packageName = (String) overlayPackageNames.get(i);
                                    Package pkg = (Package) PackageManagerService.this.mPackages.get(packageName);
                                    if (pkg == null) {
                                        String str = PackageManagerService.TAG;
                                        StringBuilder stringBuilder = new StringBuilder();
                                        stringBuilder.append("failed to find package ");
                                        stringBuilder.append(packageName);
                                        Slog.e(str, stringBuilder.toString());
                                        return false;
                                    }
                                    overlayPaths.add(pkg.baseCodePath);
                                }
                            }
                            ((PackageSetting) PackageManagerService.this.mSettings.mPackages.get(targetPackageName)).setOverlayPaths(overlayPaths, userId);
                            return true;
                        }
                    } finally {
                    }
                }
                String str2 = PackageManagerService.TAG;
                StringBuilder stringBuilder2 = new StringBuilder();
                stringBuilder2.append("failed to find package ");
                stringBuilder2.append(targetPackageName);
                Slog.e(str2, stringBuilder2.toString());
                return false;
            }
        }

        public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId, boolean resolveForStart, int filterCallingUid) {
            return PackageManagerService.this.resolveIntentInternal(intent, resolvedType, flags, userId, resolveForStart, filterCallingUid);
        }

        public ResolveInfo resolveService(Intent intent, String resolvedType, int flags, int userId, int callingUid) {
            return PackageManagerService.this.resolveServiceInternal(intent, resolvedType, flags, userId, callingUid);
        }

        public ProviderInfo resolveContentProvider(String name, int flags, int userId) {
            return PackageManagerService.this.resolveContentProviderInternal(name, flags, userId);
        }

        public void addIsolatedUid(int isolatedUid, int ownerUid) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mIsolatedOwners.put(isolatedUid, ownerUid);
            }
        }

        public void removeIsolatedUid(int isolatedUid) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mIsolatedOwners.delete(isolatedUid);
            }
        }

        public boolean isInMWPortraitWhiteList(String packageName) {
            return PackageManagerService.this.isInMWPortraitWhiteList(packageName);
        }

        public int getUidTargetSdkVersion(int uid) {
            int access$8900;
            synchronized (PackageManagerService.this.mPackages) {
                access$8900 = PackageManagerService.this.getUidTargetSdkVersionLockedLPr(uid);
            }
            return access$8900;
        }

        public int getPackageTargetSdkVersion(String packageName) {
            int access$9000;
            synchronized (PackageManagerService.this.mPackages) {
                access$9000 = PackageManagerService.this.getPackageTargetSdkVersionLockedLPr(packageName);
            }
            return access$9000;
        }

        public boolean canAccessInstantApps(int callingUid, int userId) {
            return PackageManagerService.this.canViewInstantApps(callingUid, userId);
        }

        public boolean canAccessComponent(int callingUid, ComponentName component, int userId) {
            int access$9200;
            synchronized (PackageManagerService.this.mPackages) {
                access$9200 = PackageManagerService.this.filterAppAccessLPr((PackageSetting) PackageManagerService.this.mSettings.mPackages.get(component.getPackageName()), callingUid, component, 0, userId) ^ 1;
            }
            return access$9200;
        }

        public boolean hasInstantApplicationMetadata(String packageName, int userId) {
            boolean hasInstantApplicationMetadataLPr;
            synchronized (PackageManagerService.this.mPackages) {
                hasInstantApplicationMetadataLPr = PackageManagerService.this.mInstantAppRegistry.hasInstantApplicationMetadataLPr(packageName, userId);
            }
            return hasInstantApplicationMetadataLPr;
        }

        public void notifyPackageUse(String packageName, int reason) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.notifyPackageUseLocked(packageName, reason);
            }
        }

        public float getUserMaxAspectRatio(String packageName) {
            return PackageManagerService.this.getApplicationMaxAspectRatio(packageName);
        }

        public void checkPackageStartable(String packageName, int userId) {
            PackageManagerService.this.checkPackageStartable(packageName, userId);
        }

        public boolean getHwCertPermission(boolean allowed, Package pkg, String perm) {
            return PackageManagerService.this.getHwCertPermission(allowed, pkg, perm);
        }

        public void installPackageAsUser(String originPath, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, int userId) {
            PackageManagerService.this.mHwPMSEx.installPackageAsUser(originPath, observer, installFlags, installerPackageName, userId);
        }
    }

    private class PackageManagerNative extends IPackageManagerNative.Stub {
        private PackageManagerNative() {
        }

        /* synthetic */ PackageManagerNative(PackageManagerService x0, AnonymousClass1 x1) {
            this();
        }

        public String[] getNamesForUids(int[] uids) throws RemoteException {
            String[] results = PackageManagerService.this.getNamesForUids(uids);
            for (int i = results.length - 1; i >= 0; i--) {
                if (results[i] == null) {
                    results[i] = BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS;
                }
            }
            return results;
        }

        public String getInstallerForPackage(String packageName) throws RemoteException {
            String installerName = PackageManagerService.this.getInstallerPackageName(packageName);
            if (!TextUtils.isEmpty(installerName)) {
                return installerName;
            }
            ApplicationInfo appInfo = PackageManagerService.this.getApplicationInfo(packageName, 0, UserHandle.getUserId(Binder.getCallingUid()));
            if (appInfo == null || (appInfo.flags & 1) == 0) {
                return BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS;
            }
            return "preload";
        }

        public long getVersionCodeForPackage(String packageName) throws RemoteException {
            try {
                PackageInfo pInfo = PackageManagerService.this.getPackageInfo(packageName, 0, UserHandle.getUserId(Binder.getCallingUid()));
                if (pInfo != null) {
                    return pInfo.getLongVersionCode();
                }
            } catch (Exception e) {
            }
            return 0;
        }
    }

    class PackageParserCallback implements Callback {
        PackageParserCallback() {
        }

        public final boolean hasFeature(String feature) {
            return PackageManagerService.this.hasSystemFeature(feature, 0);
        }

        final List<Package> getStaticOverlayPackages(Collection<Package> allPackages, String targetPackageName) {
            if (PackageManagerService.PLATFORM_PACKAGE_NAME.equals(targetPackageName)) {
                return null;
            }
            List<Package> overlayPackages = null;
            for (Package p : allPackages) {
                if (targetPackageName.equals(p.mOverlayTarget) && p.mOverlayIsStatic) {
                    if (overlayPackages == null) {
                        overlayPackages = new ArrayList();
                    }
                    overlayPackages.add(p);
                }
            }
            if (overlayPackages != null) {
                Collections.sort(overlayPackages, new Comparator<Package>() {
                    public int compare(Package p1, Package p2) {
                        return p1.mOverlayPriority - p2.mOverlayPriority;
                    }
                });
            }
            return overlayPackages;
        }

        final String[] getStaticOverlayPaths(List<Package> overlayPackages, String targetPath) {
            String[] strArr = null;
            if (overlayPackages == null || overlayPackages.isEmpty()) {
                return null;
            }
            List<String> overlayPathList = null;
            for (Package overlayPackage : overlayPackages) {
                if (targetPath == null) {
                    if (overlayPathList == null) {
                        overlayPathList = new ArrayList();
                    }
                    overlayPathList.add(overlayPackage.baseCodePath);
                } else {
                    try {
                        PackageManagerService.this.mInstaller.idmap(targetPath, overlayPackage.baseCodePath, UserHandle.getSharedAppGid(UserHandle.getUserGid(0)));
                        if (overlayPathList == null) {
                            overlayPathList = new ArrayList();
                        }
                        overlayPathList.add(overlayPackage.baseCodePath);
                    } catch (InstallerException e) {
                        String str = PackageManagerService.TAG;
                        StringBuilder stringBuilder = new StringBuilder();
                        stringBuilder.append("Failed to generate idmap for ");
                        stringBuilder.append(targetPath);
                        stringBuilder.append(" and ");
                        stringBuilder.append(overlayPackage.baseCodePath);
                        Slog.e(str, stringBuilder.toString());
                    }
                }
            }
            if (overlayPathList != null) {
                strArr = (String[]) overlayPathList.toArray(new String[0]);
            }
            return strArr;
        }

        String[] getStaticOverlayPaths(String targetPackageName, String targetPath) {
            String[] staticOverlayPaths;
            synchronized (PackageManagerService.this.mInstallLock) {
                List overlayPackages;
                synchronized (PackageManagerService.this.mPackages) {
                    overlayPackages = getStaticOverlayPackages(PackageManagerService.this.mPackages.values(), targetPackageName);
                }
                staticOverlayPaths = getStaticOverlayPaths(overlayPackages, targetPath);
            }
            return staticOverlayPaths;
        }

        public final String[] getOverlayApks(String targetPackageName) {
            return getStaticOverlayPaths(targetPackageName, null);
        }

        public final String[] getOverlayPaths(String targetPackageName, String targetPath) {
            return getStaticOverlayPaths(targetPackageName, targetPath);
        }
    }

    static class PackageRemovedInfo {
        ArrayMap<String, PackageInstalledInfo> appearedChildPackages;
        InstallArgs args = null;
        int[] broadcastUsers = null;
        boolean dataRemoved;
        SparseArray<Integer> installReasons;
        String installerPackageName;
        int[] instantUserIds = null;
        boolean isRemovedPackageSystemUpdate = false;
        boolean isStaticSharedLib;
        boolean isUpdate;
        int[] origUsers;
        final PackageSender packageSender;
        int removedAppId = -1;
        ArrayMap<String, PackageRemovedInfo> removedChildPackages;
        boolean removedForAllUsers;
        String removedPackage;
        int[] removedUsers = null;
        int uid = -1;

        PackageRemovedInfo(PackageSender packageSender) {
            this.packageSender = packageSender;
        }

        void sendPackageRemovedBroadcasts(boolean killApp) {
            sendPackageRemovedBroadcastInternal(killApp);
            int i = 0;
            int childCount = this.removedChildPackages != null ? this.removedChildPackages.size() : 0;
            while (i < childCount) {
                ((PackageRemovedInfo) this.removedChildPackages.valueAt(i)).sendPackageRemovedBroadcastInternal(killApp);
                i++;
            }
        }

        void sendSystemPackageUpdatedBroadcasts() {
            if (this.isRemovedPackageSystemUpdate) {
                sendSystemPackageUpdatedBroadcastsInternal();
                int i = 0;
                int childCount = this.removedChildPackages != null ? this.removedChildPackages.size() : 0;
                while (i < childCount) {
                    PackageRemovedInfo childInfo = (PackageRemovedInfo) this.removedChildPackages.valueAt(i);
                    if (childInfo.isRemovedPackageSystemUpdate) {
                        childInfo.sendSystemPackageUpdatedBroadcastsInternal();
                    }
                    i++;
                }
            }
        }

        void sendSystemPackageAppearedBroadcasts() {
            int i = 0;
            int packageCount = this.appearedChildPackages != null ? this.appearedChildPackages.size() : 0;
            while (i < packageCount) {
                PackageInstalledInfo installedInfo = (PackageInstalledInfo) this.appearedChildPackages.valueAt(i);
                this.packageSender.sendPackageAddedForNewUsers(installedInfo.name, true, false, UserHandle.getAppId(installedInfo.uid), installedInfo.newUsers, null);
                i++;
            }
        }

        private void sendSystemPackageUpdatedBroadcastsInternal() {
            Bundle extras = new Bundle(2);
            extras.putInt("android.intent.extra.UID", this.removedAppId >= 0 ? this.removedAppId : this.uid);
            extras.putBoolean("android.intent.extra.REPLACING", true);
            Bundle bundle = extras;
            this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", this.removedPackage, bundle, 0, null, null, null, null);
            this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", this.removedPackage, bundle, 0, null, null, null, null);
            this.packageSender.sendPackageBroadcast("android.intent.action.MY_PACKAGE_REPLACED", null, null, 0, this.removedPackage, null, null, null);
            if (this.installerPackageName != null) {
                bundle = extras;
                this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", this.removedPackage, bundle, 0, this.installerPackageName, null, null, null);
                this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", this.removedPackage, bundle, 0, this.installerPackageName, null, null, null);
            }
        }

        private void sendPackageRemovedBroadcastInternal(boolean killApp) {
            if (!this.isStaticSharedLib) {
                Bundle extras = new Bundle(2);
                extras.putInt("android.intent.extra.UID", this.removedAppId >= 0 ? this.removedAppId : this.uid);
                extras.putBoolean("android.intent.extra.DATA_REMOVED", this.dataRemoved);
                extras.putBoolean("android.intent.extra.DONT_KILL_APP", killApp ^ 1);
                if (this.isUpdate || this.isRemovedPackageSystemUpdate) {
                    extras.putBoolean("android.intent.extra.REPLACING", true);
                }
                extras.putBoolean("android.intent.extra.REMOVED_FOR_ALL_USERS", this.removedForAllUsers);
                if (this.removedPackage != null) {
                    this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REMOVED", this.removedPackage, extras, 0, null, null, this.broadcastUsers, this.instantUserIds);
                    if (this.installerPackageName != null) {
                        this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REMOVED", this.removedPackage, extras, 0, this.installerPackageName, null, this.broadcastUsers, this.instantUserIds);
                    }
                    if (this.dataRemoved && !this.isRemovedPackageSystemUpdate) {
                        this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_FULLY_REMOVED", this.removedPackage, extras, DumpState.DUMP_SERVICE_PERMISSIONS, null, null, this.broadcastUsers, this.instantUserIds);
                        this.packageSender.notifyPackageRemoved(this.removedPackage);
                    }
                    if ((this.packageSender instanceof PackageManagerService) && !this.isUpdate) {
                        ((PackageManagerService) this.packageSender).mHwPMSEx.updateNochScreenWhite(this.removedPackage, "removed", 0);
                    }
                }
                if (this.removedAppId >= 0) {
                    this.packageSender.sendPackageBroadcast("android.intent.action.UID_REMOVED", null, extras, DumpState.DUMP_SERVICE_PERMISSIONS, null, null, this.broadcastUsers, this.instantUserIds);
                }
                if (this.packageSender instanceof PackageManagerService) {
                    ((PackageManagerService) this.packageSender).deleteClonedProfileIfNeed(this.broadcastUsers);
                }
            }
        }

        void populateUsers(int[] userIds, PackageSetting deletedPackageSetting) {
            this.removedUsers = userIds;
            if (this.removedUsers == null) {
                this.broadcastUsers = null;
                return;
            }
            this.broadcastUsers = PackageManagerService.EMPTY_INT_ARRAY;
            this.instantUserIds = PackageManagerService.EMPTY_INT_ARRAY;
            for (int i = userIds.length - 1; i >= 0; i--) {
                int userId = userIds[i];
                if (deletedPackageSetting.getInstantApp(userId)) {
                    this.instantUserIds = ArrayUtils.appendInt(this.instantUserIds, userId);
                } else {
                    this.broadcastUsers = ArrayUtils.appendInt(this.broadcastUsers, userId);
                }
            }
        }
    }

    static class PendingPackageBroadcasts {
        final SparseArray<ArrayMap<String, ArrayList<String>>> mUidMap = new SparseArray(2);

        public ArrayList<String> get(int userId, String packageName) {
            return (ArrayList) getOrAllocate(userId).get(packageName);
        }

        public void put(int userId, String packageName, ArrayList<String> components) {
            getOrAllocate(userId).put(packageName, components);
        }

        public void remove(int userId, String packageName) {
            ArrayMap<String, ArrayList<String>> packages = (ArrayMap) this.mUidMap.get(userId);
            if (packages != null) {
                packages.remove(packageName);
            }
        }

        public void remove(int userId) {
            this.mUidMap.remove(userId);
        }

        public int userIdCount() {
            return this.mUidMap.size();
        }

        public int userIdAt(int n) {
            return this.mUidMap.keyAt(n);
        }

        public ArrayMap<String, ArrayList<String>> packagesForUserId(int userId) {
            return (ArrayMap) this.mUidMap.get(userId);
        }

        public int size() {
            int num = 0;
            for (int i = 0; i < this.mUidMap.size(); i++) {
                num += ((ArrayMap) this.mUidMap.valueAt(i)).size();
            }
            return num;
        }

        public void clear() {
            this.mUidMap.clear();
        }

        private ArrayMap<String, ArrayList<String>> getOrAllocate(int userId) {
            ArrayMap<String, ArrayList<String>> map = (ArrayMap) this.mUidMap.get(userId);
            if (map != null) {
                return map;
            }
            map = new ArrayMap();
            this.mUidMap.put(userId, map);
            return map;
        }
    }

    static class PostInstallData {
        public InstallArgs args;
        public PackageInstalledInfo res;

        PostInstallData(InstallArgs _a, PackageInstalledInfo _r) {
            this.args = _a;
            this.res = _r;
        }
    }

    @Retention(RetentionPolicy.SOURCE)
    public @interface ScanFlags {
    }

    private static class ScanRequest {
        public final PackageSetting disabledPkgSetting;
        public final boolean isPlatformPackage;
        public final Package oldPkg;
        public final PackageSetting oldPkgSetting;
        public final PackageSetting originalPkgSetting;
        public final int parseFlags;
        public final Package pkg;
        public final PackageSetting pkgSetting;
        public final String realPkgName;
        public final int scanFlags;
        public final SharedUserSetting sharedUserSetting;
        public final UserHandle user;

        public ScanRequest(Package pkg, SharedUserSetting sharedUserSetting, Package oldPkg, PackageSetting pkgSetting, PackageSetting disabledPkgSetting, PackageSetting originalPkgSetting, String realPkgName, int parseFlags, int scanFlags, boolean isPlatformPackage, UserHandle user) {
            this.pkg = pkg;
            this.oldPkg = oldPkg;
            this.pkgSetting = pkgSetting;
            this.sharedUserSetting = sharedUserSetting;
            this.oldPkgSetting = pkgSetting == null ? null : new PackageSetting(pkgSetting);
            this.disabledPkgSetting = disabledPkgSetting;
            this.originalPkgSetting = originalPkgSetting;
            this.realPkgName = realPkgName;
            this.parseFlags = parseFlags;
            this.scanFlags = scanFlags;
            this.isPlatformPackage = isPlatformPackage;
            this.user = user;
        }
    }

    private static class ScanResult {
        public final List<String> changedAbiCodePath;
        public final PackageSetting pkgSetting;
        public final boolean success;

        public ScanResult(boolean success, PackageSetting pkgSetting, List<String> changedAbiCodePath) {
            this.success = success;
            this.pkgSetting = pkgSetting;
            this.changedAbiCodePath = changedAbiCodePath;
        }
    }

    public static final class SharedLibraryEntry {
        public final String apk;
        public final SharedLibraryInfo info;
        public final String path;

        SharedLibraryEntry(String _path, String _apk, String name, long version, int type, String declaringPackageName, long declaringPackageVersionCode) {
            this.path = _path;
            this.apk = _apk;
            this.info = new SharedLibraryInfo(name, version, type, new VersionedPackage(declaringPackageName, declaringPackageVersionCode), null);
        }
    }

    static class VerificationInfo {
        public static final int NO_UID = -1;
        final int installerUid;
        final int originatingUid;
        final Uri originatingUri;
        final Uri referrer;

        VerificationInfo(Uri originatingUri, Uri referrer, int originatingUid, int installerUid) {
            this.originatingUri = originatingUri;
            this.referrer = referrer;
            this.originatingUid = originatingUid;
            this.installerUid = installerUid;
        }
    }

    final class ActivityIntentResolver extends IntentResolver<ActivityIntentInfo, ResolveInfo> {
        private final ArrayMap<ComponentName, Activity> mActivities = new ArrayMap();
        private int mFlags;

        public class IterGenerator<E> {
            public Iterator<E> generate(ActivityIntentInfo info) {
                return null;
            }
        }

        public class ActionIterGenerator extends IterGenerator<String> {
            public ActionIterGenerator() {
                super();
            }

            public Iterator<String> generate(ActivityIntentInfo info) {
                return info.actionsIterator();
            }
        }

        public class AuthoritiesIterGenerator extends IterGenerator<AuthorityEntry> {
            public AuthoritiesIterGenerator() {
                super();
            }

            public Iterator<AuthorityEntry> generate(ActivityIntentInfo info) {
                return info.authoritiesIterator();
            }
        }

        public class CategoriesIterGenerator extends IterGenerator<String> {
            public CategoriesIterGenerator() {
                super();
            }

            public Iterator<String> generate(ActivityIntentInfo info) {
                return info.categoriesIterator();
            }
        }

        public class SchemesIterGenerator extends IterGenerator<String> {
            public SchemesIterGenerator() {
                super();
            }

            public Iterator<String> generate(ActivityIntentInfo info) {
                return info.schemesIterator();
            }
        }

        ActivityIntentResolver() {
        }

        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            this.mFlags = defaultOnly ? 65536 : 0;
            return super.queryIntent(intent, resolvedType, defaultOnly, userId);
        }

        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, int flags, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            this.mFlags = flags;
            boolean z = false;
            if (PackageManagerService.this.mCustPms == null || !PackageManagerService.this.mCustPms.isSkipMmsSendImageAction()) {
                if ((flags & 65536) != 0) {
                    z = true;
                }
                return super.queryIntent(intent, resolvedType, z, userId);
            }
            if ((flags & 65536) != 0) {
                z = true;
            }
            return PackageManagerService.this.mCustPms.filterResolveInfos(super.queryIntent(intent, resolvedType, z, userId), intent, resolvedType);
        }

        public List<ResolveInfo> queryIntentForPackage(Intent intent, String resolvedType, int flags, ArrayList<Activity> packageActivities, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId) || packageActivities == null) {
                return null;
            }
            this.mFlags = flags;
            int i = 0;
            boolean defaultOnly = (65536 & flags) != 0;
            int N = packageActivities.size();
            ArrayList<ActivityIntentInfo[]> listCut = new ArrayList(N);
            while (i < N) {
                ArrayList<ActivityIntentInfo> intentFilters = ((Activity) packageActivities.get(i)).intents;
                if (intentFilters != null && intentFilters.size() > 0) {
                    ActivityIntentInfo[] array = new ActivityIntentInfo[intentFilters.size()];
                    intentFilters.toArray(array);
                    listCut.add(array);
                }
                i++;
            }
            return super.queryIntentFromList(intent, resolvedType, defaultOnly, listCut, userId);
        }

        private Activity findMatchingActivity(List<Activity> activityList, ActivityInfo activityInfo) {
            for (Activity sysActivity : activityList) {
                if (sysActivity.info.name.equals(activityInfo.name) || sysActivity.info.name.equals(activityInfo.targetActivity)) {
                    return sysActivity;
                }
                if (sysActivity.info.targetActivity != null && (sysActivity.info.targetActivity.equals(activityInfo.name) || sysActivity.info.targetActivity.equals(activityInfo.targetActivity))) {
                    return sysActivity;
                }
            }
            return null;
        }

        private <T> void getIntentListSubset(List<ActivityIntentInfo> intentList, IterGenerator<T> generator, Iterator<T> searchIterator) {
            while (searchIterator.hasNext() && intentList.size() != 0) {
                T searchAction = searchIterator.next();
                Iterator<ActivityIntentInfo> intentIter = intentList.iterator();
                while (intentIter.hasNext()) {
                    boolean selectionFound = false;
                    Iterator<T> intentSelectionIter = generator.generate((ActivityIntentInfo) intentIter.next());
                    while (intentSelectionIter != null && intentSelectionIter.hasNext()) {
                        T intentSelection = intentSelectionIter.next();
                        if (intentSelection != null && intentSelection.equals(searchAction)) {
                            selectionFound = true;
                            break;
                        }
                    }
                    if (!selectionFound) {
                        intentIter.remove();
                    }
                }
            }
        }

        private boolean isProtectedAction(ActivityIntentInfo filter) {
            Iterator<String> actionsIter = filter.actionsIterator();
            while (actionsIter != null && actionsIter.hasNext()) {
                if (PackageManagerService.PROTECTED_ACTIONS.contains((String) actionsIter.next())) {
                    return true;
                }
            }
            return false;
        }

        private void adjustPriority(List<Activity> systemActivities, ActivityIntentInfo intent) {
            List<Activity> list = systemActivities;
            ActivityIntentInfo activityIntentInfo = intent;
            if (intent.getPriority() > 0) {
                ActivityInfo activityInfo = activityIntentInfo.activity.info;
                ApplicationInfo applicationInfo = activityInfo.applicationInfo;
                String str;
                StringBuilder stringBuilder;
                if (!((applicationInfo.privateFlags & 8) != 0)) {
                    if (PackageManagerService.DEBUG_FILTERS) {
                        str = PackageManagerService.TAG;
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("Non-privileged app; cap priority to 0; package: ");
                        stringBuilder.append(applicationInfo.packageName);
                        stringBuilder.append(" activity: ");
                        stringBuilder.append(activityIntentInfo.activity.className);
                        stringBuilder.append(" origPrio: ");
                        stringBuilder.append(intent.getPriority());
                        Slog.i(str, stringBuilder.toString());
                    }
                    activityIntentInfo.setPriority(0);
                } else if (list != null) {
                    Activity foundActivity = findMatchingActivity(list, activityInfo);
                    if (foundActivity == null) {
                        if (PackageManagerService.DEBUG_FILTERS) {
                            str = PackageManagerService.TAG;
                            StringBuilder stringBuilder2 = new StringBuilder();
                            stringBuilder2.append("New activity; cap priority to 0; package: ");
                            stringBuilder2.append(applicationInfo.packageName);
                            stringBuilder2.append(" activity: ");
                            stringBuilder2.append(activityIntentInfo.activity.className);
                            stringBuilder2.append(" origPrio: ");
                            stringBuilder2.append(intent.getPriority());
                            Slog.i(str, stringBuilder2.toString());
                        }
                        activityIntentInfo.setPriority(0);
                        return;
                    }
                    StringBuilder stringBuilder3;
                    List<ActivityIntentInfo> intentListCopy = new ArrayList(foundActivity.intents);
                    List<ActivityIntentInfo> foundFilters = findFilters(activityIntentInfo);
                    Iterator<String> actionsIterator = intent.actionsIterator();
                    if (actionsIterator != null) {
                        getIntentListSubset(intentListCopy, new ActionIterGenerator(), actionsIterator);
                        if (intentListCopy.size() == 0) {
                            if (PackageManagerService.DEBUG_FILTERS) {
                                str = PackageManagerService.TAG;
                                StringBuilder stringBuilder4 = new StringBuilder();
                                stringBuilder4.append("Mismatched action; cap priority to 0; package: ");
                                stringBuilder4.append(applicationInfo.packageName);
                                stringBuilder4.append(" activity: ");
                                stringBuilder4.append(activityIntentInfo.activity.className);
                                stringBuilder4.append(" origPrio: ");
                                stringBuilder4.append(intent.getPriority());
                                Slog.i(str, stringBuilder4.toString());
                            }
                            activityIntentInfo.setPriority(0);
                            return;
                        }
                    }
                    Iterator<String> categoriesIterator = intent.categoriesIterator();
                    if (categoriesIterator != null) {
                        getIntentListSubset(intentListCopy, new CategoriesIterGenerator(), categoriesIterator);
                        if (intentListCopy.size() == 0) {
                            if (PackageManagerService.DEBUG_FILTERS) {
                                str = PackageManagerService.TAG;
                                StringBuilder stringBuilder5 = new StringBuilder();
                                stringBuilder5.append("Mismatched category; cap priority to 0; package: ");
                                stringBuilder5.append(applicationInfo.packageName);
                                stringBuilder5.append(" activity: ");
                                stringBuilder5.append(activityIntentInfo.activity.className);
                                stringBuilder5.append(" origPrio: ");
                                stringBuilder5.append(intent.getPriority());
                                Slog.i(str, stringBuilder5.toString());
                            }
                            activityIntentInfo.setPriority(0);
                            return;
                        }
                    }
                    Iterator<String> schemesIterator = intent.schemesIterator();
                    if (schemesIterator != null) {
                        getIntentListSubset(intentListCopy, new SchemesIterGenerator(), schemesIterator);
                        if (intentListCopy.size() == 0) {
                            if (PackageManagerService.DEBUG_FILTERS) {
                                str = PackageManagerService.TAG;
                                StringBuilder stringBuilder6 = new StringBuilder();
                                stringBuilder6.append("Mismatched scheme; cap priority to 0; package: ");
                                stringBuilder6.append(applicationInfo.packageName);
                                stringBuilder6.append(" activity: ");
                                stringBuilder6.append(activityIntentInfo.activity.className);
                                stringBuilder6.append(" origPrio: ");
                                stringBuilder6.append(intent.getPriority());
                                Slog.i(str, stringBuilder6.toString());
                            }
                            activityIntentInfo.setPriority(0);
                            return;
                        }
                    }
                    Iterator<AuthorityEntry> authoritiesIterator = intent.authoritiesIterator();
                    if (authoritiesIterator != null) {
                        getIntentListSubset(intentListCopy, new AuthoritiesIterGenerator(), authoritiesIterator);
                        if (intentListCopy.size() == 0) {
                            if (PackageManagerService.DEBUG_FILTERS) {
                                str = PackageManagerService.TAG;
                                stringBuilder3 = new StringBuilder();
                                stringBuilder3.append("Mismatched authority; cap priority to 0; package: ");
                                stringBuilder3.append(applicationInfo.packageName);
                                stringBuilder3.append(" activity: ");
                                stringBuilder3.append(activityIntentInfo.activity.className);
                                stringBuilder3.append(" origPrio: ");
                                stringBuilder3.append(intent.getPriority());
                                Slog.i(str, stringBuilder3.toString());
                            }
                            activityIntentInfo.setPriority(0);
                            return;
                        }
                    }
                    int cappedPriority = 0;
                    int i = intentListCopy.size() - 1;
                    while (true) {
                        int i2 = i;
                        if (i2 < 0) {
                            break;
                        }
                        cappedPriority = Math.max(cappedPriority, ((ActivityIntentInfo) intentListCopy.get(i2)).getPriority());
                        i = i2 - 1;
                    }
                    if (intent.getPriority() > cappedPriority) {
                        if (PackageManagerService.DEBUG_FILTERS) {
                            str = PackageManagerService.TAG;
                            stringBuilder3 = new StringBuilder();
                            stringBuilder3.append("Found matching filter(s); cap priority to ");
                            stringBuilder3.append(cappedPriority);
                            stringBuilder3.append("; package: ");
                            stringBuilder3.append(applicationInfo.packageName);
                            stringBuilder3.append(" activity: ");
                            stringBuilder3.append(activityIntentInfo.activity.className);
                            stringBuilder3.append(" origPrio: ");
                            stringBuilder3.append(intent.getPriority());
                            Slog.i(str, stringBuilder3.toString());
                        }
                        activityIntentInfo.setPriority(cappedPriority);
                    }
                } else if (!isProtectedAction(activityIntentInfo)) {
                } else {
                    StringBuilder stringBuilder7;
                    if (PackageManagerService.this.mDeferProtectedFilters) {
                        PackageManagerService.this.mProtectedFilters.add(activityIntentInfo);
                        if (PackageManagerService.DEBUG_FILTERS) {
                            str = PackageManagerService.TAG;
                            stringBuilder7 = new StringBuilder();
                            stringBuilder7.append("Protected action; save for later; package: ");
                            stringBuilder7.append(applicationInfo.packageName);
                            stringBuilder7.append(" activity: ");
                            stringBuilder7.append(activityIntentInfo.activity.className);
                            stringBuilder7.append(" origPrio: ");
                            stringBuilder7.append(intent.getPriority());
                            Slog.i(str, stringBuilder7.toString());
                        }
                        return;
                    }
                    if (PackageManagerService.DEBUG_FILTERS && PackageManagerService.this.mSetupWizardPackage == null) {
                        Slog.i(PackageManagerService.TAG, "No setup wizard; All protected intents capped to priority 0");
                    }
                    if (activityIntentInfo.activity.info.packageName.equals(PackageManagerService.this.mSetupWizardPackage)) {
                        if (PackageManagerService.DEBUG_FILTERS) {
                            str = PackageManagerService.TAG;
                            stringBuilder7 = new StringBuilder();
                            stringBuilder7.append("Found setup wizard; allow priority ");
                            stringBuilder7.append(intent.getPriority());
                            stringBuilder7.append("; package: ");
                            stringBuilder7.append(activityIntentInfo.activity.info.packageName);
                            stringBuilder7.append(" activity: ");
                            stringBuilder7.append(activityIntentInfo.activity.className);
                            stringBuilder7.append(" priority: ");
                            stringBuilder7.append(intent.getPriority());
                            Slog.i(str, stringBuilder7.toString());
                        }
                        return;
                    }
                    if (PackageManagerService.DEBUG_FILTERS) {
                        str = PackageManagerService.TAG;
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("Protected action; cap priority to 0; package: ");
                        stringBuilder.append(activityIntentInfo.activity.info.packageName);
                        stringBuilder.append(" activity: ");
                        stringBuilder.append(activityIntentInfo.activity.className);
                        stringBuilder.append(" origPrio: ");
                        stringBuilder.append(intent.getPriority());
                        Slog.i(str, stringBuilder.toString());
                    }
                    activityIntentInfo.setPriority(0);
                }
            }
        }

        public final void addActivity(Activity a, String type) {
            String str;
            StringBuilder stringBuilder;
            this.mActivities.put(a.getComponentName(), a);
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                str = PackageManagerService.TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("  ");
                stringBuilder.append(type);
                stringBuilder.append(" ");
                stringBuilder.append(a.info.nonLocalizedLabel != null ? a.info.nonLocalizedLabel : a.info.name);
                stringBuilder.append(":");
                Log.v(str, stringBuilder.toString());
            }
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                str = PackageManagerService.TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("    Class=");
                stringBuilder.append(a.info.name);
                Log.v(str, stringBuilder.toString());
            }
            int NI = a.intents.size();
            for (int j = 0; j < NI; j++) {
                ActivityIntentInfo intent = (ActivityIntentInfo) a.intents.get(j);
                if ("activity".equals(type)) {
                    PackageSetting ps = PackageManagerService.this.mSettings.getDisabledSystemPkgLPr(intent.activity.info.packageName);
                    List<Activity> systemActivities = (ps == null || ps.pkg == null) ? null : ps.pkg.activities;
                    adjustPriority(systemActivities, intent);
                }
                if (PackageManagerService.DEBUG_SHOW_INFO) {
                    Log.v(PackageManagerService.TAG, "    IntentFilter:");
                    intent.dump(new LogPrinter(2, PackageManagerService.TAG), "      ");
                }
                if (!intent.debugCheck()) {
                    String str2 = PackageManagerService.TAG;
                    StringBuilder stringBuilder2 = new StringBuilder();
                    stringBuilder2.append("==> For Activity ");
                    stringBuilder2.append(a.info.name);
                    Log.w(str2, stringBuilder2.toString());
                }
                addFilter(intent);
            }
        }

        public final void removeActivity(Activity a, String type) {
            this.mActivities.remove(a.getComponentName());
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                Object obj;
                String str = PackageManagerService.TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("  ");
                stringBuilder.append(type);
                stringBuilder.append(" ");
                if (a.info.nonLocalizedLabel != null) {
                    obj = a.info.nonLocalizedLabel;
                } else {
                    obj = a.info.name;
                }
                stringBuilder.append(obj);
                stringBuilder.append(":");
                Log.v(str, stringBuilder.toString());
                str = PackageManagerService.TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("    Class=");
                stringBuilder.append(a.info.name);
                Log.v(str, stringBuilder.toString());
            }
            int NI = a.intents.size();
            for (int j = 0; j < NI; j++) {
                ActivityIntentInfo intent = (ActivityIntentInfo) a.intents.get(j);
                if (PackageManagerService.DEBUG_SHOW_INFO) {
                    Log.v(PackageManagerService.TAG, "    IntentFilter:");
                    intent.dump(new LogPrinter(2, PackageManagerService.TAG), "      ");
                }
                removeFilter(intent);
            }
        }

        protected boolean allowFilterResult(ActivityIntentInfo filter, List<ResolveInfo> dest) {
            ActivityInfo filterAi = filter.activity.info;
            for (int i = dest.size() - 1; i >= 0; i--) {
                ActivityInfo destAi = ((ResolveInfo) dest.get(i)).activityInfo;
                if (destAi.name == filterAi.name && destAi.packageName == filterAi.packageName) {
                    return false;
                }
            }
            return true;
        }

        protected ActivityIntentInfo[] newArray(int size) {
            return new ActivityIntentInfo[size];
        }

        protected boolean isFilterStopped(ActivityIntentInfo filter, int userId) {
            boolean z = true;
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return true;
            }
            Package p = filter.activity.owner;
            if (p != null) {
                PackageSetting ps = p.mExtras;
                if (ps != null) {
                    if (!(((ps.pkgFlags & 1) == 0 || HwServiceFactory.isCustedCouldStopped(p.packageName, true, ps.getStopped(userId))) && ps.getStopped(userId))) {
                        z = false;
                    }
                    return z;
                }
            }
            return false;
        }

        protected boolean isPackageForFilter(String packageName, ActivityIntentInfo info) {
            return packageName.equals(info.activity.owner.packageName);
        }

        protected ResolveInfo newResult(ActivityIntentInfo info, int match, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId) || !PackageManagerService.this.mSettings.isEnabledAndMatchLPr(info.activity.info, this.mFlags, userId)) {
                return null;
            }
            Activity activity = info.activity;
            PackageSetting ps = activity.owner.mExtras;
            if (ps == null) {
                return null;
            }
            if (PackageManagerService.this.mSafeMode && !PackageManagerService.this.isSystemPathApp(ps)) {
                return null;
            }
            PackageUserState userState = ps.readUserState(userId);
            ActivityInfo ai = PackageParser.generateActivityInfo(activity, this.mFlags, userState, userId);
            if (ai == null) {
                return null;
            }
            boolean matchInstantApp = false;
            boolean matchExplicitlyVisibleOnly = (this.mFlags & DumpState.DUMP_HANDLE) != 0;
            boolean matchVisibleToInstantApp = (this.mFlags & DumpState.DUMP_SERVICE_PERMISSIONS) != 0;
            boolean componentVisible = matchVisibleToInstantApp && info.isVisibleToInstantApp() && (!matchExplicitlyVisibleOnly || info.isExplicitlyVisibleToInstantApp());
            if ((this.mFlags & DumpState.DUMP_VOLUMES) != 0) {
                matchInstantApp = true;
            }
            if (matchVisibleToInstantApp && !componentVisible && !userState.instantApp) {
                return null;
            }
            if (!matchInstantApp && userState.instantApp) {
                return null;
            }
            if (userState.instantApp && ps.isUpdateAvailable()) {
                return null;
            }
            ResolveInfo res = new ResolveInfo();
            res.activityInfo = ai;
            if ((this.mFlags & 64) != 0) {
                res.filter = info;
            }
            if (info != null && info.countActionFilters() > 0) {
                res.filter = info;
            }
            if (info != null) {
                res.handleAllWebDataURI = info.handleAllWebDataURI();
            }
            res.priority = info.getPriority();
            res.preferredOrder = activity.owner.mPreferredOrder;
            res.match = match;
            res.isDefault = info.hasDefault;
            res.labelRes = info.labelRes;
            res.nonLocalizedLabel = info.nonLocalizedLabel;
            if (PackageManagerService.this.userNeedsBadging(userId)) {
                res.noResourceId = true;
            } else {
                res.icon = info.icon;
            }
            res.iconResourceId = info.icon;
            res.system = res.activityInfo.applicationInfo.isSystemApp();
            res.isInstantAppAvailable = userState.instantApp;
            return res;
        }

        protected void sortResults(List<ResolveInfo> results) {
            Collections.sort(results, PackageManagerService.mResolvePrioritySorter);
        }

        protected void dumpFilter(PrintWriter out, String prefix, ActivityIntentInfo filter) {
            out.print(prefix);
            out.print(Integer.toHexString(System.identityHashCode(filter.activity)));
            out.print(' ');
            filter.activity.printComponentShortName(out);
            out.print(" filter ");
            out.println(Integer.toHexString(System.identityHashCode(filter)));
        }

        protected Object filterToLabel(ActivityIntentInfo filter) {
            return filter.activity;
        }

        protected void dumpFilterLabel(PrintWriter out, String prefix, Object label, int count) {
            Activity activity = (Activity) label;
            out.print(prefix);
            out.print(Integer.toHexString(System.identityHashCode(activity)));
            out.print(' ');
            activity.printComponentShortName(out);
            if (count > 1) {
                out.print(" (");
                out.print(count);
                out.print(" filters)");
            }
            out.println();
        }
    }

    class FileInstallArgs extends InstallArgs {
        private File codeFile;
        private File resourceFile;
        final /* synthetic */ PackageManagerService this$0;

        FileInstallArgs(PackageManagerService this$0, InstallParams params) {
            InstallParams installParams = params;
            this.this$0 = this$0;
            OriginInfo originInfo = installParams.origin;
            MoveInfo moveInfo = installParams.move;
            IPackageInstallObserver2 iPackageInstallObserver2 = installParams.observer;
            int i = installParams.installFlags;
            String str = installParams.installerPackageName;
            String str2 = installParams.volumeUuid;
            UserHandle user = params.getUser();
            String str3 = installParams.packageAbiOverride;
            String[] strArr = installParams.grantedRuntimePermissions;
            String str4 = installParams.traceMethod;
            int i2 = installParams.traceCookie;
            SigningDetails signingDetails = installParams.signingDetails;
            SigningDetails signingDetails2 = signingDetails;
            super(originInfo, moveInfo, iPackageInstallObserver2, i, str, str2, user, null, str3, strArr, str4, i2, signingDetails2, installParams.installReason);
            if (isFwdLocked()) {
                throw new IllegalArgumentException("Forward locking only supported in ASEC");
            }
        }

        FileInstallArgs(PackageManagerService this$0, String codePath, String resourcePath, String[] instructionSets) {
            String str = codePath;
            String str2 = resourcePath;
            this.this$0 = this$0;
            String str3 = str;
            super(OriginInfo.fromNothing(), null, null, 0, null, null, null, instructionSets, null, null, null, 0, SigningDetails.UNKNOWN, 0);
            File file = null;
            this.codeFile = str3 != null ? new File(str3) : null;
            String str4 = resourcePath;
            if (str4 != null) {
                file = new File(str4);
            }
            this.resourceFile = file;
        }

        int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException {
            Trace.traceBegin(262144, "copyApk");
            try {
                int doCopyApk = doCopyApk(imcs, temp);
                return doCopyApk;
            } finally {
                Trace.traceEnd(262144);
            }
        }

        private int doCopyApk(IMediaContainerService imcs, boolean temp) throws RemoteException {
            StringBuilder stringBuilder;
            if (this.origin.staged) {
                if (PackageManagerService.DEBUG_INSTALL) {
                    String str = PackageManagerService.TAG;
                    stringBuilder = new StringBuilder();
                    stringBuilder.append(this.origin.file);
                    stringBuilder.append(" already staged; skipping copy");
                    Slog.d(str, stringBuilder.toString());
                }
                this.codeFile = this.origin.file;
                this.resourceFile = this.origin.file;
                return 1;
            }
            try {
                File tempDir = this.this$0.mInstallerService.allocateStageDirLegacy(this.volumeUuid, (this.installFlags & 2048) != 0);
                this.codeFile = tempDir;
                this.resourceFile = tempDir;
                int ret = imcs.copyPackage(this.origin.file.getAbsolutePath(), new IParcelFileDescriptorFactory.Stub() {
                    public ParcelFileDescriptor open(String name, int mode) throws RemoteException {
                        if (FileUtils.isValidExtFilename(name)) {
                            try {
                                File file = new File(FileInstallArgs.this.codeFile, name);
                                FileDescriptor fd = Os.open(file.getAbsolutePath(), OsConstants.O_RDWR | OsConstants.O_CREAT, 420);
                                Os.chmod(file.getAbsolutePath(), 420);
                                return new ParcelFileDescriptor(fd);
                            } catch (ErrnoException e) {
                                StringBuilder stringBuilder = new StringBuilder();
                                stringBuilder.append("Failed to open: ");
                                stringBuilder.append(e.getMessage());
                                throw new RemoteException(stringBuilder.toString());
                            }
                        }
                        StringBuilder stringBuilder2 = new StringBuilder();
                        stringBuilder2.append("Invalid filename: ");
                        stringBuilder2.append(name);
                        throw new IllegalArgumentException(stringBuilder2.toString());
                    }
                });
                if (ret != 1) {
                    Slog.e(PackageManagerService.TAG, "Failed to copy package");
                    return ret;
                }
                File libraryRoot = new File(this.codeFile, "lib");
                Handle handle = null;
                try {
                    handle = Handle.create(this.codeFile);
                    ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot, this.abiOverride);
                } catch (IOException e) {
                    Slog.e(PackageManagerService.TAG, "Copying native libraries failed", e);
                    ret = RequestStatus.SYS_ETIMEDOUT;
                } catch (Throwable th) {
                    IoUtils.closeQuietly(handle);
                }
                IoUtils.closeQuietly(handle);
                return ret;
            } catch (IOException e2) {
                String str2 = PackageManagerService.TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("Failed to create copy file: ");
                stringBuilder.append(e2);
                Slog.w(str2, stringBuilder.toString());
                return -4;
            }
        }

        int doPreInstall(int status) {
            if (status != 1) {
                cleanUp();
            }
            return status;
        }

        boolean doRename(int status, Package pkg, String oldCodePath) {
            if (status != 1) {
                cleanUp();
                return false;
            }
            String str;
            StringBuilder stringBuilder;
            File targetDir = this.codeFile.getParentFile();
            File beforeCodeFile = this.codeFile;
            File afterCodeFile = this.this$0.getNextCodePath(targetDir, pkg.packageName);
            if (PackageManagerService.DEBUG_INSTALL) {
                str = PackageManagerService.TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("Renaming ");
                stringBuilder.append(beforeCodeFile);
                stringBuilder.append(" to ");
                stringBuilder.append(afterCodeFile);
                Slog.d(str, stringBuilder.toString());
            }
            try {
                Os.rename(beforeCodeFile.getAbsolutePath(), afterCodeFile.getAbsolutePath());
                if (SELinux.restoreconRecursive(afterCodeFile)) {
                    this.codeFile = afterCodeFile;
                    this.resourceFile = afterCodeFile;
                    try {
                        pkg.setCodePath(afterCodeFile.getCanonicalPath());
                        pkg.setBaseCodePath(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.baseCodePath));
                        pkg.setSplitCodePaths(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.splitCodePaths));
                        pkg.setApplicationVolumeUuid(pkg.volumeUuid);
                        pkg.setApplicationInfoCodePath(pkg.codePath);
                        pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
                        pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
                        pkg.setApplicationInfoResourcePath(pkg.codePath);
                        pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);
                        pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
                        return true;
                    } catch (IOException e) {
                        str = PackageManagerService.TAG;
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("Failed to get path: ");
                        stringBuilder.append(afterCodeFile);
                        Slog.e(str, stringBuilder.toString(), e);
                        return false;
                    }
                }
                Slog.w(PackageManagerService.TAG, "Failed to restorecon");
                return false;
            } catch (ErrnoException e2) {
                Slog.w(PackageManagerService.TAG, "Failed to rename", e2);
                return false;
            }
        }

        int doPostInstall(int status, int uid) {
            if (status != 1) {
                cleanUp();
                this.this$0.mHwPMSEx.cleanUpHwCert();
            }
            return status;
        }

        String getCodePath() {
            return this.codeFile != null ? this.codeFile.getAbsolutePath() : null;
        }

        String getResourcePath() {
            return this.resourceFile != null ? this.resourceFile.getAbsolutePath() : null;
        }

        private boolean cleanUp() {
            if (this.codeFile == null || !this.codeFile.exists()) {
                return false;
            }
            this.this$0.removeCodePathLI(this.codeFile);
            if (!(this.resourceFile == null || FileUtils.contains(this.codeFile, this.resourceFile))) {
                this.resourceFile.delete();
            }
            return true;
        }

        void cleanUpResourcesLI() {
            List<String> allCodePaths = Collections.EMPTY_LIST;
            if (this.codeFile != null && this.codeFile.exists()) {
                try {
                    allCodePaths = PackageParser.parsePackageLite(this.codeFile, 0).getAllCodePaths();
                } catch (PackageParserException e) {
                }
            }
            cleanUp();
            this.this$0.removeDexFiles(allCodePaths, this.instructionSets);
        }

        boolean doPostDeleteLI(boolean delete) {
            cleanUpResourcesLI();
            return true;
        }
    }

    class InstallParams extends HandlerParams {
        final String[] grantedRuntimePermissions;
        int installFlags;
        final int installReason;
        final String installerPackageName;
        private InstallArgs mArgs;
        private int mRet;
        final MoveInfo move;
        final IPackageInstallObserver2 observer;
        final OriginInfo origin;
        final String packageAbiOverride;
        final SigningDetails signingDetails;
        final VerificationInfo verificationInfo;
        final String volumeUuid;

        InstallParams(OriginInfo origin, MoveInfo move, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, String volumeUuid, VerificationInfo verificationInfo, UserHandle user, String packageAbiOverride, String[] grantedPermissions, SigningDetails signingDetails, int installReason) {
            super(user);
            this.origin = origin;
            this.move = move;
            this.observer = observer;
            this.installFlags = installFlags;
            this.installerPackageName = installerPackageName;
            this.volumeUuid = volumeUuid;
            this.verificationInfo = verificationInfo;
            this.packageAbiOverride = packageAbiOverride;
            this.grantedRuntimePermissions = grantedPermissions;
            this.signingDetails = signingDetails;
            this.installReason = installReason;
        }

        public String toString() {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("InstallParams{");
            stringBuilder.append(Integer.toHexString(System.identityHashCode(this)));
            stringBuilder.append(" file=");
            stringBuilder.append(this.origin.file);
            stringBuilder.append("}");
            return stringBuilder.toString();
        }

        /* JADX WARNING: Missing block: B:64:0x00ab, code skipped:
            if (r2 == false) goto L_0x00ae;
     */
        /* JADX WARNING: Missing block: B:65:0x00ad, code skipped:
            return 2;
     */
        /* JADX WARNING: Missing block: B:67:0x00b0, code skipped:
            return r14.recommendedInstallLocation;
     */
        /* Code decompiled incorrectly, please refer to instructions dump. */
        private int installLocationPolicy(PackageInfoLite pkgLite) {
            String packageName = pkgLite.packageName;
            int installLocation = pkgLite.installLocation;
            boolean downgradePermitted = false;
            boolean onSd = (this.installFlags & 8) != 0;
            synchronized (PackageManagerService.this.mPackages) {
                Package installedPkg = (Package) PackageManagerService.this.mPackages.get(packageName);
                Package dataOwnerPkg = installedPkg;
                if (dataOwnerPkg == null) {
                    PackageSetting ps = (PackageSetting) PackageManagerService.this.mSettings.mPackages.get(packageName);
                    if (ps != null) {
                        dataOwnerPkg = ps.pkg;
                    }
                }
                if (dataOwnerPkg != null) {
                    boolean downgradeRequested = (this.installFlags & 128) != 0;
                    boolean packageDebuggable = (dataOwnerPkg.applicationInfo.flags & 2) != 0;
                    if (downgradeRequested && (Build.IS_DEBUGGABLE || packageDebuggable)) {
                        downgradePermitted = true;
                    }
                    if (!downgradePermitted) {
                        try {
                            PackageManagerService.checkDowngrade(dataOwnerPkg, pkgLite);
                        } catch (PackageManagerException e) {
                            String str = PackageManagerService.TAG;
                            StringBuilder stringBuilder = new StringBuilder();
                            stringBuilder.append("Downgrade detected: ");
                            stringBuilder.append(e.getMessage());
                            Slog.w(str, stringBuilder.toString());
                            return -7;
                        }
                    }
                }
                if (installedPkg != null) {
                    if ((this.installFlags & 2) == 0) {
                        return -4;
                    } else if ((installedPkg.applicationInfo.flags & 1) != 0) {
                        if (onSd) {
                            Slog.w(PackageManagerService.TAG, "Cannot install update to system app on sdcard");
                            return -3;
                        }
                        return 1;
                    } else if (onSd) {
                        return 2;
                    } else if (installLocation == 1) {
                        return 1;
                    } else if (installLocation != 2) {
                        if (PackageManagerService.isExternal(installedPkg)) {
                            return 2;
                        }
                        return 1;
                    }
                }
            }
        }

        public void handleStartCopy() throws RemoteException {
            int ret = 1;
            if (this.origin.staged) {
                if (this.origin.file != null) {
                    this.installFlags |= 16;
                    this.installFlags &= -9;
                } else {
                    throw new IllegalStateException("Invalid stage location");
                }
            }
            boolean onSd = (this.installFlags & 8) != 0;
            boolean onInt = (this.installFlags & 16) != 0;
            boolean ephemeral = (this.installFlags & 2048) != 0;
            PackageInfoLite pkgLite = null;
            if (onInt && onSd) {
                Slog.w(PackageManagerService.TAG, "Conflicting flags specified for installing on both internal and external");
                ret = -19;
            } else if (onSd && ephemeral) {
                Slog.w(PackageManagerService.TAG, "Conflicting flags specified for installing ephemeral on external");
                ret = -19;
            } else {
                PackageInfoLite pkgLite2 = PackageManagerService.this.mContainerService.getMinimalPackageInfo(this.origin.resolvedPath, this.installFlags, this.packageAbiOverride);
                if (PackageManagerService.DEBUG_INSTANT && ephemeral) {
                    String str = PackageManagerService.TAG;
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("pkgLite for install: ");
                    stringBuilder.append(pkgLite2);
                    Slog.v(str, stringBuilder.toString());
                }
                if (this.origin.staged || pkgLite2.recommendedInstallLocation != -1) {
                    pkgLite = pkgLite2;
                } else {
                    try {
                        PackageManagerService.this.mInstaller.freeCache(null, PackageManagerService.this.mContainerService.calculateInstalledSize(this.origin.resolvedPath, this.packageAbiOverride) + StorageManager.from(PackageManagerService.this.mContext).getStorageLowBytes(Environment.getDataDirectory()), 0, 0);
                        pkgLite = PackageManagerService.this.mContainerService.getMinimalPackageInfo(this.origin.resolvedPath, this.installFlags, this.packageAbiOverride);
                    } catch (InstallerException e) {
                        Slog.w(PackageManagerService.TAG, "Failed to free cache", e);
                        pkgLite = pkgLite2;
                    }
                    if (pkgLite.recommendedInstallLocation == -6) {
                        pkgLite.recommendedInstallLocation = -1;
                    }
                }
            }
            if (ret == 1) {
                int loc = pkgLite.recommendedInstallLocation;
                if (loc == -3) {
                    ret = -19;
                } else if (loc == -4) {
                    ret = -1;
                } else if (loc == -1) {
                    ret = -4;
                } else if (loc == -2) {
                    ret = -2;
                } else if (loc == -6) {
                    ret = -3;
                } else if (loc == -5) {
                    ret = -20;
                } else {
                    loc = installLocationPolicy(pkgLite);
                    if (loc == -7) {
                        ret = -25;
                    } else if (!(onSd || onInt)) {
                        if (loc == 2) {
                            this.installFlags |= 8;
                            this.installFlags &= -17;
                        } else if (loc == 3) {
                            if (PackageManagerService.DEBUG_INSTANT) {
                                Slog.v(PackageManagerService.TAG, "...setting INSTALL_EPHEMERAL install flag");
                            }
                            this.installFlags |= 2048;
                            this.installFlags &= -25;
                        } else {
                            this.installFlags |= 16;
                            this.installFlags &= -9;
                        }
                    }
                }
            }
            InstallArgs args = PackageManagerService.this.createInstallArgs(this);
            if (pkgLite != null) {
                args.packageName = pkgLite.packageName;
                args.packageVersion = pkgLite.versionCode;
            }
            this.mArgs = args;
            ISecurityProfileController spc = HwServiceFactory.getSecurityProfileController();
            if (spc != null) {
                String str2 = args.packageName;
                StringBuilder stringBuilder2 = new StringBuilder();
                stringBuilder2.append(this.origin.file.getAbsolutePath());
                stringBuilder2.append("/base.apk");
                if (!spc.verifyPackage(str2, stringBuilder2.toString())) {
                    Slog.e(PackageManagerService.TAG, "Security policy verification failed");
                }
            }
            int i;
            ISecurityProfileController iSecurityProfileController;
            boolean z;
            if (ret == 1) {
                UserHandle verifierUser = getUser();
                if (verifierUser == UserHandle.ALL) {
                    verifierUser = UserHandle.SYSTEM;
                }
                int requiredUid = PackageManagerService.this.mRequiredVerifierPackage == null ? -1 : PackageManagerService.this.getPackageUid(PackageManagerService.this.mRequiredVerifierPackage, 268435456, verifierUser.getIdentifier());
                int installerUid = this.verificationInfo == null ? -1 : this.verificationInfo.installerUid;
                int i2;
                int i3;
                if (this.origin.existing || requiredUid == -1 || !PackageManagerService.this.isVerificationEnabled(verifierUser.getIdentifier(), this.installFlags, installerUid)) {
                    i = ret;
                    iSecurityProfileController = spc;
                    z = onSd;
                    i2 = installerUid;
                    i3 = requiredUid;
                    ret = args.copyApk(PackageManagerService.this.mContainerService, true);
                } else {
                    Intent verification = new Intent("android.intent.action.PACKAGE_NEEDS_VERIFICATION");
                    verification.addFlags(268435456);
                    verification.setDataAndType(Uri.fromFile(new File(this.origin.resolvedPath)), PackageManagerService.PACKAGE_MIME_TYPE);
                    verification.addFlags(1);
                    List<ResolveInfo> receivers = PackageManagerService.this.queryIntentReceiversInternal(verification, PackageManagerService.PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(), false);
                    if (PackageManagerService.DEBUG_VERIFY) {
                        String str3 = PackageManagerService.TAG;
                        StringBuilder stringBuilder3 = new StringBuilder();
                        stringBuilder3.append("Found ");
                        stringBuilder3.append(receivers.size());
                        stringBuilder3.append(" verifiers for intent ");
                        stringBuilder3.append(verification.toString());
                        stringBuilder3.append(" with ");
                        stringBuilder3.append(pkgLite.verifiers.length);
                        stringBuilder3.append(" optional verifiers");
                        Slog.d(str3, stringBuilder3.toString());
                    }
                    final int verificationId = PackageManagerService.this.mPendingVerificationToken = PackageManagerService.this.mPendingVerificationToken + 1;
                    verification.putExtra("android.content.pm.extra.VERIFICATION_ID", verificationId);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_INSTALLER_PACKAGE", this.installerPackageName);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_INSTALL_FLAGS", this.installFlags);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_PACKAGE_NAME", pkgLite.packageName);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_VERSION_CODE", pkgLite.versionCode);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_LONG_VERSION_CODE", pkgLite.getLongVersionCode());
                    if (this.verificationInfo != null) {
                        if (this.verificationInfo.originatingUri != null) {
                            verification.putExtra("android.intent.extra.ORIGINATING_URI", this.verificationInfo.originatingUri);
                        }
                        if (this.verificationInfo.referrer != null) {
                            verification.putExtra("android.intent.extra.REFERRER", this.verificationInfo.referrer);
                        }
                        if (this.verificationInfo.originatingUid >= 0) {
                            verification.putExtra("android.intent.extra.ORIGINATING_UID", this.verificationInfo.originatingUid);
                        }
                        if (this.verificationInfo.installerUid >= 0) {
                            verification.putExtra("android.content.pm.extra.VERIFICATION_INSTALLER_UID", this.verificationInfo.installerUid);
                        }
                    }
                    PackageVerificationState verificationState = new PackageVerificationState(requiredUid, args);
                    PackageManagerService.this.mPendingVerification.append(verificationId, verificationState);
                    onSd = PackageManagerService.this.matchVerifiers(pkgLite, receivers, verificationState);
                    LocalService idleController = PackageManagerService.this.getDeviceIdleController();
                    long idleDuration = PackageManagerService.this.getVerificationTimeout();
                    PackageVerificationState packageVerificationState;
                    if (onSd) {
                        int N = onSd.size();
                        if (N == 0) {
                            Slog.i(PackageManagerService.TAG, "Additional verifiers required, but none installed.");
                            ret = -22;
                            packageVerificationState = verificationState;
                            if (ret == 1 || PackageManagerService.this.mRequiredVerifierPackage == null) {
                                i3 = requiredUid;
                            } else {
                                pkgLite = PackageManagerService.this.matchComponentForVerifier(PackageManagerService.this.mRequiredVerifierPackage, receivers);
                                Trace.asyncTraceBegin(262144, "verification", verificationId);
                                verification.setComponent(pkgLite);
                                idleController.addPowerSaveTempWhitelistApp(Process.myUid(), PackageManagerService.this.mRequiredVerifierPackage, idleDuration, verifierUser.getIdentifier(), false, "package verifier");
                                Intent spc2 = verification;
                                PackageManagerService.this.mContext.sendOrderedBroadcastAsUser(verification, verifierUser, "android.permission.PACKAGE_VERIFICATION_AGENT", new BroadcastReceiver() {
                                    public void onReceive(Context context, Intent intent) {
                                        Message msg = PackageManagerService.this.mHandler.obtainMessage(16);
                                        msg.arg1 = verificationId;
                                        PackageManagerService.this.mHandler.sendMessageDelayed(msg, PackageManagerService.this.getVerificationTimeout());
                                    }
                                }, null, 0, null, null);
                                this.mArgs = null;
                            }
                        } else {
                            i2 = 0;
                            while (true) {
                                pkgLite = i2;
                                if (pkgLite >= N) {
                                    break;
                                }
                                ComponentName verifierComponent = (ComponentName) onSd.get(pkgLite);
                                idleController.addPowerSaveTempWhitelistApp(Process.myUid(), verifierComponent.getPackageName(), idleDuration, verifierUser.getIdentifier(), false, "package verifier");
                                i = ret;
                                ret = new Intent(verification);
                                ret.setComponent(verifierComponent);
                                packageVerificationState = verificationState;
                                PackageManagerService.this.mContext.sendBroadcastAsUser(ret, verifierUser);
                                i2 = pkgLite + 1;
                                ret = i;
                                verificationState = packageVerificationState;
                            }
                            i = ret;
                            packageVerificationState = verificationState;
                        }
                    } else {
                        i = ret;
                        packageVerificationState = verificationState;
                    }
                    ret = i;
                    if (ret == 1) {
                    }
                    i3 = requiredUid;
                }
            } else {
                i = ret;
                iSecurityProfileController = spc;
                z = onSd;
            }
            this.mRet = ret;
        }

        void handleReturnCode() {
            if (this.mArgs != null) {
                PackageManagerService.this.processPendingInstall(this.mArgs, this.mRet);
            }
        }

        void handleServiceError() {
            this.mArgs = PackageManagerService.this.createInstallArgs(this);
            this.mRet = RequestStatus.SYS_ETIMEDOUT;
        }
    }

    static final class InstantAppIntentResolver extends IntentResolver<AuxiliaryFilter, AuxiliaryFilter> {
        final ArrayMap<String, Pair<Integer, InstantAppResolveInfo>> mOrderResult = new ArrayMap();

        InstantAppIntentResolver() {
        }

        protected AuxiliaryFilter[] newArray(int size) {
            return new AuxiliaryFilter[size];
        }

        protected boolean isPackageForFilter(String packageName, AuxiliaryFilter responseObj) {
            return true;
        }

        protected AuxiliaryFilter newResult(AuxiliaryFilter responseObj, int match, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            String packageName = responseObj.resolveInfo.getPackageName();
            Integer order = Integer.valueOf(responseObj.getOrder());
            Pair<Integer, InstantAppResolveInfo> lastOrderResult = (Pair) this.mOrderResult.get(packageName);
            if (lastOrderResult != null && ((Integer) lastOrderResult.first).intValue() >= order.intValue()) {
                return null;
            }
            InstantAppResolveInfo res = responseObj.resolveInfo;
            if (order.intValue() > 0) {
                this.mOrderResult.put(packageName, new Pair(order, res));
            }
            return responseObj;
        }

        protected void filterResults(List<AuxiliaryFilter> results) {
            if (this.mOrderResult.size() != 0) {
                int resultSize = results.size();
                int i = 0;
                while (i < resultSize) {
                    InstantAppResolveInfo info = ((AuxiliaryFilter) results.get(i)).resolveInfo;
                    String packageName = info.getPackageName();
                    Pair<Integer, InstantAppResolveInfo> savedInfo = (Pair) this.mOrderResult.get(packageName);
                    if (savedInfo != null) {
                        if (savedInfo.second == info) {
                            this.mOrderResult.remove(packageName);
                            if (this.mOrderResult.size() == 0) {
                                break;
                            }
                        } else {
                            results.remove(i);
                            resultSize--;
                            i--;
                        }
                    }
                    i++;
                }
            }
        }
    }

    private class IntentVerifierProxy implements IntentFilterVerifier<ActivityIntentInfo> {
        private Context mContext;
        private ArrayList<Integer> mCurrentIntentFilterVerifications = new ArrayList();
        private ComponentName mIntentFilterVerifierComponent;

        public IntentVerifierProxy(Context context, ComponentName verifierComponent) {
            this.mContext = context;
            this.mIntentFilterVerifierComponent = verifierComponent;
        }

        private String getDefaultScheme() {
            return "https";
        }

        public void startVerifications(int userId) {
            int count = this.mCurrentIntentFilterVerifications.size();
            for (int n = 0; n < count; n++) {
                int verificationId = ((Integer) this.mCurrentIntentFilterVerifications.get(n)).intValue();
                IntentFilterVerificationState ivs = (IntentFilterVerificationState) PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
                String packageName = ivs.getPackageName();
                ArrayList<ActivityIntentInfo> filters = ivs.getFilters();
                int filterCount = filters.size();
                ArraySet<String> domainsSet = new ArraySet();
                for (int m = 0; m < filterCount; m++) {
                    domainsSet.addAll(((ActivityIntentInfo) filters.get(m)).getHostsList());
                }
                synchronized (PackageManagerService.this.mPackages) {
                    if (PackageManagerService.this.mSettings.createIntentFilterVerificationIfNeededLPw(packageName, domainsSet) != null) {
                        PackageManagerService.this.scheduleWriteSettingsLocked();
                    }
                }
                sendVerificationRequest(verificationId, ivs);
            }
            this.mCurrentIntentFilterVerifications.clear();
        }

        private void sendVerificationRequest(int verificationId, IntentFilterVerificationState ivs) {
            Intent verificationIntent = new Intent("android.intent.action.INTENT_FILTER_NEEDS_VERIFICATION");
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_ID", verificationId);
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_URI_SCHEME", getDefaultScheme());
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_HOSTS", ivs.getHostsString());
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_PACKAGE_NAME", ivs.getPackageName());
            verificationIntent.setComponent(this.mIntentFilterVerifierComponent);
            verificationIntent.addFlags(268435456);
            PackageManagerService.this.getDeviceIdleController().addPowerSaveTempWhitelistApp(Process.myUid(), this.mIntentFilterVerifierComponent.getPackageName(), PackageManagerService.this.getVerificationTimeout(), 0, true, "intent filter verifier");
            this.mContext.sendBroadcastAsUser(verificationIntent, UserHandle.SYSTEM);
            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(PackageManagerService.TAG, "Sending IntentFilter verification broadcast");
            }
        }

        public void receiveVerificationResponse(int verificationId) {
            String str;
            String str2;
            StringBuilder stringBuilder;
            IntentFilterVerificationInfo ivi;
            IntentFilterVerificationState ivs = (IntentFilterVerificationState) PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
            boolean verified = ivs.isVerified();
            ArrayList<ActivityIntentInfo> filters = ivs.getFilters();
            int count = filters.size();
            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                str = PackageManagerService.TAG;
                StringBuilder stringBuilder2 = new StringBuilder();
                stringBuilder2.append("Received verification response ");
                stringBuilder2.append(verificationId);
                stringBuilder2.append(" for ");
                stringBuilder2.append(count);
                stringBuilder2.append(" filters, verified=");
                stringBuilder2.append(verified);
                Slog.i(str, stringBuilder2.toString());
            }
            for (int n = 0; n < count; n++) {
                ActivityIntentInfo filter = (ActivityIntentInfo) filters.get(n);
                filter.setVerified(verified);
                if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                    str2 = PackageManagerService.TAG;
                    stringBuilder = new StringBuilder();
                    stringBuilder.append("IntentFilter ");
                    stringBuilder.append(filter.toString());
                    stringBuilder.append(" verified with result:");
                    stringBuilder.append(verified);
                    stringBuilder.append(" and hosts:");
                    stringBuilder.append(ivs.getHostsString());
                    Slog.d(str2, stringBuilder.toString());
                }
            }
            PackageManagerService.this.mIntentFilterVerificationStates.remove(verificationId);
            str = ivs.getPackageName();
            synchronized (PackageManagerService.this.mPackages) {
                ivi = PackageManagerService.this.mSettings.getIntentFilterVerificationLPr(str);
            }
            if (ivi == null) {
                str2 = PackageManagerService.TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("IntentFilterVerificationInfo not found for verificationId:");
                stringBuilder.append(verificationId);
                stringBuilder.append(" packageName:");
                stringBuilder.append(str);
                Slog.w(str2, stringBuilder.toString());
                return;
            }
            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                str2 = PackageManagerService.TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("Updating IntentFilterVerificationInfo for package ");
                stringBuilder.append(str);
                stringBuilder.append(" verificationId:");
                stringBuilder.append(verificationId);
                Slog.d(str2, stringBuilder.toString());
            }
            synchronized (PackageManagerService.this.mPackages) {
                if (verified) {
                    try {
                        ivi.setStatus(2);
                    } catch (Throwable th) {
                    }
                } else {
                    ivi.setStatus(1);
                }
                PackageManagerService.this.scheduleWriteSettingsLocked();
                int userId = ivs.getUserId();
                if (userId != -1) {
                    int updatedStatus = 0;
                    boolean needUpdate = false;
                    switch (PackageManagerService.this.mSettings.getIntentFilterVerificationStatusLPr(str, userId)) {
                        case 0:
                            if (verified) {
                                updatedStatus = 2;
                            } else {
                                updatedStatus = 1;
                            }
                            needUpdate = true;
                            break;
                        case 1:
                            if (verified) {
                                updatedStatus = 2;
                                needUpdate = true;
                                break;
                            }
                            break;
                        default:
                            break;
                    }
                    if (needUpdate) {
                        PackageManagerService.this.mSettings.updateIntentFilterVerificationStatusLPw(str, updatedStatus, userId);
                        PackageManagerService.this.scheduleWritePackageRestrictionsLocked(userId);
                    }
                }
            }
        }

        public boolean addOneIntentFilterVerification(int verifierUid, int userId, int verificationId, ActivityIntentInfo filter, String packageName) {
            if (!PackageManagerService.hasValidDomains(filter)) {
                return false;
            }
            IntentFilterVerificationState ivs = (IntentFilterVerificationState) PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
            if (ivs == null) {
                ivs = createDomainVerificationState(verifierUid, userId, verificationId, packageName);
            }
            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                String str = PackageManagerService.TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Adding verification filter for ");
                stringBuilder.append(packageName);
                stringBuilder.append(": ");
                stringBuilder.append(filter);
                Slog.d(str, stringBuilder.toString());
            }
            ivs.addFilter(filter);
            return true;
        }

        private IntentFilterVerificationState createDomainVerificationState(int verifierUid, int userId, int verificationId, String packageName) {
            IntentFilterVerificationState ivs = new IntentFilterVerificationState(verifierUid, userId, packageName);
            ivs.setPendingState();
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mIntentFilterVerificationStates.append(verificationId, ivs);
                this.mCurrentIntentFilterVerifications.add(Integer.valueOf(verificationId));
            }
            return ivs;
        }
    }

    class MoveInstallArgs extends InstallArgs {
        private File codeFile;
        private File resourceFile;
        final /* synthetic */ PackageManagerService this$0;

        MoveInstallArgs(PackageManagerService this$0, InstallParams params) {
            InstallParams installParams = params;
            this.this$0 = this$0;
            OriginInfo originInfo = installParams.origin;
            MoveInfo moveInfo = installParams.move;
            IPackageInstallObserver2 iPackageInstallObserver2 = installParams.observer;
            int i = installParams.installFlags;
            String str = installParams.installerPackageName;
            String str2 = installParams.volumeUuid;
            UserHandle user = params.getUser();
            String str3 = installParams.packageAbiOverride;
            String[] strArr = installParams.grantedRuntimePermissions;
            String str4 = installParams.traceMethod;
            int i2 = installParams.traceCookie;
            SigningDetails signingDetails = installParams.signingDetails;
            SigningDetails signingDetails2 = signingDetails;
            super(originInfo, moveInfo, iPackageInstallObserver2, i, str, str2, user, null, str3, strArr, str4, i2, signingDetails2, installParams.installReason);
        }

        int copyApk(IMediaContainerService imcs, boolean temp) {
            String str;
            StringBuilder stringBuilder;
            if (PackageManagerService.DEBUG_INSTALL) {
                str = PackageManagerService.TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("Moving ");
                stringBuilder.append(this.move.packageName);
                stringBuilder.append(" from ");
                stringBuilder.append(this.move.fromUuid);
                stringBuilder.append(" to ");
                stringBuilder.append(this.move.toUuid);
                Slog.d(str, stringBuilder.toString());
            }
            synchronized (this.this$0.mInstaller) {
                try {
                    this.this$0.mInstaller.moveCompleteApp(this.move.fromUuid, this.move.toUuid, this.move.packageName, this.move.dataAppName, this.move.appId, this.move.seinfo, this.move.targetSdkVersion);
                } catch (InstallerException e) {
                    Slog.w(PackageManagerService.TAG, "Failed to move app", e);
                    return RequestStatus.SYS_ETIMEDOUT;
                }
            }
            this.codeFile = new File(Environment.getDataAppDirectory(this.move.toUuid), this.move.dataAppName);
            this.resourceFile = this.codeFile;
            if (PackageManagerService.DEBUG_INSTALL) {
                str = PackageManagerService.TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("codeFile after move is ");
                stringBuilder.append(this.codeFile);
                Slog.d(str, stringBuilder.toString());
            }
            return 1;
        }

        int doPreInstall(int status) {
            if (status != 1) {
                cleanUp(this.move.toUuid);
            }
            return status;
        }

        boolean doRename(int status, Package pkg, String oldCodePath) {
            if (status != 1) {
                cleanUp(this.move.toUuid);
                return false;
            }
            pkg.setApplicationVolumeUuid(pkg.volumeUuid);
            pkg.setApplicationInfoCodePath(pkg.codePath);
            pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
            pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
            pkg.setApplicationInfoResourcePath(pkg.codePath);
            pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);
            pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
            return true;
        }

        int doPostInstall(int status, int uid) {
            if (status == 1) {
                cleanUp(this.move.fromUuid);
            } else {
                this.this$0.mHwPMSEx.cleanUpHwCert();
                cleanUp(this.move.toUuid);
            }
            return status;
        }

        String getCodePath() {
            return this.codeFile != null ? this.codeFile.getAbsolutePath() : null;
        }

        String getResourcePath() {
            return this.resourceFile != null ? this.resourceFile.getAbsolutePath() : null;
        }

        private boolean cleanUp(String volumeUuid) {
            File codeFile = new File(Environment.getDataAppDirectory(volumeUuid), this.move.dataAppName);
            String str = PackageManagerService.TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Cleaning up ");
            stringBuilder.append(this.move.packageName);
            stringBuilder.append(" on ");
            stringBuilder.append(volumeUuid);
            Slog.d(str, stringBuilder.toString());
            synchronized (this.this$0.mInstallLock) {
                for (int userId : PackageManagerService.sUserManager.getUserIds()) {
                    try {
                        this.this$0.mInstaller.destroyAppData(volumeUuid, this.move.packageName, userId, 3, 0);
                    } catch (InstallerException e) {
                        Slog.w(PackageManagerService.TAG, String.valueOf(e));
                    }
                }
                this.this$0.removeCodePathLI(codeFile);
            }
            return true;
        }

        void cleanUpResourcesLI() {
            throw new UnsupportedOperationException();
        }

        boolean doPostDeleteLI(boolean delete) {
            throw new UnsupportedOperationException();
        }
    }

    class ParallelPackageParserCallback extends PackageParserCallback {
        List<Package> mOverlayPackages = null;

        ParallelPackageParserCallback() {
            super();
        }

        void findStaticOverlayPackages() {
            synchronized (PackageManagerService.this.mPackages) {
                for (Package p : PackageManagerService.this.mPackages.values()) {
                    if (p.mOverlayIsStatic) {
                        if (this.mOverlayPackages == null) {
                            this.mOverlayPackages = new ArrayList();
                        }
                        this.mOverlayPackages.add(p);
                    }
                }
            }
        }

        synchronized String[] getStaticOverlayPaths(String targetPackageName, String targetPath) {
            String[] strArr;
            if (this.mOverlayPackages == null) {
                strArr = null;
            } else {
                strArr = getStaticOverlayPaths(getStaticOverlayPackages(this.mOverlayPackages, targetPackageName), targetPath);
            }
            return strArr;
        }
    }

    private final class ProviderIntentResolver extends IntentResolver<ProviderIntentInfo, ResolveInfo> {
        private int mFlags;
        private final ArrayMap<ComponentName, Provider> mProviders;

        private ProviderIntentResolver() {
            this.mProviders = new ArrayMap();
        }

        /* synthetic */ ProviderIntentResolver(PackageManagerService x0, AnonymousClass1 x1) {
            this();
        }

        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) {
            this.mFlags = defaultOnly ? 65536 : 0;
            return super.queryIntent(intent, resolvedType, defaultOnly, userId);
        }

        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, int flags, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            this.mFlags = flags;
            return super.queryIntent(intent, resolvedType, (65536 & flags) != 0, userId);
        }

        public List<ResolveInfo> queryIntentForPackage(Intent intent, String resolvedType, int flags, ArrayList<Provider> packageProviders, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId) || packageProviders == null) {
                return null;
            }
            this.mFlags = flags;
            int i = 0;
            boolean defaultOnly = (65536 & flags) != 0;
            int N = packageProviders.size();
            ArrayList<ProviderIntentInfo[]> listCut = new ArrayList(N);
            while (i < N) {
                ArrayList<ProviderIntentInfo> intentFilters = ((Provider) packageProviders.get(i)).intents;
                if (intentFilters != null && intentFilters.size() > 0) {
                    ProviderIntentInfo[] array = new ProviderIntentInfo[intentFilters.size()];
                    intentFilters.toArray(array);
                    listCut.add(array);
                }
                i++;
            }
            return super.queryIntentFromList(intent, resolvedType, defaultOnly, listCut, userId);
        }

        public final void addProvider(Provider p) {
            String str;
            StringBuilder stringBuilder;
            if (this.mProviders.containsKey(p.getComponentName())) {
                str = PackageManagerService.TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("Provider ");
                stringBuilder.append(p.getComponentName());
                stringBuilder.append(" already defined; ignoring");
                Slog.w(str, stringBuilder.toString());
                return;
            }
            this.mProviders.put(p.getComponentName(), p);
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                str = PackageManagerService.TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("  ");
                stringBuilder.append(p.info.nonLocalizedLabel != null ? p.info.nonLocalizedLabel : p.info.name);
                stringBuilder.append(":");
                Log.v(str, stringBuilder.toString());
                str = PackageManagerService.TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("    Class=");
                stringBuilder.append(p.info.name);
                Log.v(str, stringBuilder.toString());
            }
            int NI = p.intents.size();
            for (int j = 0; j < NI; j++) {
                ProviderIntentInfo intent = (ProviderIntentInfo) p.intents.get(j);
                if (PackageManagerService.DEBUG_SHOW_INFO) {
                    Log.v(PackageManagerService.TAG, "    IntentFilter:");
                    intent.dump(new LogPrinter(2, PackageManagerService.TAG), "      ");
                }
                if (!intent.debugCheck()) {
                    String str2 = PackageManagerService.TAG;
                    StringBuilder stringBuilder2 = new StringBuilder();
                    stringBuilder2.append("==> For Provider ");
                    stringBuilder2.append(p.info.name);
                    Log.w(str2, stringBuilder2.toString());
                }
                addFilter(intent);
            }
        }

        public final void removeProvider(Provider p) {
            this.mProviders.remove(p.getComponentName());
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                String str = PackageManagerService.TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("  ");
                stringBuilder.append(p.info.nonLocalizedLabel != null ? p.info.nonLocalizedLabel : p.info.name);
                stringBuilder.append(":");
                Log.v(str, stringBuilder.toString());
                str = PackageManagerService.TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("    Class=");
                stringBuilder.append(p.info.name);
                Log.v(str, stringBuilder.toString());
            }
            int NI = p.intents.size();
            for (int j = 0; j < NI; j++) {
                ProviderIntentInfo intent = (ProviderIntentInfo) p.intents.get(j);
                if (PackageManagerService.DEBUG_SHOW_INFO) {
                    Log.v(PackageManagerService.TAG, "    IntentFilter:");
                    intent.dump(new LogPrinter(2, PackageManagerService.TAG), "      ");
                }
                removeFilter(intent);
            }
        }

        protected boolean allowFilterResult(ProviderIntentInfo filter, List<ResolveInfo> dest) {
            ProviderInfo filterPi = filter.provider.info;
            for (int i = dest.size() - 1; i >= 0; i--) {
                ProviderInfo destPi = ((ResolveInfo) dest.get(i)).providerInfo;
                if (destPi.name == filterPi.name && destPi.packageName == filterPi.packageName) {
                    return false;
                }
            }
            return true;
        }

        protected ProviderIntentInfo[] newArray(int size) {
            return new ProviderIntentInfo[size];
        }

        protected boolean isFilterStopped(ProviderIntentInfo filter, int userId) {
            boolean z = true;
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return true;
            }
            Package p = filter.provider.owner;
            if (p != null) {
                PackageSetting ps = p.mExtras;
                if (ps != null) {
                    if (!((ps.pkgFlags & 1) == 0 && ps.getStopped(userId))) {
                        z = false;
                    }
                    return z;
                }
            }
            return false;
        }

        protected boolean isPackageForFilter(String packageName, ProviderIntentInfo info) {
            return packageName.equals(info.provider.owner.packageName);
        }

        protected ResolveInfo newResult(ProviderIntentInfo filter, int match, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            ProviderIntentInfo info = filter;
            if (!PackageManagerService.this.mSettings.isEnabledAndMatchLPr(info.provider.info, this.mFlags, userId)) {
                return null;
            }
            Provider provider = info.provider;
            PackageSetting ps = provider.owner.mExtras;
            if (ps == null) {
                return null;
            }
            if (PackageManagerService.this.mSafeMode && !PackageManagerService.this.isSystemPathApp(ps)) {
                return null;
            }
            PackageUserState userState = ps.readUserState(userId);
            boolean isInstantApp = false;
            boolean matchVisibleToInstantApp = (this.mFlags & DumpState.DUMP_SERVICE_PERMISSIONS) != 0;
            if ((this.mFlags & DumpState.DUMP_VOLUMES) != 0) {
                isInstantApp = true;
            }
            if (matchVisibleToInstantApp && !info.isVisibleToInstantApp() && !userState.instantApp) {
                return null;
            }
            if (!isInstantApp && userState.instantApp) {
                return null;
            }
            if (userState.instantApp && ps.isUpdateAvailable()) {
                return null;
            }
            ProviderInfo pi = PackageParser.generateProviderInfo(provider, this.mFlags, userState, userId);
            if (pi == null) {
                return null;
            }
            ResolveInfo res = new ResolveInfo();
            res.providerInfo = pi;
            if ((this.mFlags & 64) != 0) {
                res.filter = filter;
            }
            res.priority = info.getPriority();
            res.preferredOrder = provider.owner.mPreferredOrder;
            res.match = match;
            res.isDefault = info.hasDefault;
            res.labelRes = info.labelRes;
            res.nonLocalizedLabel = info.nonLocalizedLabel;
            res.icon = info.icon;
            res.system = res.providerInfo.applicationInfo.isSystemApp();
            return res;
        }

        protected void sortResults(List<ResolveInfo> results) {
            Collections.sort(results, PackageManagerService.mResolvePrioritySorter);
        }

        protected void dumpFilter(PrintWriter out, String prefix, ProviderIntentInfo filter) {
            out.print(prefix);
            out.print(Integer.toHexString(System.identityHashCode(filter.provider)));
            out.print(' ');
            filter.provider.printComponentShortName(out);
            out.print(" filter ");
            out.println(Integer.toHexString(System.identityHashCode(filter)));
        }

        protected Object filterToLabel(ProviderIntentInfo filter) {
            return filter.provider;
        }

        protected void dumpFilterLabel(PrintWriter out, String prefix, Object label, int count) {
            Provider provider = (Provider) label;
            out.print(prefix);
            out.print(Integer.toHexString(System.identityHashCode(provider)));
            out.print(' ');
            provider.printComponentShortName(out);
            if (count > 1) {
                out.print(" (");
                out.print(count);
                out.print(" filters)");
            }
            out.println();
        }
    }

    private final class ServiceIntentResolver extends IntentResolver<ServiceIntentInfo, ResolveInfo> {
        private int mFlags;
        private final ArrayMap<ComponentName, Service> mServices;

        private ServiceIntentResolver() {
            this.mServices = new ArrayMap();
        }

        /* synthetic */ ServiceIntentResolver(PackageManagerService x0, AnonymousClass1 x1) {
            this();
        }

        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) {
            this.mFlags = defaultOnly ? 65536 : 0;
            return super.queryIntent(intent, resolvedType, defaultOnly, userId);
        }

        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, int flags, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            this.mFlags = flags;
            return super.queryIntent(intent, resolvedType, (65536 & flags) != 0, userId);
        }

        public List<ResolveInfo> queryIntentForPackage(Intent intent, String resolvedType, int flags, ArrayList<Service> packageServices, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId) || packageServices == null) {
                return null;
            }
            this.mFlags = flags;
            int i = 0;
            boolean defaultOnly = (65536 & flags) != 0;
            int N = packageServices.size();
            ArrayList<ServiceIntentInfo[]> listCut = new ArrayList(N);
            while (i < N) {
                ArrayList<ServiceIntentInfo> intentFilters = ((Service) packageServices.get(i)).intents;
                if (intentFilters != null && intentFilters.size() > 0) {
                    ServiceIntentInfo[] array = new ServiceIntentInfo[intentFilters.size()];
                    intentFilters.toArray(array);
                    listCut.add(array);
                }
                i++;
            }
            return super.queryIntentFromList(intent, resolvedType, defaultOnly, listCut, userId);
        }

        public final void addService(Service s) {
            this.mServices.put(s.getComponentName(), s);
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                String str = PackageManagerService.TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("  ");
                stringBuilder.append(s.info.nonLocalizedLabel != null ? s.info.nonLocalizedLabel : s.info.name);
                stringBuilder.append(":");
                Log.v(str, stringBuilder.toString());
                str = PackageManagerService.TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("    Class=");
                stringBuilder.append(s.info.name);
                Log.v(str, stringBuilder.toString());
            }
            int NI = s.intents.size();
            for (int j = 0; j < NI; j++) {
                ServiceIntentInfo intent = (ServiceIntentInfo) s.intents.get(j);
                if (PackageManagerService.DEBUG_SHOW_INFO) {
                    Log.v(PackageManagerService.TAG, "    IntentFilter:");
                    intent.dump(new LogPrinter(2, PackageManagerService.TAG), "      ");
                }
                if (!intent.debugCheck()) {
                    String str2 = PackageManagerService.TAG;
                    StringBuilder stringBuilder2 = new StringBuilder();
                    stringBuilder2.append("==> For Service ");
                    stringBuilder2.append(s.info.name);
                    Log.w(str2, stringBuilder2.toString());
                }
                addFilter(intent);
            }
        }

        public final void removeService(Service s) {
            this.mServices.remove(s.getComponentName());
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                String str = PackageManagerService.TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("  ");
                stringBuilder.append(s.info.nonLocalizedLabel != null ? s.info.nonLocalizedLabel : s.info.name);
                stringBuilder.append(":");
                Log.v(str, stringBuilder.toString());
                str = PackageManagerService.TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("    Class=");
                stringBuilder.append(s.info.name);
                Log.v(str, stringBuilder.toString());
            }
            int NI = s.intents.size();
            for (int j = 0; j < NI; j++) {
                ServiceIntentInfo intent = (ServiceIntentInfo) s.intents.get(j);
                if (PackageManagerService.DEBUG_SHOW_INFO) {
                    Log.v(PackageManagerService.TAG, "    IntentFilter:");
                    intent.dump(new LogPrinter(2, PackageManagerService.TAG), "      ");
                }
                removeFilter(intent);
            }
        }

        protected boolean allowFilterResult(ServiceIntentInfo filter, List<ResolveInfo> dest) {
            ServiceInfo filterSi = filter.service.info;
            for (int i = dest.size() - 1; i >= 0; i--) {
                ServiceInfo destAi = ((ResolveInfo) dest.get(i)).serviceInfo;
                if (destAi.name == filterSi.name && destAi.packageName == filterSi.packageName) {
                    return false;
                }
            }
            return true;
        }

        protected ServiceIntentInfo[] newArray(int size) {
            return new ServiceIntentInfo[size];
        }

        protected boolean isFilterStopped(ServiceIntentInfo filter, int userId) {
            boolean z = true;
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return true;
            }
            Package p = filter.service.owner;
            if (p != null) {
                PackageSetting ps = p.mExtras;
                if (ps != null) {
                    if (!((ps.pkgFlags & 1) == 0 && ps.getStopped(userId))) {
                        z = false;
                    }
                    return z;
                }
            }
            return false;
        }

        protected boolean isPackageForFilter(String packageName, ServiceIntentInfo info) {
            return packageName.equals(info.service.owner.packageName);
        }

        protected ResolveInfo newResult(ServiceIntentInfo filter, int match, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            ServiceIntentInfo info = filter;
            if (!PackageManagerService.this.mSettings.isEnabledAndMatchLPr(info.service.info, this.mFlags, userId)) {
                return null;
            }
            Service service = info.service;
            PackageSetting ps = service.owner.mExtras;
            if (ps == null) {
                return null;
            }
            if (PackageManagerService.this.mSafeMode && !PackageManagerService.this.isSystemPathApp(ps)) {
                return null;
            }
            PackageUserState userState = ps.readUserState(userId);
            ServiceInfo si = PackageParser.generateServiceInfo(service, this.mFlags, userState, userId);
            if (si == null) {
                return null;
            }
            boolean isInstantApp = false;
            boolean matchVisibleToInstantApp = (this.mFlags & DumpState.DUMP_SERVICE_PERMISSIONS) != 0;
            if ((this.mFlags & DumpState.DUMP_VOLUMES) != 0) {
                isInstantApp = true;
            }
            if (matchVisibleToInstantApp && !info.isVisibleToInstantApp() && !userState.instantApp) {
                return null;
            }
            if (!isInstantApp && userState.instantApp) {
                return null;
            }
            if (userState.instantApp && ps.isUpdateAvailable()) {
                return null;
            }
            ResolveInfo res = new ResolveInfo();
            res.serviceInfo = si;
            if ((this.mFlags & 64) != 0) {
                res.filter = filter;
            }
            res.priority = info.getPriority();
            res.preferredOrder = service.owner.mPreferredOrder;
            res.match = match;
            res.isDefault = info.hasDefault;
            res.labelRes = info.labelRes;
            res.nonLocalizedLabel = info.nonLocalizedLabel;
            res.icon = info.icon;
            res.system = res.serviceInfo.applicationInfo.isSystemApp();
            return res;
        }

        protected void sortResults(List<ResolveInfo> results) {
            Collections.sort(results, PackageManagerService.mResolvePrioritySorter);
        }

        protected void dumpFilter(PrintWriter out, String prefix, ServiceIntentInfo filter) {
            out.print(prefix);
            out.print(Integer.toHexString(System.identityHashCode(filter.service)));
            out.print(' ');
            filter.service.printComponentShortName(out);
            out.print(" filter ");
            out.print(Integer.toHexString(System.identityHashCode(filter)));
            if (filter.service.info.permission != null) {
                out.print(" permission ");
                out.println(filter.service.info.permission);
                return;
            }
            out.println();
        }

        protected Object filterToLabel(ServiceIntentInfo filter) {
            return filter.service;
        }

        protected void dumpFilterLabel(PrintWriter out, String prefix, Object label, int count) {
            Service service = (Service) label;
            out.print(prefix);
            out.print(Integer.toHexString(System.identityHashCode(service)));
            out.print(' ');
            service.printComponentShortName(out);
            if (count > 1) {
                out.print(" (");
                out.print(count);
                out.print(" filters)");
            }
            out.println();
        }
    }

    static {
        boolean z = Log.HWINFO || (Log.HWModuleLog && Log.isLoggable(TAG, 4));
        HWFLOW = z;
        sBrowserIntent.setAction("android.intent.action.VIEW");
        sBrowserIntent.addCategory("android.intent.category.BROWSABLE");
        sBrowserIntent.setData(Uri.parse("http:"));
        sBrowserIntent.addFlags(512);
        PROTECTED_ACTIONS.add("android.intent.action.SEND");
        PROTECTED_ACTIONS.add("android.intent.action.SENDTO");
        PROTECTED_ACTIONS.add("android.intent.action.SEND_MULTIPLE");
        PROTECTED_ACTIONS.add("android.intent.action.VIEW");
    }

    private static boolean hasValidDomains(ActivityIntentInfo filter) {
        return filter.hasCategory("android.intent.category.BROWSABLE") && (filter.hasDataScheme("http") || filter.hasDataScheme("https"));
    }

    private void handlePackagePostInstall(PackageInstalledInfo res, boolean grantPermissions, boolean killApp, boolean virtualPreload, String[] grantedPermissions, boolean launchedForRestore, String installerPackage, IPackageInstallObserver2 installObserver) {
        PackageInstalledInfo packageInstalledInfo = res;
        IPackageInstallObserver2 iPackageInstallObserver2 = installObserver;
        String str;
        if (packageInstalledInfo.returnCode == 1) {
            String str2;
            String str3;
            int[] iArr;
            String installerPackageName;
            int[] firstUserIds;
            int i;
            String packageName;
            int i2;
            if (packageInstalledInfo.removedInfo != null) {
                packageInstalledInfo.removedInfo.sendPackageRemovedBroadcasts(killApp);
            } else {
                boolean z = killApp;
            }
            if (grantPermissions) {
                this.mPermissionManager.grantRequestedRuntimePermissions(packageInstalledInfo.pkg, packageInstalledInfo.newUsers, grantedPermissions, Binder.getCallingUid(), this.mPermissionCallback);
            }
            boolean z2 = (packageInstalledInfo.removedInfo == null || packageInstalledInfo.removedInfo.removedPackage == null) ? false : true;
            boolean update = z2;
            if (packageInstalledInfo.installerPackageName != null) {
                str2 = packageInstalledInfo.installerPackageName;
            } else if (packageInstalledInfo.removedInfo != null) {
                str2 = packageInstalledInfo.removedInfo.installerPackageName;
            } else {
                str2 = null;
            }
            String installerPackageName2 = str2;
            if (packageInstalledInfo.pkg.parentPackage != null) {
                this.mPermissionManager.grantRuntimePermissionsGrantedToDisabledPackage(packageInstalledInfo.pkg, Binder.getCallingUid(), this.mPermissionCallback);
            }
            synchronized (this.mPackages) {
                try {
                    this.mInstantAppRegistry.onPackageInstalledLPw(packageInstalledInfo.pkg, packageInstalledInfo.newUsers);
                } catch (Throwable th) {
                    str = installerPackage;
                    str3 = installerPackageName2;
                    while (true) {
                    }
                }
            }
            String packageName2 = packageInstalledInfo.pkg.applicationInfo.packageName;
            int[] firstUserIds2 = EMPTY_INT_ARRAY;
            int[] firstInstantUserIds = EMPTY_INT_ARRAY;
            int[] updateUserIds = EMPTY_INT_ARRAY;
            int[] instantUserIds = EMPTY_INT_ARRAY;
            boolean z3 = packageInstalledInfo.origUsers == null || packageInstalledInfo.origUsers.length == 0;
            boolean allNewUsers = z3;
            PackageSetting ps = packageInstalledInfo.pkg.mExtras;
            int[] iArr2 = packageInstalledInfo.newUsers;
            int length = iArr2.length;
            int[] updateUserIds2 = updateUserIds;
            updateUserIds = firstUserIds2;
            int firstUserIds3 = 0;
            int[] iArr3 = instantUserIds;
            instantUserIds = firstInstantUserIds;
            firstInstantUserIds = iArr3;
            while (firstUserIds3 < length) {
                PackageSetting ps2;
                int newUser = iArr2[firstUserIds3];
                boolean isInstantApp = ps.getInstantApp(newUser);
                if (allNewUsers) {
                    if (isInstantApp) {
                        instantUserIds = ArrayUtils.appendInt(instantUserIds, newUser);
                    } else {
                        updateUserIds = ArrayUtils.appendInt(updateUserIds, newUser);
                    }
                    iArr = iArr2;
                    ps2 = ps;
                    installerPackageName = installerPackageName2;
                } else {
                    boolean isNew = true;
                    iArr = iArr2;
                    iArr2 = packageInstalledInfo.origUsers;
                    ps2 = ps;
                    ps = iArr2.length;
                    installerPackageName = installerPackageName2;
                    int installerPackageName3 = 0;
                    while (installerPackageName3 < ps) {
                        PackageSetting packageSetting = ps;
                        if (iArr2[installerPackageName3] == newUser) {
                            isNew = false;
                            break;
                        } else {
                            installerPackageName3++;
                            ps = packageSetting;
                        }
                    }
                    if (isNew) {
                        if (isInstantApp) {
                            instantUserIds = ArrayUtils.appendInt(instantUserIds, newUser);
                        } else {
                            updateUserIds = ArrayUtils.appendInt(updateUserIds, newUser);
                        }
                    } else if (isInstantApp) {
                        firstInstantUserIds = ArrayUtils.appendInt(firstInstantUserIds, newUser);
                    } else {
                        updateUserIds2 = ArrayUtils.appendInt(updateUserIds2, newUser);
                    }
                }
                firstUserIds3++;
                iArr2 = iArr;
                ps = ps2;
                installerPackageName2 = installerPackageName;
            }
            installerPackageName = installerPackageName2;
            setNeedClearDeviceForCTS(true, packageName2);
            try {
                updatePackageBlackListInfo(packageName2);
            } catch (Exception e) {
                Exception exception = e;
                Slog.e(TAG, "update BlackList info failed");
            }
            int[] iArr4;
            if (packageInstalledInfo.pkg.staticSharedLibName == null) {
                String packageName3;
                int[] firstInstantUserIds2;
                String str4;
                StringBuilder stringBuilder;
                this.mProcessLoggingHandler.invalidateProcessLoggingBaseApkHash(packageInstalledInfo.pkg.baseCodePath);
                sendIncompatibleNotificationIfNeeded(packageName2);
                firstUserIds3 = UserHandle.getAppId(packageInstalledInfo.uid);
                z3 = packageInstalledInfo.pkg.applicationInfo.isSystemApp() || virtualPreload;
                iArr = firstInstantUserIds;
                int[] firstUserIds4 = updateUserIds;
                int[] firstInstantUserIds3 = instantUserIds;
                String packageName4 = packageName2;
                str3 = installerPackageName;
                sendPackageAddedForNewUsers(packageName2, z3, virtualPreload, firstUserIds3, firstUserIds4, firstInstantUserIds3);
                Bundle extras = new Bundle(1);
                extras.putInt("android.intent.extra.UID", packageInstalledInfo.uid);
                if (update) {
                    extras.putBoolean("android.intent.extra.REPLACING", true);
                }
                Bundle extras2 = extras;
                int[] firstInstantUserIds4 = firstInstantUserIds3;
                firstUserIds = firstUserIds4;
                i = 0;
                sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName4, extras, 0, null, null, updateUserIds2, iArr);
                if (str3 != null) {
                    sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName4, extras2, 0, str3, null, updateUserIds2, iArr);
                }
                str = packageName4;
                this.mHwPMSEx.updateNochScreenWhite(str, "add", packageInstalledInfo.pkg.applicationInfo.versionCode);
                boolean z4 = (this.mRequiredVerifierPackage == null || this.mRequiredVerifierPackage.equals(str3)) ? false : true;
                boolean notifyVerifier = z4;
                if (notifyVerifier) {
                    packageName3 = str;
                    sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", str, extras2, 0, this.mRequiredVerifierPackage, null, updateUserIds2, iArr);
                } else {
                    packageName3 = str;
                }
                if (update) {
                    sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", packageName3, extras2, 0, null, null, updateUserIds2, iArr);
                    if (str3 != null) {
                        sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", packageName3, extras2, 0, str3, null, updateUserIds2, iArr);
                    }
                    if (notifyVerifier) {
                        sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", packageName3, extras2, 0, this.mRequiredVerifierPackage, null, updateUserIds2, iArr);
                    }
                    sendPackageBroadcast("android.intent.action.MY_PACKAGE_REPLACED", null, null, 0, packageName3, null, updateUserIds2, iArr);
                    str = installerPackage;
                    firstInstantUserIds2 = firstInstantUserIds4;
                    packageName = packageName3;
                } else if (!launchedForRestore || isSystemApp(packageInstalledInfo.pkg)) {
                    str = installerPackage;
                    firstInstantUserIds2 = firstInstantUserIds4;
                    packageName = packageName3;
                } else {
                    if (DEBUG_BACKUP) {
                        str4 = TAG;
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("Post-restore of ");
                        packageName = packageName3;
                        stringBuilder.append(packageName);
                        stringBuilder.append(" sending FIRST_LAUNCH in ");
                        stringBuilder.append(Arrays.toString(firstUserIds));
                        Slog.i(str4, stringBuilder.toString());
                    } else {
                        packageName = packageName3;
                    }
                    firstInstantUserIds2 = firstInstantUserIds4;
                    sendFirstLaunchBroadcast(packageName, installerPackage, firstUserIds, firstInstantUserIds2);
                }
                if (packageInstalledInfo.pkg.isForwardLocked() || isExternal(packageInstalledInfo.pkg)) {
                    if (DEBUG_INSTALL) {
                        str4 = TAG;
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("upgrading pkg ");
                        stringBuilder.append(packageInstalledInfo.pkg);
                        stringBuilder.append(" is ASEC-hosted -> AVAILABLE");
                        Slog.i(str4, stringBuilder.toString());
                    }
                    int[] uidArray = new int[]{packageInstalledInfo.pkg.applicationInfo.uid};
                    ArrayList arrayList = new ArrayList(1);
                    arrayList.add(packageName);
                    ArrayList installerPackageName4 = arrayList;
                    sendResourcesChangedBroadcast(true, true, arrayList, uidArray, null);
                } else {
                    iArr4 = firstInstantUserIds2;
                }
            } else {
                str = installerPackage;
                iArr = firstInstantUserIds;
                firstUserIds = updateUserIds;
                iArr4 = instantUserIds;
                packageName = packageName2;
                str3 = installerPackageName;
                i = 0;
            }
            if (firstUserIds != null && firstUserIds.length > 0) {
                synchronized (this.mPackages) {
                    firstUserIds3 = firstUserIds.length;
                    for (i2 = i; i2 < firstUserIds3; i2++) {
                        int userId = firstUserIds[i2];
                        if (packageIsBrowser(packageName, userId)) {
                            this.mSettings.setDefaultBrowserPackageNameLPw(null, userId);
                        }
                        this.mSettings.applyPendingPermissionGrantsLPw(packageName, userId);
                    }
                }
            }
            if (allNewUsers && !update) {
                notifyPackageAdded(packageName);
            }
            EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED, getUnknownSourcesSettings());
            if (packageInstalledInfo.removedInfo == null || packageInstalledInfo.removedInfo.args == null) {
                VMRuntime.getRuntime().requestConcurrentGC();
            } else {
                Runtime.getRuntime().gc();
                synchronized (this.mInstallLock) {
                    packageInstalledInfo.removedInfo.args.doPostDeleteLI(true);
                }
            }
            firstUserIds3 = firstUserIds.length;
            for (int i3 = i; i3 < firstUserIds3; i3++) {
                i2 = firstUserIds[i3];
                PackageInfo info = getPackageInfo(packageName, i, i2);
                if (info != null) {
                    this.mDexManager.notifyPackageInstalled(info, i2);
                }
            }
        } else {
            str = installerPackage;
        }
        IPackageInstallObserver2 iPackageInstallObserver22 = installObserver;
        if (iPackageInstallObserver22 != null) {
            try {
                iPackageInstallObserver22.onPackageInstalled(packageInstalledInfo.name, packageInstalledInfo.returnCode, packageInstalledInfo.returnMsg, extrasForInstallResult(res));
            } catch (RemoteException e2) {
                Slog.i(TAG, "Observer no longer exists.");
            }
        }
    }

    public void setNeedClearDeviceForCTS(boolean needvalue, String packageName) {
        if (packageName == null) {
            this.mNeedClearDeviceForCTS = false;
        } else if (packageName.equals(PACKAGE_NAME_BASICADMINRECEIVER_CTS_DEIVCEOWNER) || packageName.equals(PACKAGE_NAME_BASICADMINRECEIVER_CTS_DEVICEANDPROFILEOWNER) || packageName.equals(PACKAGE_NAME_BASICADMINRECEIVER_CTS_PACKAGEINSTALLER)) {
            this.mNeedClearDeviceForCTS = needvalue;
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("setmNeedClearDeviceForCTS:");
            stringBuilder.append(this.mNeedClearDeviceForCTS);
            Log.d(str, stringBuilder.toString());
        } else {
            this.mNeedClearDeviceForCTS = false;
        }
    }

    public boolean getNeedClearDeviceForCTS() {
        return this.mNeedClearDeviceForCTS;
    }

    Bundle extrasForInstallResult(PackageInstalledInfo res) {
        int i = res.returnCode;
        Bundle extras;
        if (i != -112) {
            boolean z = true;
            if (i != 1) {
                return null;
            }
            extras = new Bundle();
            String str = "android.intent.extra.REPLACING";
            if (res.removedInfo == null || res.removedInfo.removedPackage == null) {
                z = false;
            }
            extras.putBoolean(str, z);
            return extras;
        }
        extras = new Bundle();
        extras.putString("android.content.pm.extra.FAILURE_EXISTING_PERMISSION", res.origPermission);
        extras.putString("android.content.pm.extra.FAILURE_EXISTING_PACKAGE", res.origPackage);
        return extras;
    }

    void scheduleWriteSettingsLocked() {
        if (!this.mHandler.hasMessages(13)) {
            this.mHandler.sendEmptyMessageDelayed(13, 10000);
        }
    }

    void scheduleWritePackageListLocked(int userId) {
        if (!this.mHandler.hasMessages(19)) {
            Message msg = this.mHandler.obtainMessage(19);
            msg.arg1 = userId;
            this.mHandler.sendMessageDelayed(msg, 10000);
        }
    }

    void scheduleWritePackageRestrictionsLocked(UserHandle user) {
        scheduleWritePackageRestrictionsLocked(user == null ? -1 : user.getIdentifier());
    }

    void scheduleWritePackageRestrictionsLocked(int userId) {
        int i = 0;
        int[] userIds = userId == -1 ? sUserManager.getUserIds() : new int[]{userId};
        int length = userIds.length;
        while (i < length) {
            int nextUserId = userIds[i];
            if (sUserManager.exists(nextUserId)) {
                this.mDirtyUsers.add(Integer.valueOf(nextUserId));
                if (!this.mHandler.hasMessages(14)) {
                    this.mHandler.sendEmptyMessageDelayed(14, 10000);
                }
                i++;
            } else {
                return;
            }
        }
    }

    public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) {
        long startTime = SystemClock.uptimeMillis();
        PackageManagerServiceCompilerMapping.checkProperties();
        PackageManagerService m = HwServiceFactory.getHuaweiPackageManagerService(context, installer, factoryTest, onlyCore);
        m.enableSystemUserPackages();
        ServiceManager.addService("package", m);
        Objects.requireNonNull(m);
        ServiceManager.addService("package_native", new PackageManagerNative(m, null));
        String str = TAG;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("PackageManagerService booting timestamp : ");
        stringBuilder.append(SystemClock.uptimeMillis() - startTime);
        stringBuilder.append(" ms");
        Slog.i(str, stringBuilder.toString());
        return m;
    }

    private void enableSystemUserPackages() {
        if (UserManager.isSplitSystemUser()) {
            AppsQueryHelper queryHelper = new AppsQueryHelper(this);
            Set<String> enableApps = new ArraySet();
            enableApps.addAll(queryHelper.queryApps((AppsQueryHelper.GET_NON_LAUNCHABLE_APPS | AppsQueryHelper.GET_APPS_WITH_INTERACT_ACROSS_USERS_PERM) | AppsQueryHelper.GET_IMES, true, UserHandle.SYSTEM));
            enableApps.addAll(SystemConfig.getInstance().getSystemUserWhitelistedApps());
            int i = false;
            enableApps.addAll(queryHelper.queryApps(AppsQueryHelper.GET_REQUIRED_FOR_SYSTEM_USER, false, UserHandle.SYSTEM));
            enableApps.removeAll(SystemConfig.getInstance().getSystemUserBlacklistedApps());
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Applications installed for system user: ");
            stringBuilder.append(enableApps);
            Log.i(str, stringBuilder.toString());
            List<String> allAps = queryHelper.queryApps(0, false, UserHandle.SYSTEM);
            int allAppsSize = allAps.size();
            synchronized (this.mPackages) {
                int i2 = 0;
                while (i2 < allAppsSize) {
                    try {
                        String pName = (String) allAps.get(i2);
                        PackageSetting pkgSetting = (PackageSetting) this.mSettings.mPackages.get(pName);
                        if (pkgSetting == null) {
                            i2++;
                        } else {
                            boolean install = enableApps.contains(pName);
                            if (pkgSetting.getInstalled(i) != install) {
                                String str2 = TAG;
                                StringBuilder stringBuilder2 = new StringBuilder();
                                stringBuilder2.append(install ? "Installing " : "Uninstalling ");
                                stringBuilder2.append(pName);
                                stringBuilder2.append(" for system user");
                                Log.i(str2, stringBuilder2.toString());
                                pkgSetting.setInstalled(install, i);
                            }
                            i2++;
                        }
                    } finally {
                    }
                }
                scheduleWritePackageRestrictionsLocked(i);
            }
        }
    }

    private static void getDefaultDisplayMetrics(Context context, DisplayMetrics metrics) {
        ((DisplayManager) context.getSystemService("display")).getDisplay(0).getMetrics(metrics);
    }

    private static void requestCopyPreoptedFiles() {
        String CP_PREOPT_PROPERTY = "sys.cppreopt";
        if (SystemProperties.getInt("ro.cp_system_other_odex", 0) == 1) {
            SystemProperties.set("sys.cppreopt", "requested");
            long timeStart = SystemClock.uptimeMillis();
            long timeEnd = 100000 + timeStart;
            long timeNow = timeStart;
            while (!SystemProperties.get("sys.cppreopt").equals("finished")) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                }
                timeNow = SystemClock.uptimeMillis();
                if (timeNow > timeEnd) {
                    SystemProperties.set("sys.cppreopt", "timed-out");
                    Slog.wtf(TAG, "cppreopt did not finish!");
                    break;
                }
            }
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("cppreopts took ");
            stringBuilder.append(timeNow - timeStart);
            stringBuilder.append(" ms");
            Slog.i(str, stringBuilder.toString());
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:520:0x114a A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:515:0x110c A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:527:0x11a1 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:523:0x116a A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:530:0x11c1 A:{LOOP_END, LOOP:14: B:529:0x11bf->B:530:0x11c1, Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:533:0x11fe A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:287:0x097d A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:321:0x0ae0 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:320:0x0adb A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:415:0x0de8 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:329:0x0b0e A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:418:0x0e14 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:438:0x0ee8 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:456:0x0f69 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:455:0x0f67 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:458:0x0f6c A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:461:0x0fa8 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:477:0x0ff6 A:{LOOP_END, LOOP:12: B:475:0x0ff0->B:477:0x0ff6, Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:481:0x100b A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:480:0x1009 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:502:0x108a A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:501:0x1089 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:287:0x097d A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:320:0x0adb A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:321:0x0ae0 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:324:0x0afb A:{SKIP, Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:329:0x0b0e A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:415:0x0de8 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:418:0x0e14 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:438:0x0ee8 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:455:0x0f67 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:456:0x0f69 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:458:0x0f6c A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:461:0x0fa8 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:463:0x0fae A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:477:0x0ff6 A:{LOOP_END, LOOP:12: B:475:0x0ff0->B:477:0x0ff6, Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:480:0x1009 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:481:0x100b A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:484:0x102e A:{SKIP, Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:501:0x1089 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:502:0x108a A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:242:0x0849 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:246:0x0888 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:245:0x0856 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:249:0x088e A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:252:0x089b A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:287:0x097d A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:321:0x0ae0 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:320:0x0adb A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:324:0x0afb A:{SKIP, Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:415:0x0de8 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:329:0x0b0e A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:418:0x0e14 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:438:0x0ee8 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:456:0x0f69 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:455:0x0f67 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:458:0x0f6c A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:461:0x0fa8 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:463:0x0fae A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:477:0x0ff6 A:{LOOP_END, LOOP:12: B:475:0x0ff0->B:477:0x0ff6, Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:481:0x100b A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:480:0x1009 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:484:0x102e A:{SKIP, Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:502:0x108a A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:501:0x1089 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:287:0x097d A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:320:0x0adb A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:321:0x0ae0 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:324:0x0afb A:{SKIP, Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:329:0x0b0e A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:415:0x0de8 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:418:0x0e14 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:438:0x0ee8 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:455:0x0f67 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:456:0x0f69 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:458:0x0f6c A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:461:0x0fa8 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:463:0x0fae A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:477:0x0ff6 A:{LOOP_END, LOOP:12: B:475:0x0ff0->B:477:0x0ff6, Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:480:0x1009 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:481:0x100b A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:484:0x102e A:{SKIP, Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:501:0x1089 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:502:0x108a A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:287:0x097d A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:321:0x0ae0 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:320:0x0adb A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:324:0x0afb A:{SKIP, Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:415:0x0de8 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:329:0x0b0e A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:418:0x0e14 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:438:0x0ee8 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:456:0x0f69 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:455:0x0f67 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:458:0x0f6c A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:461:0x0fa8 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:463:0x0fae A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:477:0x0ff6 A:{LOOP_END, LOOP:12: B:475:0x0ff0->B:477:0x0ff6, Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:481:0x100b A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:480:0x1009 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:484:0x102e A:{SKIP, Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:502:0x108a A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:501:0x1089 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:242:0x0849 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:245:0x0856 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:246:0x0888 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:249:0x088e A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:252:0x089b A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:287:0x097d A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:320:0x0adb A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:321:0x0ae0 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:324:0x0afb A:{SKIP, Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:329:0x0b0e A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:415:0x0de8 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:418:0x0e14 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:438:0x0ee8 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:455:0x0f67 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:456:0x0f69 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:458:0x0f6c A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:461:0x0fa8 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:463:0x0fae A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:477:0x0ff6 A:{LOOP_END, LOOP:12: B:475:0x0ff0->B:477:0x0ff6, Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:480:0x1009 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:481:0x100b A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:484:0x102e A:{SKIP, Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:501:0x1089 A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Removed duplicated region for block: B:502:0x108a A:{Catch:{ PackageManagerException -> 0x0d44, all -> 0x122f }} */
    /* JADX WARNING: Missing block: B:25:0x0285, code skipped:
            r13.mSettings.addSharedUserLPw("android.uid.system", 1000, 1, 8);
            r13.mSettings.addSharedUserLPw("android.uid.phone", 1001, 1, 8);
            r13.mSettings.addSharedUserLPw("android.uid.log", LOG_UID, 1, 8);
            r13.mSettings.addSharedUserLPw("android.uid.nfc", 1027, 1, 8);
            r13.mSettings.addSharedUserLPw("com.nxp.uid.nfceeapi", SPI_UID, 1, 8);
            r13.mSettings.addSharedUserLPw("android.uid.bluetooth", BLUETOOTH_UID, 1, 8);
            r13.mSettings.addSharedUserLPw("android.uid.shell", 2000, 1, 8);
            r13.mSettings.addSharedUserLPw("android.uid.se", SE_UID, 1, 8);
            r13.mSettings.addSharedUserLPw("android.uid.hbs", HBS_UID, 1, 8);
            com.android.server.HwServiceFactory.getHwPackageServiceManager().addHwSharedUserLP(r13.mSettings);
            r12 = android.os.SystemProperties.get("debug.separate_processes");
     */
    /* JADX WARNING: Missing block: B:26:0x02e7, code skipped:
            if (r12 == null) goto L_0x0326;
     */
    /* JADX WARNING: Missing block: B:28:0x02ed, code skipped:
            if (r12.length() <= 0) goto L_0x0326;
     */
    /* JADX WARNING: Missing block: B:30:0x02f5, code skipped:
            if ("*".equals(r12) == false) goto L_0x0304;
     */
    /* JADX WARNING: Missing block: B:31:0x02f7, code skipped:
            r13.mDefParseFlags = 2;
            r13.mSeparateProcesses = null;
            android.util.Slog.w(TAG, "Running with debug.separate_processes: * (ALL)");
     */
    /* JADX WARNING: Missing block: B:32:0x0304, code skipped:
            r13.mDefParseFlags = 0;
            r13.mSeparateProcesses = r12.split(",");
            r0 = TAG;
            r1 = new java.lang.StringBuilder();
            r1.append("Running with debug.separate_processes: ");
            r1.append(r12);
            android.util.Slog.w(r0, r1.toString());
     */
    /* JADX WARNING: Missing block: B:33:0x0326, code skipped:
            r13.mDefParseFlags = 0;
            r13.mSeparateProcesses = null;
     */
    /* JADX WARNING: Missing block: B:34:0x032b, code skipped:
            r13.mPackageDexOptimizer = new com.android.server.pm.PackageDexOptimizer(r15, r13.mInstallLock, r14, "*dexopt*");
            r24 = null;
            r8 = true;
            r13.mDexManager = new com.android.server.pm.dex.DexManager(r13.mContext, r13, r13.mPackageDexOptimizer, r15, r13.mInstallLock, com.android.server.pm.dex.DexLogger.getListener(r13, r15, r13.mInstallLock));
            r13.mArtManagerService = new com.android.server.pm.dex.ArtManagerService(r13.mContext, r13, r15, r13.mInstallLock);
            r13.mMoveCallbacks = new com.android.server.pm.PackageManagerService.MoveCallbacks(com.android.server.FgThread.get().getLooper());
            r13.mOnPermissionChangeListeners = new com.android.server.pm.PackageManagerService.OnPermissionChangeListeners(com.android.server.FgThread.get().getLooper());
            getDefaultDisplayMetrics(r14, r13.mMetrics);
            android.os.Trace.traceBegin(262144, "get system config");
            r7 = com.android.server.SystemConfig.getInstance();
            r13.mAvailableFeatures = r7.getAvailableFeatures();
            android.os.Trace.traceEnd(262144);
            r13.mProtectedPackages = new com.android.server.pm.ProtectedPackages(r13.mContext);
     */
    /* JADX WARNING: Missing block: B:35:0x03a1, code skipped:
            if (HWFLOW == false) goto L_0x03d2;
     */
    /* JADX WARNING: Missing block: B:36:0x03a3, code skipped:
            r0 = TAG;
            r1 = new java.lang.StringBuilder();
            r1.append("TimerCounter = ");
            r2 = r13.mTimerCounter + r8;
            r13.mTimerCounter = r2;
            r1.append(r2);
            r1.append(" **** Config Init  ************ Time to elapsed: ");
            r1.append(android.os.SystemClock.uptimeMillis() - r13.mStartTimer);
            r1.append(" ms");
            android.util.Slog.i(r0, r1.toString());
     */
    /* JADX WARNING: Missing block: B:37:0x03d2, code skipped:
            r5 = r13.mInstallLock;
     */
    /* JADX WARNING: Missing block: B:38:0x03d4, code skipped:
            monitor-enter(r5);
     */
    /* JADX WARNING: Missing block: B:40:?, code skipped:
            r6 = r13.mPackages;
     */
    /* JADX WARNING: Missing block: B:41:0x03d7, code skipped:
            monitor-enter(r6);
     */
    /* JADX WARNING: Missing block: B:43:?, code skipped:
            r13.mHandlerThread = new com.android.server.ServiceThread(TAG, 10, r8);
            r13.mHandlerThread.start();
            r13.mHandler = new com.android.server.pm.PackageManagerService.PackageHandler(r13, r13.mHandlerThread.getLooper());
            r13.mProcessLoggingHandler = new com.android.server.pm.ProcessLoggingHandler();
            com.android.server.Watchdog.getInstance().addThread(r13.mHandler, WATCHDOG_TIMEOUT);
            r13.mInstantAppRegistry = new com.android.server.pm.InstantAppRegistry(r13);
            r3 = r7.getSharedLibraries();
     */
    /* JADX WARNING: Missing block: B:44:0x0417, code skipped:
            r1 = r3.size();
            r0 = 0;
     */
    /* JADX WARNING: Missing block: B:45:0x0419, code skipped:
            if (r0 >= r1) goto L_0x0476;
     */
    /* JADX WARNING: Missing block: B:48:0x0430, code skipped:
            r29 = r1;
            r30 = r3;
            r16 = r5;
            r31 = r6;
            r17 = r7;
            r32 = r12;
            r12 = r8;
     */
    /* JADX WARNING: Missing block: B:50:?, code skipped:
            addSharedLibraryLPw((java.lang.String) r3.valueAt(r0), null, (java.lang.String) r3.keyAt(r0), -1, 0, PLATFORM_PACKAGE_NAME, 0);
     */
    /* JADX WARNING: Missing block: B:51:0x044f, code skipped:
            r0 = r0 + 1;
            r8 = r12;
            r5 = r16;
            r7 = r17;
            r1 = r29;
            r3 = r30;
            r6 = r31;
            r12 = r32;
     */
    /* JADX WARNING: Missing block: B:52:0x0462, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:53:0x0463, code skipped:
            r36 = r32;
            r32 = r11;
     */
    /* JADX WARNING: Missing block: B:54:0x0469, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:55:0x046a, code skipped:
            r16 = r5;
            r31 = r6;
            r17 = r7;
            r32 = r11;
            r36 = r12;
     */
    /* JADX WARNING: Missing block: B:56:0x0476, code skipped:
            r29 = r1;
            r30 = r3;
            r16 = r5;
            r31 = r6;
            r17 = r7;
            r32 = r12;
            r12 = r8;
     */
    /* JADX WARNING: Missing block: B:58:?, code skipped:
            com.android.server.pm.SELinuxMMAC.readInstallPolicy();
            r13.mHwPMSEx.initHwCertificationManager();
            android.os.Trace.traceBegin(262144, "loadFallbacks");
            android.content.pm.FallbackCategoryProvider.loadFallbacks();
            android.os.Trace.traceEnd(262144);
     */
    /* JADX WARNING: Missing block: B:59:0x049e, code skipped:
            if (HWFLOW == false) goto L_0x04a6;
     */
    /* JADX WARNING: Missing block: B:61:?, code skipped:
            r13.mStartTimer = android.os.SystemClock.uptimeMillis();
     */
    /* JADX WARNING: Missing block: B:63:?, code skipped:
            android.os.Trace.traceBegin(262144, "read user settings");
            r13.mFirstBoot = r13.mSettings.readLPw(sUserManager.getUsers(false)) ^ r12;
            android.os.Trace.traceEnd(262144);
            r20 = false;
     */
    /* JADX WARNING: Missing block: B:64:0x04c3, code skipped:
            if (HWFLOW == false) goto L_0x04f4;
     */
    /* JADX WARNING: Missing block: B:66:?, code skipped:
            r0 = TAG;
            r1 = new java.lang.StringBuilder();
            r1.append("TimerCounter = ");
            r2 = r13.mTimerCounter + r12;
            r13.mTimerCounter = r2;
            r1.append(r2);
            r1.append(" **** mSettings.readLPw  ************ Time to elapsed: ");
            r1.append(android.os.SystemClock.uptimeMillis() - r13.mStartTimer);
            r1.append(" ms");
            android.util.Slog.i(r0, r1.toString());
     */
    /* JADX WARNING: Missing block: B:69:0x04fc, code skipped:
            if (r13.mSettings.mDisabledSysPackages.size() <= 0) goto L_0x0541;
     */
    /* JADX WARNING: Missing block: B:71:?, code skipped:
            r1 = r13.mSettings.mPackages.size() - 1;
     */
    /* JADX WARNING: Missing block: B:72:0x0508, code skipped:
            if (r1 < 0) goto L_0x0541;
     */
    /* JADX WARNING: Missing block: B:73:0x050a, code skipped:
            r2 = (com.android.server.pm.PackageSetting) r13.mSettings.mPackages.valueAt(r1);
     */
    /* JADX WARNING: Missing block: B:74:0x0518, code skipped:
            if (isExternal(r2) != false) goto L_0x053e;
     */
    /* JADX WARNING: Missing block: B:76:0x051c, code skipped:
            if (r2.codePath == null) goto L_0x0526;
     */
    /* JADX WARNING: Missing block: B:78:0x0524, code skipped:
            if (r2.codePath.exists() != false) goto L_0x053e;
     */
    /* JADX WARNING: Missing block: B:80:0x052e, code skipped:
            if (r13.mSettings.getDisabledSystemPkgLPr(r2.name) == null) goto L_0x053e;
     */
    /* JADX WARNING: Missing block: B:81:0x0530, code skipped:
            r13.mSettings.mPackages.removeAt(r1);
            r13.mSettings.enableSystemPackageLPw(r2.name);
     */
    /* JADX WARNING: Missing block: B:82:0x053e, code skipped:
            r1 = r1 - 1;
     */
    /* JADX WARNING: Missing block: B:85:0x0543, code skipped:
            if (r13.mFirstBoot == false) goto L_0x0548;
     */
    /* JADX WARNING: Missing block: B:87:?, code skipped:
            requestCopyPreoptedFiles();
     */
    /* JADX WARNING: Missing block: B:89:?, code skipped:
            r0 = android.content.res.Resources.getSystem().getString(17039776);
            r0 = android.common.HwFrameworkFactory.getHuaweiResolverActivity(r13.mContext);
     */
    /* JADX WARNING: Missing block: B:90:0x055e, code skipped:
            if (android.text.TextUtils.isEmpty(r0) == false) goto L_0x0564;
     */
    /* JADX WARNING: Missing block: B:91:0x0560, code skipped:
            r0 = null;
     */
    /* JADX WARNING: Missing block: B:92:0x0561, code skipped:
            r21 = r0;
     */
    /* JADX WARNING: Missing block: B:93:0x0564, code skipped:
            r13.mCustomResolverComponentName = android.content.ComponentName.unflattenFromString(r0);
     */
    /* JADX WARNING: Missing block: B:94:0x056b, code skipped:
            r5 = android.os.SystemClock.uptimeMillis();
            android.util.EventLog.writeEvent(com.android.server.EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START, r5);
            r22 = java.lang.System.getenv("BOOTCLASSPATH");
     */
    /* JADX WARNING: Missing block: B:95:0x0583, code skipped:
            r25 = java.lang.System.getenv("SYSTEMSERVERCLASSPATH");
     */
    /* JADX WARNING: Missing block: B:96:0x0585, code skipped:
            if (r22 != null) goto L_0x058e;
     */
    /* JADX WARNING: Missing block: B:98:?, code skipped:
            android.util.Slog.w(TAG, "No BOOTCLASSPATH found!");
     */
    /* JADX WARNING: Missing block: B:99:0x058e, code skipped:
            if (r25 != null) goto L_0x0597;
     */
    /* JADX WARNING: Missing block: B:100:0x0590, code skipped:
            android.util.Slog.w(TAG, "No SYSTEMSERVERCLASSPATH found!");
     */
    /* JADX WARNING: Missing block: B:102:?, code skipped:
            r8 = new java.io.File(android.os.Environment.getRootDirectory(), "framework");
     */
    /* JADX WARNING: Missing block: B:103:0x05a8, code skipped:
            r4 = r13.mSettings.getInternalVersion();
     */
    /* JADX WARNING: Missing block: B:104:0x05a9, code skipped:
            if (r4 == null) goto L_0x05c1;
     */
    /* JADX WARNING: Missing block: B:107:0x05b3, code skipped:
            if (android.os.Build.FINGERPRINT.equals(r4.fingerprint) == false) goto L_0x05bf;
     */
    /* JADX WARNING: Missing block: B:109:0x05bd, code skipped:
            if (android.os.Build.HWFINGERPRINT.equals(r4.hwFingerprint) != false) goto L_0x05c1;
     */
    /* JADX WARNING: Missing block: B:110:0x05bf, code skipped:
            r0 = r12;
     */
    /* JADX WARNING: Missing block: B:111:0x05c1, code skipped:
            r0 = false;
     */
    /* JADX WARNING: Missing block: B:113:?, code skipped:
            r13.mIsUpgrade = r0;
     */
    /* JADX WARNING: Missing block: B:114:0x05c6, code skipped:
            r3 = 4;
     */
    /* JADX WARNING: Missing block: B:115:0x05c7, code skipped:
            if (r13.mIsUpgrade == false) goto L_0x05fd;
     */
    /* JADX WARNING: Missing block: B:117:?, code skipped:
            r0 = new java.lang.StringBuilder();
            r0.append("FINGERPRINT Upgrading from ");
            r0.append(r4.fingerprint);
            r0.append(" to ");
            r0.append(android.os.Build.FINGERPRINT);
            r0.append(" and HWFINGERPRINT Upgrading from ");
            r0.append(r4.hwFingerprint);
            r0.append(" to ");
            r0.append(android.os.Build.HWFINGERPRINT);
            com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(4, r0.toString());
     */
    /* JADX WARNING: Missing block: B:119:?, code skipped:
            loadCorrectUninstallDelapp();
     */
    /* JADX WARNING: Missing block: B:120:0x0602, code skipped:
            if (HWFLOW == false) goto L_0x060a;
     */
    /* JADX WARNING: Missing block: B:122:?, code skipped:
            r13.mStartTimer = android.os.SystemClock.uptimeMillis();
     */
    /* JADX WARNING: Missing block: B:124:?, code skipped:
            loadSysWhitelist();
     */
    /* JADX WARNING: Missing block: B:125:0x060f, code skipped:
            if (HWFLOW == false) goto L_0x0641;
     */
    /* JADX WARNING: Missing block: B:127:?, code skipped:
            r0 = TAG;
            r1 = new java.lang.StringBuilder();
            r1.append("TimerCounter = ");
            r2 = r13.mTimerCounter + r12;
            r13.mTimerCounter = r2;
            r1.append(r2);
            r1.append(" **** loadSysWhitelist  ************ Time to elapsed: ");
            r1.append(android.os.SystemClock.uptimeMillis() - r13.mStartTimer);
            r1.append(" ms");
            android.util.Slog.i(r0, r1.toString());
     */
    /* JADX WARNING: Missing block: B:129:?, code skipped:
            r13.mHwPMSEx.readPersistentConfig();
            initCertCompatSettings();
            resetSharedUserSignaturesIfNeeded();
     */
    /* JADX WARNING: Missing block: B:130:0x064e, code skipped:
            if (r13.mIsUpgrade == false) goto L_0x0655;
     */
    /* JADX WARNING: Missing block: B:131:0x0650, code skipped:
            if (r11 != false) goto L_0x0655;
     */
    /* JADX WARNING: Missing block: B:133:?, code skipped:
            deletePackagesAbiFile();
     */
    /* JADX WARNING: Missing block: B:136:0x0657, code skipped:
            if (r13.mIsUpgrade == false) goto L_0x0661;
     */
    /* JADX WARNING: Missing block: B:140:0x065d, code skipped:
            if (r4.sdkVersion > 22) goto L_0x0661;
     */
    /* JADX WARNING: Missing block: B:141:0x065f, code skipped:
            r0 = r12;
     */
    /* JADX WARNING: Missing block: B:142:0x0661, code skipped:
            r0 = false;
     */
    /* JADX WARNING: Missing block: B:144:?, code skipped:
            r13.mPromoteSystemApps = r0;
     */
    /* JADX WARNING: Missing block: B:145:0x0666, code skipped:
            if (r13.mIsUpgrade == false) goto L_0x0670;
     */
    /* JADX WARNING: Missing block: B:149:0x066c, code skipped:
            if (r4.sdkVersion >= 24) goto L_0x0670;
     */
    /* JADX WARNING: Missing block: B:150:0x066e, code skipped:
            r0 = r12;
     */
    /* JADX WARNING: Missing block: B:151:0x0670, code skipped:
            r0 = false;
     */
    /* JADX WARNING: Missing block: B:153:?, code skipped:
            r13.mIsPreNUpgrade = r0;
     */
    /* JADX WARNING: Missing block: B:154:0x0675, code skipped:
            if (r13.mIsUpgrade == false) goto L_0x067f;
     */
    /* JADX WARNING: Missing block: B:158:0x067b, code skipped:
            if (r4.sdkVersion >= 25) goto L_0x067f;
     */
    /* JADX WARNING: Missing block: B:159:0x067d, code skipped:
            r0 = r12;
     */
    /* JADX WARNING: Missing block: B:160:0x067f, code skipped:
            r0 = false;
     */
    /* JADX WARNING: Missing block: B:162:?, code skipped:
            r13.mIsPreNMR1Upgrade = r0;
     */
    /* JADX WARNING: Missing block: B:163:0x0684, code skipped:
            if (r13.mIsUpgrade == false) goto L_0x068e;
     */
    /* JADX WARNING: Missing block: B:167:0x068a, code skipped:
            if (r4.sdkVersion >= 28) goto L_0x068e;
     */
    /* JADX WARNING: Missing block: B:168:0x068c, code skipped:
            r0 = r12;
     */
    /* JADX WARNING: Missing block: B:169:0x068e, code skipped:
            r0 = false;
     */
    /* JADX WARNING: Missing block: B:171:?, code skipped:
            r13.mIsPrePUpgrade = r0;
     */
    /* JADX WARNING: Missing block: B:172:0x0693, code skipped:
            if (r13.mPromoteSystemApps == false) goto L_0x06bb;
     */
    /* JADX WARNING: Missing block: B:174:?, code skipped:
            r0 = r13.mSettings.mPackages.values().iterator();
     */
    /* JADX WARNING: Missing block: B:176:0x06a5, code skipped:
            if (r0.hasNext() == false) goto L_0x06bb;
     */
    /* JADX WARNING: Missing block: B:177:0x06a7, code skipped:
            r1 = (com.android.server.pm.PackageSetting) r0.next();
     */
    /* JADX WARNING: Missing block: B:178:0x06b1, code skipped:
            if (isSystemApp(r1) == false) goto L_0x06ba;
     */
    /* JADX WARNING: Missing block: B:179:0x06b3, code skipped:
            r13.mExistingSystemPackages.add(r1.name);
     */
    /* JADX WARNING: Missing block: B:182:?, code skipped:
            r13.mCacheDir = preparePackageParserCache(r13.mIsUpgrade);
            r0 = 528;
     */
    /* JADX WARNING: Missing block: B:183:0x06c7, code skipped:
            if (r13.mIsUpgrade != false) goto L_0x06cd;
     */
    /* JADX WARNING: Missing block: B:186:0x06cb, code skipped:
            if (r13.mFirstBoot == false) goto L_0x06cf;
     */
    /* JADX WARNING: Missing block: B:187:0x06cd, code skipped:
            r0 = 528 | 8192;
     */
    /* JADX WARNING: Missing block: B:188:0x06cf, code skipped:
            r10 = r0;
     */
    /* JADX WARNING: Missing block: B:190:?, code skipped:
            readPreInstallApkList();
     */
    /* JADX WARNING: Missing block: B:191:0x06d3, code skipped:
            r1 = r24;
     */
    /* JADX WARNING: Missing block: B:194:0x06db, code skipped:
            r1 = huawei.cust.HwCfgFilePolicy.getCfgFileList("/overlay", r12);
     */
    /* JADX WARNING: Missing block: B:196:0x06df, code skipped:
            r0 = move-exception;
     */
    /* JADX WARNING: Missing block: B:198:?, code skipped:
            android.util.Slog.e(TAG, r0.getMessage());
     */
    /* JADX WARNING: Missing block: B:539:0x121c, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:540:0x121d, code skipped:
            r36 = r32;
            r32 = r11;
     */
    /* JADX WARNING: Missing block: B:541:0x1222, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:542:0x1223, code skipped:
            r16 = r5;
            r31 = r6;
            r17 = r7;
            r32 = r11;
            r36 = r12;
     */
    /* JADX WARNING: Missing block: B:549:0x1231, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:550:0x1232, code skipped:
            r16 = r5;
            r17 = r7;
            r32 = r11;
            r36 = r12;
     */
    /* JADX WARNING: Missing block: B:551:0x123a, code skipped:
            monitor-exit(r16);
     */
    /* JADX WARNING: Missing block: B:552:0x123b, code skipped:
            throw r0;
     */
    /* JADX WARNING: Missing block: B:553:0x123c, code skipped:
            r0 = th;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public PackageManagerService(Context context, Installer installer, boolean factoryTest, boolean onlyCore) {
        String str;
        StringBuilder stringBuilder;
        Throwable e;
        boolean z;
        String str2;
        Context context2 = context;
        Installer installer2 = installer;
        boolean z2 = onlyCore;
        this.mHwPMSEx = HwServiceExFactory.getHwPackageManagerServiceEx(this, context);
        LockGuard.installLock(this.mPackages, 3);
        Trace.traceBegin(262144, "create package manager");
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START, SystemClock.uptimeMillis());
        Jlog.d(31, "JL_BOOT_PROGRESS_PMS_START");
        if (this.mSdkVersion <= 0) {
            Slog.w(TAG, "**** ro.build.version.sdk not set!");
        }
        this.mContext = context2;
        this.mPermissionReviewRequired = context.getResources().getBoolean(17957000);
        if (HWFLOW) {
            this.mStartTimer = SystemClock.uptimeMillis();
        }
        this.mFactoryTest = factoryTest;
        this.mOnlyCore = z2;
        this.mMetrics = new DisplayMetrics();
        this.mInstaller = installer2;
        synchronized (this.mInstallLock) {
            try {
                synchronized (this.mPackages) {
                    try {
                        LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl(this, null));
                        Slog.i(TAG, "UserManagerService");
                        IHwUserManagerService service = HwServiceFactory.getHwUserManagerService();
                        if (service != null) {
                            sUserManager = service.getInstance(context2, this, new UserDataPreparer(this.mInstaller, this.mInstallLock, this.mContext, this.mOnlyCore), this.mPackages);
                        } else {
                            sUserManager = new UserManagerService(context2, this, new UserDataPreparer(this.mInstaller, this.mInstallLock, this.mContext, this.mOnlyCore), this.mPackages);
                        }
                    } catch (Throwable th) {
                        z = z2;
                        while (true) {
                            try {
                            } catch (Throwable th2) {
                                e = th2;
                                throw e;
                            }
                        }
                    }
                    this.mPermissionManager = PermissionManagerService.create(context2, new DefaultPermissionGrantedCallback() {
                        public void onDefaultRuntimePermissionsGranted(int userId) {
                            synchronized (PackageManagerService.this.mPackages) {
                                PackageManagerService.this.mSettings.onDefaultRuntimePermissionsGrantedLPr(userId);
                            }
                        }
                    }, this.mPackages);
                    this.mDefaultPermissionPolicy = this.mPermissionManager.getDefaultPermissionGrantPolicy();
                    str2 = TAG;
                    StringBuilder stringBuilder2 = new StringBuilder();
                    stringBuilder2.append("mDefaultPermissionPolicy :");
                    stringBuilder2.append(this.mDefaultPermissionPolicy);
                    Slog.i(str2, stringBuilder2.toString());
                    this.mSettings = new Settings(this.mPermissionManager.getPermissionSettings(), this.mPackages);
                }
            } catch (Throwable th3) {
                e = th3;
                z = z2;
                throw e;
            }
        }
        File privilegedOdmAppDir;
        File privilegedOdmAppDir2;
        File vendorAppDir;
        File vendorAppDir2;
        int scanFlags;
        File odmAppDir;
        File odmAppDir2;
        File oemAppDir;
        File productAppDir;
        List<String> possiblyDeletedUpdatedSystemApps;
        List<String> stubSystemApps;
        List<String> stubSystemApps2;
        File file;
        File file2;
        String separateProcesses;
        long systemScanTime;
        long startTime;
        int systemPackagesCount;
        StringBuilder stringBuilder3;
        long j;
        AnonymousClass1 anonymousClass1;
        File frameworkDir;
        File file3;
        File file4;
        File file5;
        List<String> list;
        int i;
        List<String> possiblyDeletedUpdatedSystemApps2;
        Iterator it;
        int i2;
        int scanFlags2;
        File privilegedAppDir;
        int rescanFlags;
        File systemAppDir;
        File privilegedVendorAppDir;
        int rescanFlags2;
        int rescanFlags3;
        VersionInfo ver;
        VersionInfo ver2;
        boolean sdkUpdated;
        int storageFlags;
        List<String> deferPackages;
        int i3;
        boolean z3;
        String deletedAppName;
        try {
            StringBuilder stringBuilder4;
            PackageSetting disabledPs;
            boolean settingsDirty;
            List<String> possiblyDeletedUpdatedSystemApps3;
            String str3;
            Pair<ComponentName, String> instantAppResolverComponent;
            Map<Integer, List<PackageInfo>> userPackages;
            int[] currentUserIds;
            SystemConfig systemConfig;
            List<String> deferPackages2;
            Pair<ComponentName, String> instantAppResolverComponent2;
            privilegedOdmAppDir = privilegedOdmAppDir2;
            vendorAppDir = vendorAppDir2;
            scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, ((scanFlags | 131072) | 1048576) | 262144, 0);
            odmAppDir = new File(Environment.getOdmDirectory(), "app");
            try {
                privilegedOdmAppDir2 = odmAppDir.getCanonicalFile();
            } catch (IOException e2) {
                privilegedOdmAppDir2 = odmAppDir;
            }
            odmAppDir2 = privilegedOdmAppDir2;
            scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, (scanFlags | 131072) | 1048576, 0);
            privilegedOdmAppDir2 = new File(Environment.getOemDirectory(), "app");
            oemAppDir = privilegedOdmAppDir2;
            scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, (scanFlags | 131072) | 524288, 0);
            odmAppDir = new File(Environment.getProductDirectory(), "priv-app");
            try {
                odmAppDir = odmAppDir.getCanonicalFile();
            } catch (IOException e3) {
            }
            privilegedOdmAppDir2 = odmAppDir;
            odmAppDir = new File(Environment.getProductDirectory(), "app");
            try {
                odmAppDir = odmAppDir.getCanonicalFile();
            } catch (IOException e4) {
            }
            productAppDir = odmAppDir;
            possiblyDeletedUpdatedSystemApps = new ArrayList();
            stubSystemApps = new ArrayList();
            if (!this.mOnlyCore) {
                Iterator<Package> pkgIterator = this.mPackages.values().iterator();
                while (pkgIterator.hasNext()) {
                    Package pkg = (Package) pkgIterator.next();
                    if (pkg.isStub) {
                        stubSystemApps.add(pkg.packageName);
                    }
                }
                Iterator<PackageSetting> psit = this.mSettings.mPackages.values().iterator();
                while (psit.hasNext()) {
                    Iterator<Package> pkgIterator2;
                    PackageSetting ps = (PackageSetting) psit.next();
                    if ((ps.pkgFlags & 1) == 0) {
                        pkgIterator2 = pkgIterator;
                        stubSystemApps2 = stubSystemApps;
                        file = privilegedOdmAppDir2;
                        file2 = productAppDir;
                    } else {
                        pkgIterator2 = pkgIterator;
                        Package scannedPkg = (Package) this.mPackages.get(ps.name);
                        if (scannedPkg != null) {
                            stubSystemApps2 = stubSystemApps;
                            if (this.mSettings.isDisabledSystemPackageLPr(ps.name)) {
                                stringBuilder4 = new StringBuilder();
                                stringBuilder4.append("Expecting better updated system app for ");
                                stringBuilder4.append(ps.name);
                                stringBuilder4.append("; removing system app.  Last known codePath=");
                                stringBuilder4.append(ps.codePathString);
                                stringBuilder4.append(", versionCode=");
                                file = privilegedOdmAppDir2;
                                file2 = productAppDir;
                                stringBuilder4.append(ps.versionCode);
                                stringBuilder4.append("; scanned versionCode=");
                                stringBuilder4.append(scannedPkg.getLongVersionCode());
                                PackageManagerServiceUtils.logCriticalInfo(5, stringBuilder4.toString());
                                removePackageLI(scannedPkg, true);
                                this.mExpectingBetter.put(ps.name, ps.codePath);
                            } else {
                                file = privilegedOdmAppDir2;
                                file2 = productAppDir;
                            }
                        } else {
                            stubSystemApps2 = stubSystemApps;
                            file = privilegedOdmAppDir2;
                            file2 = productAppDir;
                            if (this.mSettings.isDisabledSystemPackageLPr(ps.name)) {
                                disabledPs = this.mSettings.getDisabledSystemPkgLPr(ps.name);
                                if (disabledPs.codePath == null || !disabledPs.codePath.exists() || disabledPs.pkg == null) {
                                    possiblyDeletedUpdatedSystemApps.add(ps.name);
                                }
                            } else {
                                psit.remove();
                                settingsDirty = true;
                                stringBuilder4 = new StringBuilder();
                                stringBuilder4.append("System package ");
                                stringBuilder4.append(ps.name);
                                stringBuilder4.append(" no longer exists; it's data will be wiped");
                                PackageManagerServiceUtils.logCriticalInfo(5, stringBuilder4.toString());
                                writeNetQinFlag(ps.name);
                            }
                            pkgIterator = pkgIterator2;
                            stubSystemApps = stubSystemApps2;
                            privilegedOdmAppDir2 = file;
                            productAppDir = file2;
                        }
                    }
                    pkgIterator = pkgIterator2;
                    stubSystemApps = stubSystemApps2;
                    privilegedOdmAppDir2 = file;
                    productAppDir = file2;
                }
            }
            stubSystemApps2 = stubSystemApps;
            file = privilegedOdmAppDir2;
            file2 = productAppDir;
            deleteTempPackageFiles();
            separateProcesses = PackageParser.sCachedPackageReadCount.get();
            this.mSettings.pruneSharedUsersLPw();
            systemScanTime = SystemClock.uptimeMillis() - startTime;
            systemPackagesCount = this.mPackages.size();
            str2 = TAG;
            stringBuilder3 = new StringBuilder();
            stringBuilder3.append("Finished scanning system apps. Time: ");
            stringBuilder3.append(systemScanTime);
            stringBuilder3.append(" ms, packageCount: ");
            stringBuilder3.append(systemPackagesCount);
            stringBuilder3.append(" , timePerPackage: ");
            if (systemPackagesCount == 0) {
                possiblyDeletedUpdatedSystemApps3 = possiblyDeletedUpdatedSystemApps;
                j = 0;
            } else {
                possiblyDeletedUpdatedSystemApps3 = possiblyDeletedUpdatedSystemApps;
                j = systemScanTime / ((long) systemPackagesCount);
            }
            stringBuilder3.append(j);
            stringBuilder3.append(" , cached: ");
            stringBuilder3.append(separateProcesses);
            Slog.i(str2, stringBuilder3.toString());
            if (this.mIsUpgrade || systemPackagesCount <= 0) {
                anonymousClass1 = r24;
            } else {
                MetricsLogger.histogram(r24, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
            }
            int i4;
            List<String> list2;
            File file6;
            if (this.mOnlyCore) {
                i4 = systemPackagesCount;
                File file7 = frameworkDir;
                file3 = vendorAppDir;
                file4 = privilegedOdmAppDir;
                list2 = stubSystemApps2;
                file5 = file;
                file6 = file2;
                list = possiblyDeletedUpdatedSystemApps3;
            } else {
                long j2;
                int systemPackagesCount2 = systemPackagesCount;
                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START, SystemClock.uptimeMillis());
                boolean isPackageSettingsError = this.mSettings.isPackageSettingsError();
                long systemScanTime2 = systemScanTime;
                List<String> stubSystemApps3 = stubSystemApps2;
                List<String> possiblyDeletedUpdatedSystemApps4 = possiblyDeletedUpdatedSystemApps3;
                i = 5;
                frameworkDir = file;
                file6 = file2;
                i4 = systemPackagesCount2;
                scanDirTracedLI(sAppInstallDir, 0, isPackageSettingsError ? scanFlags : scanFlags | 128, 0);
                scanDirTracedLI(sDrmAppPrivateInstallDir, this.mDefParseFlags | 4, isPackageSettingsError ? scanFlags : scanFlags | 128, 0);
                if (isPackageSettingsError) {
                    Settings.resetPackageSettingsError();
                    Slog.w(TAG, "Booting after package manager settings file broken, scanFlags was changed for scanning non-system apps!");
                }
                possiblyDeletedUpdatedSystemApps2 = possiblyDeletedUpdatedSystemApps4;
                for (String deletedAppName2 : possiblyDeletedUpdatedSystemApps2) {
                    String msg;
                    Package systemScanTime3 = (Package) this.mPackages.get(deletedAppName2);
                    this.mSettings.removeDisabledSystemPackageLPw(deletedAppName2);
                    if (systemScanTime3 == null) {
                        msg = new StringBuilder();
                        msg.append("Updated system package ");
                        msg.append(deletedAppName2);
                        msg.append(" no longer exists; removing its data");
                        msg = msg.toString();
                    } else {
                        stringBuilder4 = new StringBuilder();
                        stringBuilder4.append("Updated system package + ");
                        stringBuilder4.append(deletedAppName2);
                        stringBuilder4.append(" no longer exists; revoking system privileges");
                        msg = stringBuilder4.toString();
                        PackageSetting deletedPs = (PackageSetting) this.mSettings.mPackages.get(deletedAppName2);
                        ApplicationInfo applicationInfo = systemScanTime3.applicationInfo;
                        applicationInfo.flags &= -2;
                        deletedPs.pkgFlags &= -2;
                    }
                    PackageManagerServiceUtils.logCriticalInfo(5, msg);
                }
                i2 = 0;
                while (true) {
                    i = i2;
                    if (i >= this.mExpectingBetter.size()) {
                        break;
                    }
                    String packageName = (String) this.mExpectingBetter.keyAt(i);
                    if (this.mPackages.containsKey(packageName)) {
                        list = possiblyDeletedUpdatedSystemApps2;
                        file5 = frameworkDir;
                        file3 = vendorAppDir;
                        file4 = privilegedOdmAppDir;
                        scanFlags2 = scanFlags;
                    } else {
                        List<String> possiblyDeletedUpdatedSystemApps5;
                        File vendorAppDir3;
                        File privilegedOdmAppDir3;
                        File odmAppDir3;
                        File systemScanTime4 = (File) this.mExpectingBetter.valueAt(i);
                        StringBuilder stringBuilder5 = new StringBuilder();
                        stringBuilder5.append("Expected better ");
                        stringBuilder5.append(packageName);
                        stringBuilder5.append(" but never showed up; reverting to system");
                        PackageManagerServiceUtils.logCriticalInfo(5, stringBuilder5.toString());
                        if (FileUtils.contains(privilegedAppDir, systemScanTime4)) {
                            i2 = this.mDefParseFlags | 16;
                            rescanFlags = (scanFlags | 131072) | 262144;
                        } else if (FileUtils.contains(systemAppDir, systemScanTime4)) {
                            i2 = this.mDefParseFlags | 16;
                            rescanFlags = scanFlags | 131072;
                        } else {
                            int rescanFlags4;
                            if (FileUtils.contains(privilegedVendorAppDir, systemScanTime4)) {
                                possiblyDeletedUpdatedSystemApps5 = possiblyDeletedUpdatedSystemApps2;
                                vendorAppDir3 = vendorAppDir;
                                privilegedOdmAppDir3 = privilegedOdmAppDir;
                                odmAppDir3 = odmAppDir2;
                                possiblyDeletedUpdatedSystemApps2 = oemAppDir;
                            } else {
                                privilegedOdmAppDir3 = privilegedOdmAppDir;
                                if (FileUtils.contains(privilegedOdmAppDir3, systemScanTime4)) {
                                    possiblyDeletedUpdatedSystemApps5 = possiblyDeletedUpdatedSystemApps2;
                                    vendorAppDir3 = vendorAppDir;
                                    odmAppDir3 = odmAppDir2;
                                    possiblyDeletedUpdatedSystemApps2 = oemAppDir;
                                } else {
                                    File vendorAppDir4 = vendorAppDir;
                                    if (FileUtils.contains(vendorAppDir4, systemScanTime4)) {
                                        vendorAppDir3 = vendorAppDir4;
                                        possiblyDeletedUpdatedSystemApps5 = possiblyDeletedUpdatedSystemApps2;
                                        odmAppDir3 = odmAppDir2;
                                        possiblyDeletedUpdatedSystemApps2 = oemAppDir;
                                    } else {
                                        possiblyDeletedUpdatedSystemApps5 = possiblyDeletedUpdatedSystemApps2;
                                        privilegedOdmAppDir2 = odmAppDir2;
                                        if (FileUtils.contains(privilegedOdmAppDir2, systemScanTime4)) {
                                            vendorAppDir3 = vendorAppDir4;
                                            odmAppDir3 = privilegedOdmAppDir2;
                                            possiblyDeletedUpdatedSystemApps2 = oemAppDir;
                                        } else {
                                            odmAppDir3 = privilegedOdmAppDir2;
                                            privilegedOdmAppDir2 = oemAppDir;
                                            if (FileUtils.contains(privilegedOdmAppDir2, systemScanTime4)) {
                                                i2 = this.mDefParseFlags | 16;
                                                rescanFlags2 = (scanFlags | 131072) | 524288;
                                            } else if (FileUtils.contains(frameworkDir, systemScanTime4)) {
                                                i2 = this.mDefParseFlags | 16;
                                                rescanFlags2 = ((scanFlags | 131072) | 2097152) | 262144;
                                            } else if (FileUtils.contains(file6, systemScanTime4)) {
                                                i2 = this.mDefParseFlags | 16;
                                                rescanFlags2 = (scanFlags | 131072) | 2097152;
                                            } else if (this.mHwPMSEx != null && this.mHwPMSEx.isSystemPreApp(systemScanTime4)) {
                                                i2 = this.mDefParseFlags | 16;
                                                rescanFlags2 = scanFlags | 131072;
                                            } else if (this.mHwPMSEx == null || !this.mHwPMSEx.isPrivilegedPreApp(systemScanTime4)) {
                                                str2 = TAG;
                                                stringBuilder3 = new StringBuilder();
                                                vendorAppDir3 = vendorAppDir4;
                                                stringBuilder3.append("Ignoring unexpected fallback path ");
                                                stringBuilder3.append(systemScanTime4);
                                                Slog.e(str2, stringBuilder3.toString());
                                                file4 = privilegedOdmAppDir3;
                                                oemAppDir = privilegedOdmAppDir2;
                                                file5 = frameworkDir;
                                                list = possiblyDeletedUpdatedSystemApps5;
                                                odmAppDir2 = odmAppDir3;
                                                file3 = vendorAppDir3;
                                                scanFlags2 = scanFlags;
                                            } else {
                                                i2 = this.mDefParseFlags | 16;
                                                rescanFlags2 = (scanFlags | 131072) | 262144;
                                            }
                                            vendorAppDir3 = vendorAppDir4;
                                            rescanFlags = i2;
                                            file3 = vendorAppDir3;
                                            file4 = privilegedOdmAppDir3;
                                            rescanFlags3 = rescanFlags2;
                                            this.mSettings.enableSystemPackageLPw(packageName);
                                            settingsDirty = true;
                                            privilegedOdmAppDir = systemScanTime4;
                                            oemAppDir = possiblyDeletedUpdatedSystemApps2;
                                            list = possiblyDeletedUpdatedSystemApps5;
                                            odmAppDir2 = odmAppDir3;
                                            file5 = frameworkDir;
                                            scanFlags2 = scanFlags;
                                            scanPackageTracedLI(systemScanTime4, rescanFlags, rescanFlags3, 0, null);
                                        }
                                    }
                                    i2 = this.mDefParseFlags | 16;
                                    rescanFlags4 = (scanFlags | 131072) | 1048576;
                                    rescanFlags = i2;
                                    rescanFlags2 = rescanFlags4;
                                    file3 = vendorAppDir3;
                                    file4 = privilegedOdmAppDir3;
                                    rescanFlags3 = rescanFlags2;
                                    this.mSettings.enableSystemPackageLPw(packageName);
                                    settingsDirty = true;
                                    privilegedOdmAppDir = systemScanTime4;
                                    oemAppDir = possiblyDeletedUpdatedSystemApps2;
                                    list = possiblyDeletedUpdatedSystemApps5;
                                    odmAppDir2 = odmAppDir3;
                                    file5 = frameworkDir;
                                    scanFlags2 = scanFlags;
                                    scanPackageTracedLI(systemScanTime4, rescanFlags, rescanFlags3, 0, null);
                                }
                            }
                            i2 = this.mDefParseFlags | 16;
                            rescanFlags4 = ((scanFlags | 131072) | 1048576) | 262144;
                            rescanFlags = i2;
                            rescanFlags2 = rescanFlags4;
                            file3 = vendorAppDir3;
                            file4 = privilegedOdmAppDir3;
                            rescanFlags3 = rescanFlags2;
                            this.mSettings.enableSystemPackageLPw(packageName);
                            settingsDirty = true;
                            privilegedOdmAppDir = systemScanTime4;
                            oemAppDir = possiblyDeletedUpdatedSystemApps2;
                            list = possiblyDeletedUpdatedSystemApps5;
                            odmAppDir2 = odmAppDir3;
                            file5 = frameworkDir;
                            scanFlags2 = scanFlags;
                            scanPackageTracedLI(systemScanTime4, rescanFlags, rescanFlags3, 0, null);
                        }
                        rescanFlags2 = rescanFlags;
                        possiblyDeletedUpdatedSystemApps5 = possiblyDeletedUpdatedSystemApps2;
                        vendorAppDir3 = vendorAppDir;
                        privilegedOdmAppDir3 = privilegedOdmAppDir;
                        odmAppDir3 = odmAppDir2;
                        possiblyDeletedUpdatedSystemApps2 = oemAppDir;
                        rescanFlags = i2;
                        file3 = vendorAppDir3;
                        file4 = privilegedOdmAppDir3;
                        rescanFlags3 = rescanFlags2;
                        this.mSettings.enableSystemPackageLPw(packageName);
                        settingsDirty = true;
                        privilegedOdmAppDir = systemScanTime4;
                        oemAppDir = possiblyDeletedUpdatedSystemApps2;
                        list = possiblyDeletedUpdatedSystemApps5;
                        odmAppDir2 = odmAppDir3;
                        file5 = frameworkDir;
                        scanFlags2 = scanFlags;
                        scanPackageTracedLI(systemScanTime4, rescanFlags, rescanFlags3, 0, null);
                    }
                    i2 = i + 1;
                    scanFlags = scanFlags2;
                    vendorAppDir = file3;
                    privilegedOdmAppDir = file4;
                    possiblyDeletedUpdatedSystemApps2 = list;
                    frameworkDir = file5;
                }
                file5 = frameworkDir;
                file3 = vendorAppDir;
                file4 = privilegedOdmAppDir;
                frameworkDir = scanFlags;
                scanFlags = stubSystemApps3;
                decompressSystemApplications(scanFlags, frameworkDir);
                i2 = PackageParser.sCachedPackageReadCount.get() - separateProcesses;
                long dataScanTime = (SystemClock.uptimeMillis() - systemScanTime2) - startTime;
                rescanFlags = this.mPackages.size() - i4;
                str = TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("Finished scanning non-system apps. Time: ");
                stringBuilder.append(dataScanTime);
                stringBuilder.append(" ms, packageCount: ");
                stringBuilder.append(rescanFlags);
                stringBuilder.append(" , timePerPackage: ");
                if (rescanFlags == 0) {
                    Object obj = scanFlags;
                    j2 = 0;
                } else {
                    list2 = scanFlags;
                    j2 = dataScanTime / ((long) rescanFlags);
                }
                stringBuilder.append(j2);
                stringBuilder.append(" , cached: ");
                stringBuilder.append(i2);
                Slog.i(str, stringBuilder.toString());
                if (this.mIsUpgrade && rescanFlags > 0) {
                    MetricsLogger.histogram(0, "ota_package_manager_data_app_avg_scan_time", ((int) dataScanTime) / rescanFlags);
                }
            }
            this.mExpectingBetter.clear();
            this.mStorageManagerPackage = getStorageManagerPackageName();
            this.mSetupWizardPackage = getSetupWizardPackageName();
            if (this.mProtectedFilters.size() > 0) {
                if (DEBUG_FILTERS && this.mSetupWizardPackage == null) {
                    Slog.i(TAG, "No setup wizard; All protected intents capped to priority 0");
                }
                for (ActivityIntentInfo filter : this.mProtectedFilters) {
                    if (!filter.activity.info.packageName.equals(this.mSetupWizardPackage)) {
                        if (DEBUG_FILTERS) {
                            str3 = TAG;
                            stringBuilder4 = new StringBuilder();
                            stringBuilder4.append("Protected action; cap priority to 0; package: ");
                            stringBuilder4.append(filter.activity.info.packageName);
                            stringBuilder4.append(" activity: ");
                            stringBuilder4.append(filter.activity.className);
                            stringBuilder4.append(" origPrio: ");
                            stringBuilder4.append(filter.getPriority());
                            Slog.i(str3, stringBuilder4.toString());
                        }
                        filter.setPriority(0);
                    } else if (DEBUG_FILTERS) {
                        str3 = TAG;
                        stringBuilder4 = new StringBuilder();
                        stringBuilder4.append("Found setup wizard; allow priority ");
                        stringBuilder4.append(filter.getPriority());
                        stringBuilder4.append("; package: ");
                        stringBuilder4.append(filter.activity.info.packageName);
                        stringBuilder4.append(" activity: ");
                        stringBuilder4.append(filter.activity.className);
                        stringBuilder4.append(" priority: ");
                        stringBuilder4.append(filter.getPriority());
                        Slog.i(str3, stringBuilder4.toString());
                    }
                }
            }
            this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
            this.mDeferProtectedFilters = false;
            this.mProtectedFilters.clear();
            updateAllSharedLibrariesLPw(null);
            for (SharedUserSetting setting : this.mSettings.getAllSharedUsersLPw()) {
                stubSystemApps = adjustCpuAbisForSharedUserLPw(setting.packages, null);
                if (stubSystemApps != null && stubSystemApps.size() > 0) {
                    i2 = stubSystemApps.size() - 1;
                    while (true) {
                        rescanFlags3 = i2;
                        if (rescanFlags3 >= 0) {
                            try {
                                this.mInstaller.rmdex((String) stubSystemApps.get(rescanFlags3), InstructionSets.getDexCodeInstructionSet(InstructionSets.getPreferredInstructionSet()));
                            } catch (InstallerException e5) {
                            }
                            i2 = rescanFlags3 - 1;
                        }
                    }
                    setting.fixSeInfoLocked();
                }
                setting.fixSeInfoLocked();
            }
            this.mPackageUsage.read(this.mPackages);
            this.mCompilerStats.read();
            EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
            str2 = TAG;
            stringBuilder3 = new StringBuilder();
            stringBuilder3.append("Time to scan packages: ");
            stringBuilder3.append(((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f);
            stringBuilder3.append(" seconds");
            Slog.i(str2, stringBuilder3.toString());
            ver = ver2;
            sdkUpdated = ver.sdkVersion != this.mSdkVersion;
            if (sdkUpdated) {
                this.tSdkVersion = ver.sdkVersion;
                deletedAppName2 = TAG;
                StringBuilder stringBuilder6 = new StringBuilder();
                stringBuilder6.append("Platform changed from ");
                stringBuilder6.append(ver.sdkVersion);
                stringBuilder6.append(" to ");
                stringBuilder6.append(this.mSdkVersion);
                stringBuilder6.append("; regranting permissions for internal storage");
                Slog.i(deletedAppName2, stringBuilder6.toString());
            }
            this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
            if (ver != null) {
                ver.sdkVersion = this.mSdkVersion;
            }
            if (z && (this.mPromoteSystemApps || this.mFirstBoot)) {
                for (UserInfo user : sUserManager.getUsers(true)) {
                    this.mSettings.applyDefaultPreferredAppsLPw(this, user.id);
                    applyFactoryDefaultBrowserLPw(user.id);
                    primeDomainVerificationsLPw(user.id);
                }
            } else if (!z && this.mIsUpgrade) {
                for (UserInfo user2 : sUserManager.getUsers(true)) {
                    primeDomainVerificationsLPw(user2.id, 1);
                }
            }
            if (StorageManager.isFileEncryptedNativeOrEmulated()) {
                storageFlags = 1;
            } else {
                storageFlags = 3;
            }
            i = storageFlags;
            deferPackages = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, i, true, true);
            this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new -$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU(this, deferPackages, i), "prepareAppData");
            if (!this.mIsUpgrade && !z) {
                Slog.i(TAG, "Build fingerprint changed; clearing code caches");
                for (i3 = 0; i3 < this.mSettings.mPackages.size(); i3++) {
                    disabledPs = (PackageSetting) this.mSettings.mPackages.valueAt(i3);
                    if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, disabledPs.volumeUuid)) {
                        clearAppDataLIF(disabledPs.pkg, -1, UsbTerminalTypes.TERMINAL_IN_PERSONAL_MIC);
                    }
                }
                ver.fingerprint = Build.FINGERPRINT;
                ver.hwFingerprint = Build.HWFINGERPRINT;
            }
            checkAndEnableWebview();
            checkDefaultBrowser();
            this.mExistingSystemPackages.clear();
            this.mPromoteSystemApps = false;
            ver.databaseVersion = 3;
            if (!(settingsDirty || this.mIsUpgrade)) {
                if (!this.mFirstBoot) {
                    if (!this.mHandler.hasMessages(13)) {
                        this.mHandler.sendEmptyMessageDelayed(13, 5000);
                    }
                    VersionInfo versionInfo = ver;
                    writeCertCompatPackages(true);
                    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
                    Jlog.d(32, "JL_BOOT_PROGRESS_PMS_READY");
                    if (this.mOnlyCore) {
                        this.mRequiredVerifierPackage = getRequiredButNotReallyRequiredVerifierLPr();
                        this.mRequiredInstallerPackage = getRequiredInstallerLPr();
                        this.mRequiredUninstallerPackage = getRequiredUninstallerLPr();
                        this.mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();
                        if (this.mIntentFilterVerifierComponent != null) {
                            this.mIntentFilterVerifier = new IntentVerifierProxy(this.mContext, this.mIntentFilterVerifierComponent);
                        } else {
                            this.mIntentFilterVerifier = null;
                        }
                        this.mServicesSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr("android.ext.services", -1);
                        this.mSharedSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr("android.ext.shared", -1);
                        str3 = null;
                    } else {
                        str3 = null;
                        this.mRequiredVerifierPackage = null;
                        this.mRequiredInstallerPackage = null;
                        this.mRequiredUninstallerPackage = null;
                        this.mIntentFilterVerifierComponent = null;
                        this.mIntentFilterVerifier = null;
                        this.mServicesSystemSharedLibraryPackageName = null;
                        this.mSharedSystemSharedLibraryPackageName = null;
                    }
                    str = str3;
                    this.mInstallerService = new PackageInstallerService(context, this);
                    instantAppResolverComponent = getInstantAppResolverLPr();
                    if (instantAppResolverComponent == null) {
                        if (DEBUG_INSTANT) {
                            String str4 = TAG;
                            StringBuilder stringBuilder7 = new StringBuilder();
                            stringBuilder7.append("Set ephemeral resolver: ");
                            stringBuilder7.append(instantAppResolverComponent);
                            Slog.d(str4, stringBuilder7.toString());
                        }
                        this.mInstantAppResolverConnection = new InstantAppResolverConnection(this.mContext, (ComponentName) instantAppResolverComponent.first, (String) instantAppResolverComponent.second);
                        this.mInstantAppResolverSettingsComponent = getInstantAppResolverSettingsLPr((ComponentName) instantAppResolverComponent.first);
                        str = null;
                    } else {
                        str = null;
                        this.mInstantAppResolverConnection = null;
                        this.mInstantAppResolverSettingsComponent = null;
                    }
                    updateInstantAppInstallerLocked(str);
                    userPackages = new HashMap();
                    currentUserIds = UserManagerService.getInstance().getUserIds();
                    Slog.i(TAG, "begin getInstalledPackages");
                    systemPackagesCount = currentUserIds.length;
                    systemConfig = null;
                    while (systemConfig < systemPackagesCount) {
                        boolean sdkUpdated2 = sdkUpdated;
                        deferPackages2 = deferPackages;
                        sdkUpdated = currentUserIds[systemConfig];
                        instantAppResolverComponent2 = instantAppResolverComponent;
                        userPackages.put(Integer.valueOf(sdkUpdated), getInstalledPackages(0, sdkUpdated).getList());
                        systemConfig++;
                        sdkUpdated = sdkUpdated2;
                        deferPackages = deferPackages2;
                        instantAppResolverComponent = instantAppResolverComponent2;
                        Context context3 = context;
                    }
                    deferPackages2 = deferPackages;
                    instantAppResolverComponent2 = instantAppResolverComponent;
                    Slog.i(TAG, "end getInstalledPackages");
                    this.mDexManager.load(userPackages);
                    if (this.mIsUpgrade) {
                        MetricsLogger.histogram(null, "ota_package_manager_init_time", (int) (SystemClock.uptimeMillis() - startTime));
                    }
                    this.mInstaller.setWarnIfHeld(this.mPackages);
                    Trace.traceEnd(262144);
                    return;
                }
            }
            if (HWFLOW) {
                this.mStartTimer = SystemClock.uptimeMillis();
            }
            Trace.traceBegin(262144, "write settings");
            this.mSettings.writeLPr();
            Trace.traceEnd(262144);
            if (HWFLOW) {
                str3 = TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("TimerCounter = ");
                rescanFlags = this.mTimerCounter + 1;
                this.mTimerCounter = rescanFlags;
                stringBuilder.append(rescanFlags);
                stringBuilder.append(" **** mSettings.writeLPr  ************ Time to elapsed: ");
                stringBuilder.append(SystemClock.uptimeMillis() - this.mStartTimer);
                stringBuilder.append(" ms");
                Slog.i(str3, stringBuilder.toString());
            }
            writeCertCompatPackages(true);
            EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
            Jlog.d(32, "JL_BOOT_PROGRESS_PMS_READY");
            if (this.mOnlyCore) {
            }
            str = str3;
            this.mInstallerService = new PackageInstallerService(context, this);
            instantAppResolverComponent = getInstantAppResolverLPr();
            if (instantAppResolverComponent == null) {
            }
            updateInstantAppInstallerLocked(str);
            userPackages = new HashMap();
            currentUserIds = UserManagerService.getInstance().getUserIds();
            Slog.i(TAG, "begin getInstalledPackages");
            systemPackagesCount = currentUserIds.length;
            systemConfig = null;
            while (systemConfig < systemPackagesCount) {
            }
            deferPackages2 = deferPackages;
            instantAppResolverComponent2 = instantAppResolverComponent;
            Slog.i(TAG, "end getInstalledPackages");
            this.mDexManager.load(userPackages);
            if (this.mIsUpgrade) {
            }
            this.mInstaller.setWarnIfHeld(this.mPackages);
            Trace.traceEnd(262144);
            return;
        } catch (PackageManagerException e6) {
            PackageManagerException packageManagerException = e6;
            deletedAppName2 = TAG;
            systemScanTime = new StringBuilder();
            systemScanTime.append("Failed to parse original system package: ");
            systemScanTime.append(e6.getMessage());
            Slog.e(deletedAppName2, systemScanTime.toString());
        } catch (Throwable th4) {
            e = th4;
            throw e;
        }
        privilegedOdmAppDir2 = odmAppDir;
        if (HWFLOW) {
            this.mStartTimer = SystemClock.uptimeMillis();
        }
        scanNonSystemPartitionDir(scanFlags);
        if (HWFLOW) {
            str2 = TAG;
            stringBuilder3 = new StringBuilder();
            stringBuilder3.append("TimerCounter = ");
            i3 = this.mTimerCounter + z3;
            this.mTimerCounter = i3;
            stringBuilder3.append(i3);
            stringBuilder3.append(" **** scanNonSystemPartitionDir  ************ Time to elapsed: ");
            vendorAppDir2 = privilegedOdmAppDir2;
            stringBuilder3.append(SystemClock.uptimeMillis() - this.mStartTimer);
            stringBuilder3.append(" ms");
            Slog.i(str2, stringBuilder3.toString());
        } else {
            vendorAppDir2 = privilegedOdmAppDir2;
        }
        if (HWFLOW) {
            this.mStartTimer = SystemClock.uptimeMillis();
        }
        scanRemovableAppDir(scanFlags);
        if (HWFLOW) {
            str2 = TAG;
            stringBuilder3 = new StringBuilder();
            stringBuilder3.append("TimerCounter = ");
            i3 = this.mTimerCounter + z3;
            this.mTimerCounter = i3;
            stringBuilder3.append(i3);
            stringBuilder3.append(" **** scanRemovableAppDir  ************ Time to elapsed: ");
            stringBuilder3.append(SystemClock.uptimeMillis() - this.mStartTimer);
            stringBuilder3.append(" ms");
            Slog.i(str2, stringBuilder3.toString());
        }
        odmAppDir = new File(Environment.getOdmDirectory(), "priv-app");
        try {
            privilegedOdmAppDir2 = odmAppDir.getCanonicalFile();
        } catch (IOException e7) {
            privilegedOdmAppDir2 = odmAppDir;
        }
        privilegedOdmAppDir = privilegedOdmAppDir2;
        vendorAppDir = vendorAppDir2;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, ((scanFlags | 131072) | 1048576) | 262144, 0);
        odmAppDir = new File(Environment.getOdmDirectory(), "app");
        privilegedOdmAppDir2 = odmAppDir.getCanonicalFile();
        odmAppDir2 = privilegedOdmAppDir2;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, (scanFlags | 131072) | 1048576, 0);
        privilegedOdmAppDir2 = new File(Environment.getOemDirectory(), "app");
        oemAppDir = privilegedOdmAppDir2;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, (scanFlags | 131072) | 524288, 0);
        odmAppDir = new File(Environment.getProductDirectory(), "priv-app");
        odmAppDir = odmAppDir.getCanonicalFile();
        privilegedOdmAppDir2 = odmAppDir;
        odmAppDir = new File(Environment.getProductDirectory(), "app");
        odmAppDir = odmAppDir.getCanonicalFile();
        productAppDir = odmAppDir;
        possiblyDeletedUpdatedSystemApps = new ArrayList();
        stubSystemApps = new ArrayList();
        if (this.mOnlyCore) {
        }
        stubSystemApps2 = stubSystemApps;
        file = privilegedOdmAppDir2;
        file2 = productAppDir;
        deleteTempPackageFiles();
        separateProcesses = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        str2 = TAG;
        stringBuilder3 = new StringBuilder();
        stringBuilder3.append("Finished scanning system apps. Time: ");
        stringBuilder3.append(systemScanTime);
        stringBuilder3.append(" ms, packageCount: ");
        stringBuilder3.append(systemPackagesCount);
        stringBuilder3.append(" , timePerPackage: ");
        if (systemPackagesCount == 0) {
        }
        stringBuilder3.append(j);
        stringBuilder3.append(" , cached: ");
        stringBuilder3.append(separateProcesses);
        Slog.i(str2, stringBuilder3.toString());
        if (this.mIsUpgrade) {
        }
        anonymousClass1 = r24;
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        if (this.mProtectedFilters.size() > 0) {
        }
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mDeferProtectedFilters = false;
        this.mProtectedFilters.clear();
        updateAllSharedLibrariesLPw(null);
        for (SharedUserSetting setting2 : this.mSettings.getAllSharedUsersLPw()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        str2 = TAG;
        stringBuilder3 = new StringBuilder();
        stringBuilder3.append("Time to scan packages: ");
        stringBuilder3.append(((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f);
        stringBuilder3.append(" seconds");
        Slog.i(str2, stringBuilder3.toString());
        ver = ver2;
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        if (ver != null) {
        }
        if (z) {
        }
        while (r1.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        i = storageFlags;
        deferPackages = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, i, true, true);
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new -$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU(this, deferPackages, i), "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        checkAndEnableWebview();
        checkDefaultBrowser();
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        if (!this.mFirstBoot) {
        }
        productAppDir = odmAppDir;
        possiblyDeletedUpdatedSystemApps = new ArrayList();
        stubSystemApps = new ArrayList();
        if (this.mOnlyCore) {
        }
        stubSystemApps2 = stubSystemApps;
        file = privilegedOdmAppDir2;
        file2 = productAppDir;
        deleteTempPackageFiles();
        separateProcesses = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        str2 = TAG;
        stringBuilder3 = new StringBuilder();
        stringBuilder3.append("Finished scanning system apps. Time: ");
        stringBuilder3.append(systemScanTime);
        stringBuilder3.append(" ms, packageCount: ");
        stringBuilder3.append(systemPackagesCount);
        stringBuilder3.append(" , timePerPackage: ");
        if (systemPackagesCount == 0) {
        }
        stringBuilder3.append(j);
        stringBuilder3.append(" , cached: ");
        stringBuilder3.append(separateProcesses);
        Slog.i(str2, stringBuilder3.toString());
        if (this.mIsUpgrade) {
        }
        anonymousClass1 = r24;
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        if (this.mProtectedFilters.size() > 0) {
        }
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mDeferProtectedFilters = false;
        this.mProtectedFilters.clear();
        updateAllSharedLibrariesLPw(null);
        for (SharedUserSetting setting22 : this.mSettings.getAllSharedUsersLPw()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        str2 = TAG;
        stringBuilder3 = new StringBuilder();
        stringBuilder3.append("Time to scan packages: ");
        stringBuilder3.append(((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f);
        stringBuilder3.append(" seconds");
        Slog.i(str2, stringBuilder3.toString());
        ver = ver2;
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        if (ver != null) {
        }
        if (z) {
        }
        while (r1.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        i = storageFlags;
        deferPackages = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, i, true, true);
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new -$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU(this, deferPackages, i), "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        checkAndEnableWebview();
        checkDefaultBrowser();
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        if (!this.mFirstBoot) {
        }
        privilegedVendorAppDir = odmAppDir;
        odmAppDir = new File(Environment.getVendorDirectory(), "app");
        try {
            odmAppDir = odmAppDir.getCanonicalFile();
        } catch (IOException e8) {
        }
        privilegedOdmAppDir2 = odmAppDir;
        if (HWFLOW) {
        }
        scanNonSystemPartitionDir(scanFlags);
        if (HWFLOW) {
        }
        if (HWFLOW) {
        }
        scanRemovableAppDir(scanFlags);
        if (HWFLOW) {
        }
        odmAppDir = new File(Environment.getOdmDirectory(), "priv-app");
        privilegedOdmAppDir2 = odmAppDir.getCanonicalFile();
        privilegedOdmAppDir = privilegedOdmAppDir2;
        vendorAppDir = vendorAppDir2;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, ((scanFlags | 131072) | 1048576) | 262144, 0);
        odmAppDir = new File(Environment.getOdmDirectory(), "app");
        privilegedOdmAppDir2 = odmAppDir.getCanonicalFile();
        odmAppDir2 = privilegedOdmAppDir2;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, (scanFlags | 131072) | 1048576, 0);
        privilegedOdmAppDir2 = new File(Environment.getOemDirectory(), "app");
        oemAppDir = privilegedOdmAppDir2;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, (scanFlags | 131072) | 524288, 0);
        odmAppDir = new File(Environment.getProductDirectory(), "priv-app");
        odmAppDir = odmAppDir.getCanonicalFile();
        privilegedOdmAppDir2 = odmAppDir;
        odmAppDir = new File(Environment.getProductDirectory(), "app");
        odmAppDir = odmAppDir.getCanonicalFile();
        productAppDir = odmAppDir;
        possiblyDeletedUpdatedSystemApps = new ArrayList();
        stubSystemApps = new ArrayList();
        if (this.mOnlyCore) {
        }
        stubSystemApps2 = stubSystemApps;
        file = privilegedOdmAppDir2;
        file2 = productAppDir;
        deleteTempPackageFiles();
        separateProcesses = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        str2 = TAG;
        stringBuilder3 = new StringBuilder();
        stringBuilder3.append("Finished scanning system apps. Time: ");
        stringBuilder3.append(systemScanTime);
        stringBuilder3.append(" ms, packageCount: ");
        stringBuilder3.append(systemPackagesCount);
        stringBuilder3.append(" , timePerPackage: ");
        if (systemPackagesCount == 0) {
        }
        stringBuilder3.append(j);
        stringBuilder3.append(" , cached: ");
        stringBuilder3.append(separateProcesses);
        Slog.i(str2, stringBuilder3.toString());
        if (this.mIsUpgrade) {
        }
        anonymousClass1 = r24;
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        if (this.mProtectedFilters.size() > 0) {
        }
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mDeferProtectedFilters = false;
        this.mProtectedFilters.clear();
        updateAllSharedLibrariesLPw(null);
        for (SharedUserSetting setting222 : this.mSettings.getAllSharedUsersLPw()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        str2 = TAG;
        stringBuilder3 = new StringBuilder();
        stringBuilder3.append("Time to scan packages: ");
        stringBuilder3.append(((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f);
        stringBuilder3.append(" seconds");
        Slog.i(str2, stringBuilder3.toString());
        ver = ver2;
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        if (ver != null) {
        }
        if (z) {
        }
        while (r1.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        i = storageFlags;
        deferPackages = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, i, true, true);
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new -$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU(this, deferPackages, i), "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        checkAndEnableWebview();
        checkDefaultBrowser();
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        if (!this.mFirstBoot) {
        }
        i2 = i + 1;
        scanFlags = scanFlags2;
        vendorAppDir = file3;
        privilegedOdmAppDir = file4;
        possiblyDeletedUpdatedSystemApps2 = list;
        frameworkDir = file5;
        odmAppDir2 = privilegedOdmAppDir2;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, (scanFlags | 131072) | 1048576, 0);
        privilegedOdmAppDir2 = new File(Environment.getOemDirectory(), "app");
        oemAppDir = privilegedOdmAppDir2;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, (scanFlags | 131072) | 524288, 0);
        odmAppDir = new File(Environment.getProductDirectory(), "priv-app");
        odmAppDir = odmAppDir.getCanonicalFile();
        privilegedOdmAppDir2 = odmAppDir;
        odmAppDir = new File(Environment.getProductDirectory(), "app");
        odmAppDir = odmAppDir.getCanonicalFile();
        productAppDir = odmAppDir;
        possiblyDeletedUpdatedSystemApps = new ArrayList();
        stubSystemApps = new ArrayList();
        if (this.mOnlyCore) {
        }
        stubSystemApps2 = stubSystemApps;
        file = privilegedOdmAppDir2;
        file2 = productAppDir;
        deleteTempPackageFiles();
        separateProcesses = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        str2 = TAG;
        stringBuilder3 = new StringBuilder();
        stringBuilder3.append("Finished scanning system apps. Time: ");
        stringBuilder3.append(systemScanTime);
        stringBuilder3.append(" ms, packageCount: ");
        stringBuilder3.append(systemPackagesCount);
        stringBuilder3.append(" , timePerPackage: ");
        if (systemPackagesCount == 0) {
        }
        stringBuilder3.append(j);
        stringBuilder3.append(" , cached: ");
        stringBuilder3.append(separateProcesses);
        Slog.i(str2, stringBuilder3.toString());
        if (this.mIsUpgrade) {
        }
        anonymousClass1 = r24;
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        if (this.mProtectedFilters.size() > 0) {
        }
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mDeferProtectedFilters = false;
        this.mProtectedFilters.clear();
        updateAllSharedLibrariesLPw(null);
        for (SharedUserSetting setting2222 : this.mSettings.getAllSharedUsersLPw()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        str2 = TAG;
        stringBuilder3 = new StringBuilder();
        stringBuilder3.append("Time to scan packages: ");
        stringBuilder3.append(((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f);
        stringBuilder3.append(" seconds");
        Slog.i(str2, stringBuilder3.toString());
        ver = ver2;
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        if (ver != null) {
        }
        if (z) {
        }
        while (r1.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        i = storageFlags;
        deferPackages = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, i, true, true);
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new -$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU(this, deferPackages, i), "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        checkAndEnableWebview();
        checkDefaultBrowser();
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        if (!this.mFirstBoot) {
        }
        privilegedOdmAppDir2 = odmAppDir;
        odmAppDir = new File(Environment.getProductDirectory(), "app");
        odmAppDir = odmAppDir.getCanonicalFile();
        productAppDir = odmAppDir;
        possiblyDeletedUpdatedSystemApps = new ArrayList();
        stubSystemApps = new ArrayList();
        if (this.mOnlyCore) {
        }
        stubSystemApps2 = stubSystemApps;
        file = privilegedOdmAppDir2;
        file2 = productAppDir;
        deleteTempPackageFiles();
        separateProcesses = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        str2 = TAG;
        stringBuilder3 = new StringBuilder();
        stringBuilder3.append("Finished scanning system apps. Time: ");
        stringBuilder3.append(systemScanTime);
        stringBuilder3.append(" ms, packageCount: ");
        stringBuilder3.append(systemPackagesCount);
        stringBuilder3.append(" , timePerPackage: ");
        if (systemPackagesCount == 0) {
        }
        stringBuilder3.append(j);
        stringBuilder3.append(" , cached: ");
        stringBuilder3.append(separateProcesses);
        Slog.i(str2, stringBuilder3.toString());
        if (this.mIsUpgrade) {
        }
        anonymousClass1 = r24;
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        if (this.mProtectedFilters.size() > 0) {
        }
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mDeferProtectedFilters = false;
        this.mProtectedFilters.clear();
        updateAllSharedLibrariesLPw(null);
        for (SharedUserSetting setting22222 : this.mSettings.getAllSharedUsersLPw()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        str2 = TAG;
        stringBuilder3 = new StringBuilder();
        stringBuilder3.append("Time to scan packages: ");
        stringBuilder3.append(((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f);
        stringBuilder3.append(" seconds");
        Slog.i(str2, stringBuilder3.toString());
        ver = ver2;
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        if (ver != null) {
        }
        if (z) {
        }
        while (r1.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        i = storageFlags;
        deferPackages = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, i, true, true);
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new -$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU(this, deferPackages, i), "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        checkAndEnableWebview();
        checkDefaultBrowser();
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        if (!this.mFirstBoot) {
        }
        ArrayList<File> fileList = fileList;
        VersionInfo ver3;
        long startTime2;
        if (fileList != null) {
            it = fileList.iterator();
            while (it.hasNext()) {
                rescanFlags2 = rescanFlags;
                ver2 = ver3;
                startTime = startTime2;
                scanDirTracedLI((File) it.next(), this.mDefParseFlags | 16, (scanFlags | 131072) | 1048576, 0);
                startTime2 = startTime;
                rescanFlags = rescanFlags2;
                ver3 = ver2;
            }
            rescanFlags2 = rescanFlags;
            ver2 = ver3;
            startTime = startTime2;
        } else {
            rescanFlags2 = 4;
            ver2 = ver3;
            startTime = startTime2;
            scanDirTracedLI(new File(VENDOR_OVERLAY_DIR), this.mDefParseFlags | 16, (scanFlags | 131072) | 1048576, 0);
            scanDirTracedLI(new File(PRODUCT_OVERLAY_DIR), this.mDefParseFlags | 16, (scanFlags | 131072) | 2097152, 0);
        }
        if (HWFLOW) {
            this.mStartTimer = SystemClock.uptimeMillis();
        }
        getUninstallApk();
        if (HWFLOW) {
            str2 = TAG;
            stringBuilder3 = new StringBuilder();
            stringBuilder3.append("TimerCounter = ");
            i3 = this.mTimerCounter + z3;
            this.mTimerCounter = i3;
            stringBuilder3.append(i3);
            stringBuilder3.append(" **** getUninstallApk  ************ Time to elapsed: ");
            stringBuilder3.append(SystemClock.uptimeMillis() - this.mStartTimer);
            stringBuilder3.append(" ms");
            Slog.i(str2, stringBuilder3.toString());
        }
        this.mParallelPackageParserCallback.findStaticOverlayPackages();
        boolean z4 = false;
        storageFlags = scanFlags;
        boolean z5 = z3;
        z = z2;
        scanDirTracedLI(frameworkDir, this.mDefParseFlags | 16, ((scanFlags | 1) | 131072) | 262144, 0);
        Slog.i(TAG, "begin scan priv-app");
        privilegedAppDir = new File(Environment.getRootDirectory(), "priv-app");
        z3 = z4;
        scanFlags = storageFlags;
        z3 = z5;
        scanDirTracedLI(privilegedAppDir, this.mDefParseFlags | 16, (storageFlags | 131072) | 262144, 0);
        Slog.i(TAG, "end scan priv-app");
        Slog.i(TAG, "begin scan app");
        systemAppDir = new File(Environment.getRootDirectory(), "app");
        scanDirTracedLI(systemAppDir, this.mDefParseFlags | 16, scanFlags | 131072, 0);
        Slog.i(TAG, "end scan app");
        odmAppDir = new File(Environment.getVendorDirectory(), "priv-app");
        try {
            odmAppDir = odmAppDir.getCanonicalFile();
        } catch (IOException e9) {
        }
        privilegedVendorAppDir = odmAppDir;
        odmAppDir = new File(Environment.getVendorDirectory(), "app");
        odmAppDir = odmAppDir.getCanonicalFile();
        privilegedOdmAppDir2 = odmAppDir;
        if (HWFLOW) {
        }
        scanNonSystemPartitionDir(scanFlags);
        if (HWFLOW) {
        }
        if (HWFLOW) {
        }
        scanRemovableAppDir(scanFlags);
        if (HWFLOW) {
        }
        odmAppDir = new File(Environment.getOdmDirectory(), "priv-app");
        privilegedOdmAppDir2 = odmAppDir.getCanonicalFile();
        privilegedOdmAppDir = privilegedOdmAppDir2;
        vendorAppDir = vendorAppDir2;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, ((scanFlags | 131072) | 1048576) | 262144, 0);
        odmAppDir = new File(Environment.getOdmDirectory(), "app");
        privilegedOdmAppDir2 = odmAppDir.getCanonicalFile();
        odmAppDir2 = privilegedOdmAppDir2;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, (scanFlags | 131072) | 1048576, 0);
        privilegedOdmAppDir2 = new File(Environment.getOemDirectory(), "app");
        oemAppDir = privilegedOdmAppDir2;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, (scanFlags | 131072) | 524288, 0);
        odmAppDir = new File(Environment.getProductDirectory(), "priv-app");
        odmAppDir = odmAppDir.getCanonicalFile();
        privilegedOdmAppDir2 = odmAppDir;
        odmAppDir = new File(Environment.getProductDirectory(), "app");
        odmAppDir = odmAppDir.getCanonicalFile();
        productAppDir = odmAppDir;
        possiblyDeletedUpdatedSystemApps = new ArrayList();
        stubSystemApps = new ArrayList();
        if (this.mOnlyCore) {
        }
        stubSystemApps2 = stubSystemApps;
        file = privilegedOdmAppDir2;
        file2 = productAppDir;
        deleteTempPackageFiles();
        separateProcesses = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        str2 = TAG;
        stringBuilder3 = new StringBuilder();
        stringBuilder3.append("Finished scanning system apps. Time: ");
        stringBuilder3.append(systemScanTime);
        stringBuilder3.append(" ms, packageCount: ");
        stringBuilder3.append(systemPackagesCount);
        stringBuilder3.append(" , timePerPackage: ");
        if (systemPackagesCount == 0) {
        }
        stringBuilder3.append(j);
        stringBuilder3.append(" , cached: ");
        stringBuilder3.append(separateProcesses);
        Slog.i(str2, stringBuilder3.toString());
        if (this.mIsUpgrade) {
        }
        anonymousClass1 = r24;
        if (this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        if (this.mProtectedFilters.size() > 0) {
        }
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mDeferProtectedFilters = false;
        this.mProtectedFilters.clear();
        updateAllSharedLibrariesLPw(null);
        for (SharedUserSetting setting222222 : this.mSettings.getAllSharedUsersLPw()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        str2 = TAG;
        stringBuilder3 = new StringBuilder();
        stringBuilder3.append("Time to scan packages: ");
        stringBuilder3.append(((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f);
        stringBuilder3.append(" seconds");
        Slog.i(str2, stringBuilder3.toString());
        ver = ver2;
        if (ver.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        if (ver != null) {
        }
        if (z) {
        }
        while (r1.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        i = storageFlags;
        deferPackages = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, i, true, true);
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new -$$Lambda$PackageManagerService$sJ5w9GfSftnZPyv5hBDxQkxDJMU(this, deferPackages, i), "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        checkAndEnableWebview();
        checkDefaultBrowser();
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver.databaseVersion = 3;
        if (!this.mFirstBoot) {
        }
        i2 = rescanFlags3 - 1;
    }

    public static /* synthetic */ void lambda$new$0(PackageManagerService packageManagerService, List deferPackages, int storageFlags) {
        TimingsTraceLog traceLog = new TimingsTraceLog("SystemServerTimingAsync", 262144);
        traceLog.traceBegin("AppDataFixup");
        try {
            packageManagerService.mInstaller.fixupAppData(StorageManager.UUID_PRIVATE_INTERNAL, 3);
        } catch (InstallerException e) {
            Slog.w(TAG, "Trouble fixing GIDs", e);
        }
        traceLog.traceEnd();
        traceLog.traceBegin("AppDataPrepare");
        if (deferPackages != null && !deferPackages.isEmpty()) {
            int count = 0;
            for (String pkgName : deferPackages) {
                Package pkg = null;
                synchronized (packageManagerService.mPackages) {
                    PackageSetting ps = packageManagerService.mSettings.getPackageLPr(pkgName);
                    if (ps != null && ps.getInstalled(0)) {
                        pkg = ps.pkg;
                    }
                }
                if (pkg != null) {
                    synchronized (packageManagerService.mInstallLock) {
                        packageManagerService.prepareAppDataAndMigrateLIF(pkg, 0, storageFlags, true);
                    }
                    count++;
                }
            }
            traceLog.traceEnd();
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Deferred reconcileAppsData finished ");
            stringBuilder.append(count);
            stringBuilder.append(" packages");
            Slog.i(str, stringBuilder.toString());
        }
    }

    private void checkAndEnableWebview() {
        if (this.mIsUpgrade) {
            String pkgWebViewName = "com.google.android.webview";
            boolean isChina = "CN".equalsIgnoreCase(SystemProperties.get("ro.product.locale.region", BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS));
            try {
                int state = getApplicationEnabledSetting(pkgWebViewName, this.mContext.getUserId());
                boolean z = true;
                if (state != 1) {
                    z = false;
                }
                boolean isEnabled = z;
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("WebViewGoogle state=");
                stringBuilder.append(state);
                stringBuilder.append(" version is china = ");
                stringBuilder.append(isChina);
                Slog.i(str, stringBuilder.toString());
                if (!isEnabled && isChina) {
                    Slog.i(TAG, "current WebViewGoogle disable, enable it");
                    setApplicationEnabledSetting(pkgWebViewName, 1, 0, this.mContext.getUserId(), this.mContext.getOpPackageName());
                }
            } catch (Exception e) {
                String str2 = TAG;
                StringBuilder stringBuilder2 = new StringBuilder();
                stringBuilder2.append("enable WebViewGoogle exception ");
                stringBuilder2.append(e.getMessage());
                Slog.w(str2, stringBuilder2.toString());
            }
        }
    }

    private void decompressSystemApplications(List<String> stubSystemApps, int scanFlags) {
        List<String> list = stubSystemApps;
        int i = stubSystemApps.size() - 1;
        while (true) {
            int i2 = i;
            if (i2 < 0) {
                break;
            }
            String pkgName = (String) list.get(i2);
            if (this.mSettings.isDisabledSystemPackageLPr(pkgName)) {
                list.remove(i2);
            } else {
                Package pkg = (Package) this.mPackages.get(pkgName);
                if (pkg == null) {
                    list.remove(i2);
                } else {
                    PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(pkgName);
                    if (ps == null || ps.getEnabled(0) != 3) {
                        String str;
                        StringBuilder stringBuilder;
                        if (DEBUG_COMPRESSION) {
                            str = TAG;
                            stringBuilder = new StringBuilder();
                            stringBuilder.append("Uncompressing system stub; pkg: ");
                            stringBuilder.append(pkgName);
                            Slog.i(str, stringBuilder.toString());
                        }
                        File scanFile = decompressPackage(pkg);
                        if (scanFile != null) {
                            try {
                                this.mSettings.disableSystemPackageLPw(pkgName, true);
                                removePackageLI(pkg, true);
                                scanPackageTracedLI(scanFile, 0, scanFlags, 0, null);
                                ps.setEnabled(0, 0, PLATFORM_PACKAGE_NAME);
                                list.remove(i2);
                            } catch (PackageManagerException e) {
                                str = TAG;
                                stringBuilder = new StringBuilder();
                                stringBuilder.append("Failed to parse uncompressed system package: ");
                                stringBuilder.append(e.getMessage());
                                Slog.e(str, stringBuilder.toString());
                            }
                        }
                    } else {
                        list.remove(i2);
                    }
                }
            }
            i = i2 - 1;
        }
        for (int i3 = stubSystemApps.size() - 1; i3 >= 0; i3--) {
            String pkgName2 = (String) list.get(i3);
            ((PackageSetting) this.mSettings.mPackages.get(pkgName2)).setEnabled(2, 0, PLATFORM_PACKAGE_NAME);
            StringBuilder stringBuilder2 = new StringBuilder();
            stringBuilder2.append("Stub disabled; pkg: ");
            stringBuilder2.append(pkgName2);
            PackageManagerServiceUtils.logCriticalInfo(6, stringBuilder2.toString());
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:19:0x009e  */
    /* JADX WARNING: Removed duplicated region for block: B:38:0x00e5 A:{RETURN} */
    /* JADX WARNING: Removed duplicated region for block: B:32:0x00d7  */
    /* JADX WARNING: Removed duplicated region for block: B:19:0x009e  */
    /* JADX WARNING: Removed duplicated region for block: B:32:0x00d7  */
    /* JADX WARNING: Removed duplicated region for block: B:38:0x00e5 A:{RETURN} */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private File decompressPackage(Package pkg) {
        ErrnoException e;
        StringBuilder stringBuilder;
        File[] compressedFiles = PackageManagerServiceUtils.getCompressedFiles(pkg.codePath);
        if (compressedFiles == null || compressedFiles.length == 0) {
            if (DEBUG_COMPRESSION) {
                String str = TAG;
                StringBuilder stringBuilder2 = new StringBuilder();
                stringBuilder2.append("No files to decompress: ");
                stringBuilder2.append(pkg.baseCodePath);
                Slog.i(str, stringBuilder2.toString());
            }
            return null;
        }
        int ret;
        File dstCodePath = getNextCodePath(Environment.getDataAppDirectory(null), pkg.packageName);
        int ret2 = 1;
        try {
            Os.mkdir(dstCodePath.getAbsolutePath(), 493);
            Os.chmod(dstCodePath.getAbsolutePath(), 493);
            int length = compressedFiles.length;
            ret = ret2;
            ret2 = 0;
            while (ret2 < length) {
                try {
                    File srcFile = compressedFiles[ret2];
                    String srcFileName = srcFile.getName();
                    String dstFileName = srcFileName.substring(0, srcFileName.length() - COMPRESSED_EXTENSION.length());
                    ret = PackageManagerServiceUtils.decompressFile(srcFile, new File(dstCodePath, dstFileName));
                    if (ret != 1) {
                        StringBuilder stringBuilder3 = new StringBuilder();
                        stringBuilder3.append("Failed to decompress; pkg: ");
                        stringBuilder3.append(pkg.packageName);
                        stringBuilder3.append(", file: ");
                        stringBuilder3.append(dstFileName);
                        PackageManagerServiceUtils.logCriticalInfo(6, stringBuilder3.toString());
                        break;
                    }
                    ret2++;
                } catch (ErrnoException e2) {
                    e = e2;
                    stringBuilder = new StringBuilder();
                    stringBuilder.append("Failed to decompress; pkg: ");
                    stringBuilder.append(pkg.packageName);
                    stringBuilder.append(", err: ");
                    stringBuilder.append(e.errno);
                    PackageManagerServiceUtils.logCriticalInfo(6, stringBuilder.toString());
                    if (ret == 1) {
                    }
                    if (ret == 1) {
                    }
                }
            }
        } catch (ErrnoException e3) {
            ret = ret2;
            e = e3;
            stringBuilder = new StringBuilder();
            stringBuilder.append("Failed to decompress; pkg: ");
            stringBuilder.append(pkg.packageName);
            stringBuilder.append(", err: ");
            stringBuilder.append(e.errno);
            PackageManagerServiceUtils.logCriticalInfo(6, stringBuilder.toString());
            if (ret == 1) {
            }
            if (ret == 1) {
            }
        }
        if (ret == 1) {
            File libraryRoot = new File(dstCodePath, "lib");
            Handle handle = null;
            try {
                handle = Handle.create(dstCodePath);
                ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot, null);
            } catch (IOException e4) {
                StringBuilder stringBuilder4 = new StringBuilder();
                stringBuilder4.append("Failed to extract native libraries; pkg: ");
                stringBuilder4.append(pkg.packageName);
                PackageManagerServiceUtils.logCriticalInfo(6, stringBuilder4.toString());
                ret = RequestStatus.SYS_ETIMEDOUT;
            } catch (Throwable th) {
                IoUtils.closeQuietly(handle);
            }
            IoUtils.closeQuietly(handle);
        }
        if (ret == 1) {
            return dstCodePath;
        }
        if (dstCodePath == null || !dstCodePath.exists()) {
            return null;
        }
        removeCodePathLI(dstCodePath);
        return null;
    }

    private void updateInstantAppInstallerLocked(String modifiedPackage) {
        if (this.mInstantAppInstallerActivity == null || this.mInstantAppInstallerActivity.getComponentName().getPackageName().equals(modifiedPackage)) {
            setUpInstantAppInstallerActivityLP(getInstantAppInstallerLPr());
        }
    }

    private static File preparePackageParserCache(boolean isUpgrade) {
        String str = TAG;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("preparePackageParserCache, isUpgrade= ");
        stringBuilder.append(isUpgrade);
        Slog.i(str, stringBuilder.toString());
        if (Build.IS_ENG) {
            return null;
        }
        if (SystemProperties.getBoolean("pm.boot.disable_package_cache", false)) {
            Slog.i(TAG, "Disabling package parser cache due to system property.");
            return null;
        }
        File cacheBaseDir = FileUtils.createDir(Environment.getDataSystemDirectory(), "package_cache");
        if (cacheBaseDir == null) {
            return null;
        }
        if (isUpgrade) {
            FileUtils.deleteContents(cacheBaseDir);
        }
        File cacheDir = FileUtils.createDir(cacheBaseDir, PACKAGE_PARSER_CACHE_VERSION);
        if (cacheDir == null) {
            String str2 = TAG;
            StringBuilder stringBuilder2 = new StringBuilder();
            stringBuilder2.append("Cache directory cannot be created - wiping base dir ");
            stringBuilder2.append(cacheBaseDir);
            Slog.wtf(str2, stringBuilder2.toString());
            FileUtils.deleteContentsAndDir(cacheBaseDir);
            return null;
        }
        if (Build.IS_USERDEBUG && VERSION.INCREMENTAL.startsWith("eng.")) {
            Slog.w(TAG, "Wiping cache directory because the system partition changed.");
            if (cacheDir.lastModified() < new File(Environment.getRootDirectory(), "framework").lastModified()) {
                FileUtils.deleteContents(cacheBaseDir);
                cacheDir = FileUtils.createDir(cacheBaseDir, PACKAGE_PARSER_CACHE_VERSION);
            }
        }
        return cacheDir;
    }

    public boolean isFirstBoot() {
        return this.mFirstBoot;
    }

    public boolean isOnlyCoreApps() {
        return this.mOnlyCore;
    }

    public boolean isUpgrade() {
        return this.mIsUpgrade || SystemProperties.getBoolean("persist.pm.mock-upgrade", false);
    }

    private String getRequiredButNotReallyRequiredVerifierLPr() {
        List<ResolveInfo> matches = queryIntentReceiversInternal(new Intent("android.intent.action.PACKAGE_NEEDS_VERIFICATION"), PACKAGE_MIME_TYPE, 1835008, 0, false);
        if (matches.size() == 1) {
            return ((ResolveInfo) matches.get(0)).getComponentInfo().packageName;
        }
        if (matches.size() == 0) {
            Log.e(TAG, "There should probably be a verifier, but, none were found");
            return null;
        }
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("There must be exactly one verifier; found ");
        stringBuilder.append(matches);
        throw new RuntimeException(stringBuilder.toString());
    }

    private String getRequiredSharedLibraryLPr(String name, int version) {
        String str;
        synchronized (this.mPackages) {
            SharedLibraryEntry libraryEntry = getSharedLibraryEntryLPr(name, (long) version);
            if (libraryEntry != null) {
                str = libraryEntry.apk;
            } else {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Missing required shared library:");
                stringBuilder.append(name);
                throw new IllegalStateException(stringBuilder.toString());
            }
        }
        return str;
    }

    private String getRequiredInstallerLPr() {
        Intent intent = new Intent("android.intent.action.INSTALL_PACKAGE");
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setDataAndType(Uri.fromFile(new File("foo.apk")), PACKAGE_MIME_TYPE);
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, PACKAGE_MIME_TYPE, 1835008, 0);
        if (matches.size() != 1) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("There must be exactly one installer; found ");
            stringBuilder.append(matches);
            throw new RuntimeException(stringBuilder.toString());
        } else if (((ResolveInfo) matches.get(0)).activityInfo.applicationInfo.isPrivilegedApp()) {
            return ((ResolveInfo) matches.get(0)).getComponentInfo().packageName;
        } else {
            throw new RuntimeException("The installer must be a privileged app");
        }
    }

    private String getRequiredUninstallerLPr() {
        Intent intent = new Intent("android.intent.action.UNINSTALL_PACKAGE");
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setData(Uri.fromParts("package", "foo.bar", null));
        ResolveInfo resolveInfo = resolveIntent(intent, null, 1835008, 0);
        if (resolveInfo != null && (this.mResolveActivity.name == null || !this.mResolveActivity.name.equals(resolveInfo.getComponentInfo().name))) {
            return resolveInfo.getComponentInfo().packageName;
        }
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("There must be exactly one uninstaller; found ");
        stringBuilder.append(resolveInfo);
        throw new RuntimeException(stringBuilder.toString());
    }

    private ComponentName getIntentFilterVerifierComponentNameLPr() {
        List<ResolveInfo> matches = queryIntentReceiversInternal(new Intent("android.intent.action.INTENT_FILTER_NEEDS_VERIFICATION"), PACKAGE_MIME_TYPE, 1835008, 0, false);
        int N = matches.size();
        ResolveInfo best = null;
        for (int i = 0; i < N; i++) {
            ResolveInfo cur = (ResolveInfo) matches.get(i);
            if (checkPermission("android.permission.INTENT_FILTER_VERIFICATION_AGENT", cur.getComponentInfo().packageName, 0) == 0 && (best == null || cur.priority > best.priority)) {
                best = cur;
            }
        }
        if (best != null) {
            return best.getComponentInfo().getComponentName();
        }
        Slog.w(TAG, "Intent filter verifier not found");
        return null;
    }

    public ComponentName getInstantAppResolverComponent() {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            Pair<ComponentName, String> instantAppResolver = getInstantAppResolverLPr();
            if (instantAppResolver == null) {
                return null;
            }
            ComponentName componentName = (ComponentName) instantAppResolver.first;
            return componentName;
        }
    }

    private Pair<ComponentName, String> getInstantAppResolverLPr() {
        String[] packageArray = this.mContext.getResources().getStringArray(17236008);
        if (packageArray.length != 0 || Build.IS_DEBUGGABLE) {
            int i = 0;
            String actionName = "android.intent.action.RESOLVE_INSTANT_APP_PACKAGE";
            List<ResolveInfo> resolvers = queryIntentServicesInternal(new Intent(actionName), null, 786432 | (!Build.IS_DEBUGGABLE ? 1048576 : 0), 0, Binder.getCallingUid(), false);
            int N = resolvers.size();
            if (N == 0) {
                if (DEBUG_INSTANT) {
                    Slog.d(TAG, "Ephemeral resolver NOT found; no matching intent filters");
                }
                return null;
            }
            ResolveInfo info;
            String packageName;
            Set<String> possiblePackages = new ArraySet(Arrays.asList(packageArray));
            while (true) {
                int i2 = i;
                if (i2 < N) {
                    info = (ResolveInfo) resolvers.get(i2);
                    if (info.serviceInfo != null) {
                        packageName = info.serviceInfo.packageName;
                        if (!possiblePackages.contains(packageName) && !Build.IS_DEBUGGABLE) {
                            if (DEBUG_INSTANT) {
                                String str = TAG;
                                StringBuilder stringBuilder = new StringBuilder();
                                stringBuilder.append("Ephemeral resolver not in allowed package list; pkg: ");
                                stringBuilder.append(packageName);
                                stringBuilder.append(", info:");
                                stringBuilder.append(info);
                                Slog.d(str, stringBuilder.toString());
                            }
                        }
                    }
                    i = i2 + 1;
                } else {
                    if (DEBUG_INSTANT) {
                        Slog.v(TAG, "Ephemeral resolver NOT found");
                    }
                    return null;
                }
            }
            if (DEBUG_INSTANT) {
                String str2 = TAG;
                StringBuilder stringBuilder2 = new StringBuilder();
                stringBuilder2.append("Ephemeral resolver found; pkg: ");
                stringBuilder2.append(packageName);
                stringBuilder2.append(", info:");
                stringBuilder2.append(info);
                Slog.v(str2, stringBuilder2.toString());
            }
            return new Pair(new ComponentName(packageName, info.serviceInfo.name), actionName);
        }
        if (DEBUG_INSTANT) {
            Slog.d(TAG, "Ephemeral resolver NOT found; empty package list");
        }
        return null;
    }

    private ActivityInfo getInstantAppInstallerLPr() {
        String[] orderedActions;
        if (Build.IS_ENG) {
            orderedActions = new String[]{"android.intent.action.INSTALL_INSTANT_APP_PACKAGE_TEST", "android.intent.action.INSTALL_INSTANT_APP_PACKAGE"};
        } else {
            orderedActions = new String[]{"android.intent.action.INSTALL_INSTANT_APP_PACKAGE"};
        }
        int resolveFlags = 786944 | (!Build.IS_ENG ? 1048576 : 0);
        Intent intent = new Intent();
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setDataAndType(Uri.fromFile(new File("foo.apk")), PACKAGE_MIME_TYPE);
        List<ResolveInfo> matches = null;
        for (String action : orderedActions) {
            intent.setAction(action);
            matches = queryIntentActivitiesInternal(intent, PACKAGE_MIME_TYPE, resolveFlags, 0);
            if (!matches.isEmpty()) {
                break;
            }
            if (DEBUG_INSTANT) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Instant App installer not found with ");
                stringBuilder.append(action);
                Slog.d(str, stringBuilder.toString());
            }
        }
        Iterator<ResolveInfo> iter = matches.iterator();
        while (iter.hasNext()) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(((ResolveInfo) iter.next()).activityInfo.packageName);
            if (ps != null) {
                if (!ps.getPermissionsState().hasPermission("android.permission.INSTALL_PACKAGES", 0)) {
                    if (Build.IS_ENG) {
                    }
                }
            }
            iter.remove();
        }
        if (matches.size() == 0) {
            return null;
        }
        if (matches.size() == 1) {
            return (ActivityInfo) ((ResolveInfo) matches.get(0)).getComponentInfo();
        }
        StringBuilder stringBuilder2 = new StringBuilder();
        stringBuilder2.append("There must be at most one ephemeral installer; found ");
        stringBuilder2.append(matches);
        throw new RuntimeException(stringBuilder2.toString());
    }

    private ComponentName getInstantAppResolverSettingsLPr(ComponentName resolver) {
        List<ResolveInfo> matches = queryIntentActivitiesInternal(new Intent("android.intent.action.INSTANT_APP_RESOLVER_SETTINGS").addCategory("android.intent.category.DEFAULT").setPackage(resolver.getPackageName()), null, 786432, 0);
        if (matches.isEmpty()) {
            return null;
        }
        return ((ResolveInfo) matches.get(0)).getComponentInfo().getComponentName();
    }

    private void primeDomainVerificationsLPw(int userId) {
        primeDomainVerificationsLPw(userId, 0);
    }

    private void primeDomainVerificationsLPw(int userId, int flag) {
        if (DEBUG_DOMAIN_VERIFICATION) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Priming domain verifications in user ");
            stringBuilder.append(userId);
            Slog.d(str, stringBuilder.toString());
        }
        Iterator it = SystemConfig.getInstance().getLinkedApps().iterator();
        while (it.hasNext()) {
            String packageName = (String) it.next();
            Package pkg = (Package) this.mPackages.get(packageName);
            String str2;
            StringBuilder stringBuilder2;
            if (pkg == null) {
                str2 = TAG;
                stringBuilder2 = new StringBuilder();
                stringBuilder2.append("Unknown package ");
                stringBuilder2.append(packageName);
                stringBuilder2.append(" in sysconfig <app-link>");
                Slog.w(str2, stringBuilder2.toString());
            } else if (pkg.isSystem()) {
                ArraySet<String> domains = null;
                Iterator it2 = pkg.activities.iterator();
                while (it2.hasNext()) {
                    Iterator it3 = ((Activity) it2.next()).intents.iterator();
                    while (it3.hasNext()) {
                        ActivityIntentInfo filter = (ActivityIntentInfo) it3.next();
                        if (hasValidDomains(filter)) {
                            if (domains == null) {
                                domains = new ArraySet();
                            }
                            domains.addAll(filter.getHostsList());
                        }
                    }
                }
                String str3;
                StringBuilder stringBuilder3;
                if (domains == null || domains.size() <= 0) {
                    str3 = TAG;
                    stringBuilder3 = new StringBuilder();
                    stringBuilder3.append("Sysconfig <app-link> package '");
                    stringBuilder3.append(packageName);
                    stringBuilder3.append("' does not handle web links");
                    Slog.w(str3, stringBuilder3.toString());
                } else {
                    if (DEBUG_DOMAIN_VERIFICATION) {
                        str3 = TAG;
                        stringBuilder3 = new StringBuilder();
                        stringBuilder3.append("      + ");
                        stringBuilder3.append(packageName);
                        Slog.v(str3, stringBuilder3.toString());
                    }
                    if (this.mIsUpgrade && flag == 1) {
                        PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                        if (ps != null && ps.getIntentFilterVerificationInfo() == null) {
                            ps.setIntentFilterVerificationInfo(new IntentFilterVerificationInfo(packageName, domains));
                            this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, 2, userId);
                            String str4 = TAG;
                            StringBuilder stringBuilder4 = new StringBuilder();
                            stringBuilder4.append("package ");
                            stringBuilder4.append(packageName);
                            stringBuilder4.append(" is a new application for hota upgrade, sysconfig app-link");
                            Slog.w(str4, stringBuilder4.toString());
                        }
                    } else if (flag == 0) {
                        this.mSettings.createIntentFilterVerificationIfNeededLPw(packageName, domains).setStatus(0);
                        this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, 2, userId);
                    }
                }
            } else {
                str2 = TAG;
                stringBuilder2 = new StringBuilder();
                stringBuilder2.append("Non-system app '");
                stringBuilder2.append(packageName);
                stringBuilder2.append("' in sysconfig <app-link>");
                Slog.w(str2, stringBuilder2.toString());
            }
        }
        scheduleWritePackageRestrictionsLocked(userId);
        scheduleWriteSettingsLocked();
    }

    private void applyFactoryDefaultBrowserLPw(int userId) {
        String browserPkg = this.mContext.getResources().getString(17039920);
        if (!TextUtils.isEmpty(browserPkg)) {
            if (((PackageSetting) this.mSettings.mPackages.get(browserPkg)) == null) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Product default browser app does not exist: ");
                stringBuilder.append(browserPkg);
                Slog.e(str, stringBuilder.toString());
                browserPkg = null;
            } else {
                this.mSettings.setDefaultBrowserPackageNameLPw(browserPkg, userId);
            }
        }
        if (browserPkg == null) {
            calculateDefaultBrowserLPw(userId);
        }
    }

    private void calculateDefaultBrowserLPw(int userId) {
        List<String> allBrowsers = resolveAllBrowserApps(userId);
        this.mSettings.setDefaultBrowserPackageNameLPw(allBrowsers.size() == 1 ? (String) allBrowsers.get(0) : null, userId);
    }

    private List<String> resolveAllBrowserApps(int userId) {
        List<ResolveInfo> list = queryIntentActivitiesInternal(sBrowserIntent, null, 131072, userId);
        int count = list.size();
        List<String> result = new ArrayList(count);
        for (int i = 0; i < count; i++) {
            ResolveInfo info = (ResolveInfo) list.get(i);
            if (!(info.activityInfo == null || !info.handleAllWebDataURI || (info.activityInfo.applicationInfo.flags & 1) == 0 || result.contains(info.activityInfo.packageName))) {
                result.add(info.activityInfo.packageName);
            }
        }
        return result;
    }

    private boolean packageIsBrowser(String packageName, int userId) {
        List<ResolveInfo> list = queryIntentActivitiesInternal(sBrowserIntent, null, 131072, userId);
        int N = list.size();
        for (int i = 0; i < N; i++) {
            ResolveInfo info = (ResolveInfo) list.get(i);
            if (info.priority >= 0 && packageName.equals(info.activityInfo.packageName)) {
                return true;
            }
        }
        return false;
    }

    private void checkDefaultBrowser() {
        int myUserId = UserHandle.myUserId();
        String packageName = getDefaultBrowserPackageName(myUserId);
        if (packageName != null && getPackageInfo(packageName, null, myUserId) == null) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Default browser no longer installed: ");
            stringBuilder.append(packageName);
            Slog.w(str, stringBuilder.toString());
            synchronized (this.mPackages) {
                applyFactoryDefaultBrowserLPw(myUserId);
            }
        }
    }

    public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
        try {
            return super.onTransact(code, data, reply, flags);
        } catch (RuntimeException e) {
            if (!((e instanceof SecurityException) || (e instanceof IllegalArgumentException))) {
                Slog.wtf(TAG, "Package Manager Crash", e);
            }
            throw e;
        }
    }

    static int[] appendInts(int[] cur, int[] add) {
        if (add == null) {
            return cur;
        }
        if (cur == null) {
            return add;
        }
        for (int appendInt : add) {
            cur = ArrayUtils.appendInt(cur, appendInt);
        }
        return cur;
    }

    private boolean canViewInstantApps(int callingUid, int userId) {
        if (callingUid < 10000 || this.mContext.checkCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS") == 0) {
            return true;
        }
        if (this.mContext.checkCallingOrSelfPermission("android.permission.VIEW_INSTANT_APPS") == 0) {
            ComponentName homeComponent = getDefaultHomeActivity(userId);
            if (homeComponent != null && isCallerSameApp(homeComponent.getPackageName(), callingUid)) {
                return true;
            }
        }
        return false;
    }

    private PackageInfo generatePackageInfo(PackageSetting ps, int flags, int userId) {
        PackageSetting packageSetting = ps;
        int i = flags;
        int i2 = userId;
        if (!sUserManager.exists(i2) || packageSetting == null) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        if (filterAppAccessLPr(packageSetting, callingUid, i2)) {
            return null;
        }
        if ((i & 8192) != 0 && ps.isSystem()) {
            i |= DumpState.DUMP_CHANGES;
        }
        int flags2 = i;
        PackageUserState state = packageSetting.readUserState(i2);
        Package p = packageSetting.pkg;
        PackageInfo packageInfo;
        if (p != null) {
            PermissionsState permissionsState = ps.getPermissionsState();
            int[] gids = (flags2 & 256) == 0 ? EMPTY_INT_ARRAY : permissionsState.computeGids(i2);
            boolean z = (flags2 & 4096) == 0 || ArrayUtils.isEmpty(p.requestedPermissions);
            Package p2 = p;
            callingUid = state;
            packageInfo = PackageParser.generatePackageInfo(p, gids, flags2, packageSetting.firstInstallTime, packageSetting.lastUpdateTime, z ? Collections.emptySet() : permissionsState.getPermissions(i2), state, i2);
            if (packageInfo == null) {
                return null;
            }
            ApplicationInfo applicationInfo = packageInfo.applicationInfo;
            String resolveExternalPackageNameLPr = resolveExternalPackageNameLPr(p2);
            applicationInfo.packageName = resolveExternalPackageNameLPr;
            packageInfo.packageName = resolveExternalPackageNameLPr;
            return packageInfo;
        }
        int i3 = callingUid;
        PackageUserState state2 = state;
        if ((flags2 & 8192) == 0 || !state2.isAvailable(flags2)) {
            return null;
        }
        packageInfo = new PackageInfo();
        packageInfo.packageName = packageSetting.name;
        packageInfo.setLongVersionCode(packageSetting.versionCode);
        packageInfo.sharedUserId = packageSetting.sharedUser != null ? packageSetting.sharedUser.name : null;
        packageInfo.firstInstallTime = packageSetting.firstInstallTime;
        packageInfo.lastUpdateTime = packageSetting.lastUpdateTime;
        ApplicationInfo ai = new ApplicationInfo();
        ai.packageName = packageSetting.name;
        ai.uid = UserHandle.getUid(i2, packageSetting.appId);
        ai.primaryCpuAbi = packageSetting.primaryCpuAbiString;
        ai.secondaryCpuAbi = packageSetting.secondaryCpuAbiString;
        ai.setVersionCode(packageSetting.versionCode);
        ai.flags = packageSetting.pkgFlags;
        ai.privateFlags = packageSetting.pkgPrivateFlags;
        packageInfo.applicationInfo = PackageParser.generateApplicationInfo(ai, flags2, state2, i2);
        if (DEBUG_PACKAGE_INFO) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("ps.pkg is n/a for [");
            stringBuilder.append(packageSetting.name);
            stringBuilder.append("]. Provides a minimum info.");
            Log.v(str, stringBuilder.toString());
        }
        return packageInfo;
    }

    public void checkPackageStartable(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null) {
            boolean userKeyUnlocked = StorageManager.isUserKeyUnlocked(userId);
            synchronized (this.mPackages) {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                StringBuilder stringBuilder;
                if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                    stringBuilder = new StringBuilder();
                    stringBuilder.append("Package ");
                    stringBuilder.append(packageName);
                    stringBuilder.append(" was not found!");
                    throw new SecurityException(stringBuilder.toString());
                } else if (ps.getInstalled(userId)) {
                    if (this.mSafeMode) {
                        if (!ps.isSystem()) {
                            stringBuilder = new StringBuilder();
                            stringBuilder.append("Package ");
                            stringBuilder.append(packageName);
                            stringBuilder.append(" not a system app!");
                            throw new SecurityException(stringBuilder.toString());
                        }
                    }
                    if (this.mFrozenPackages.contains(packageName)) {
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("Package ");
                        stringBuilder.append(packageName);
                        stringBuilder.append(" is currently frozen!");
                        throw new SecurityException(stringBuilder.toString());
                    }
                    if (!userKeyUnlocked) {
                        if (!ps.pkg.applicationInfo.isEncryptionAware()) {
                            stringBuilder = new StringBuilder();
                            stringBuilder.append("Package ");
                            stringBuilder.append(packageName);
                            stringBuilder.append(" is not encryption aware!");
                            throw new SecurityException(stringBuilder.toString());
                        }
                    }
                } else {
                    stringBuilder = new StringBuilder();
                    stringBuilder.append("Package ");
                    stringBuilder.append(packageName);
                    stringBuilder.append(" was not installed for user ");
                    stringBuilder.append(userId);
                    stringBuilder.append("!");
                    throw new SecurityException(stringBuilder.toString());
                }
            }
            return;
        }
        throw new SecurityException("Instant applications don't have access to this method");
    }

    /* JADX WARNING: Missing block: B:19:0x0041, code skipped:
            return false;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean isPackageAvailable(String packageName, int userId) {
        if (!sUserManager.exists(userId)) {
            return false;
        }
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "is package available");
        synchronized (this.mPackages) {
            Package p = (Package) this.mPackages.get(packageName);
            if (p != null) {
                PackageSetting ps = p.mExtras;
                if (filterAppAccessLPr(ps, callingUid, userId)) {
                    return false;
                } else if (ps != null) {
                    PackageUserState state = ps.readUserState(userId);
                    if (state != null) {
                        boolean isAvailable = PackageParser.isAvailable(state);
                        return isAvailable;
                    }
                }
            }
        }
    }

    public PackageInfo getPackageInfo(String packageName, int flags, int userId) {
        return getPackageInfoInternal(packageName, -1, flags, Binder.getCallingUid(), userId);
    }

    public PackageInfo getPackageInfoVersioned(VersionedPackage versionedPackage, int flags, int userId) {
        if (versionedPackage == null) {
            return null;
        }
        return getPackageInfoInternal(versionedPackage.getPackageName(), versionedPackage.getLongVersionCode(), flags, Binder.getCallingUid(), userId);
    }

    /* JADX WARNING: Missing block: B:71:0x00df, code skipped:
            return r8.mHwPMSEx.handlePackageNotFound(r9, r12, r13);
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private PackageInfo getPackageInfoInternal(String packageName, long versionCode, int flags, int filterCallingUid, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        flags = updateFlagsForPackage(flags, userId, packageName);
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get package info");
        synchronized (this.mPackages) {
            PackageInfo generatePackageInfo;
            packageName = resolveInternalPackageNameLPr(packageName, versionCode);
            boolean matchFactoryOnly = (2097152 & flags) != 0;
            if (matchFactoryOnly) {
                PackageSetting ps = this.mSettings.getDisabledSystemPkgLPr(packageName);
                if (ps != null) {
                    if (filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags)) {
                        return null;
                    } else if (filterAppAccessLPr(ps, filterCallingUid, userId)) {
                        return null;
                    } else {
                        generatePackageInfo = generatePackageInfo(ps, flags, userId);
                        return generatePackageInfo;
                    }
                }
            }
            Package p = (Package) this.mPackages.get(packageName);
            if (matchFactoryOnly && p != null && !isSystemApp(p)) {
                return null;
            } else if (isHwCustHiddenInfoPackage(p)) {
                return null;
            } else {
                if (DEBUG_PACKAGE_INFO) {
                    String str = TAG;
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("getPackageInfo ");
                    stringBuilder.append(packageName);
                    stringBuilder.append(": ");
                    stringBuilder.append(p);
                    Log.v(str, stringBuilder.toString());
                }
                PackageSetting ps2;
                if (p != null) {
                    ps2 = p.mExtras;
                    if (filterSharedLibPackageLPr(ps2, filterCallingUid, userId, flags)) {
                        return null;
                    } else if (ps2 == null || !filterAppAccessLPr(ps2, filterCallingUid, userId)) {
                        generatePackageInfo = generatePackageInfo((PackageSetting) p.mExtras, flags, userId);
                        return generatePackageInfo;
                    } else {
                        return null;
                    }
                } else if (matchFactoryOnly || (4202496 & flags) == 0) {
                } else {
                    ps2 = (PackageSetting) this.mSettings.mPackages.get(packageName);
                    if (ps2 == null) {
                        return null;
                    } else if (filterSharedLibPackageLPr(ps2, filterCallingUid, userId, flags)) {
                        return null;
                    } else if (filterAppAccessLPr(ps2, filterCallingUid, userId)) {
                        return null;
                    } else {
                        generatePackageInfo = generatePackageInfo(ps2, flags, userId);
                        return generatePackageInfo;
                    }
                }
            }
        }
    }

    private boolean isComponentVisibleToInstantApp(ComponentName component) {
        if (isComponentVisibleToInstantApp(component, 1) || isComponentVisibleToInstantApp(component, 3) || isComponentVisibleToInstantApp(component, 4)) {
            return true;
        }
        return false;
    }

    private boolean isComponentVisibleToInstantApp(ComponentName component, int type) {
        boolean z = true;
        boolean z2 = false;
        Activity activity;
        boolean visibleToInstantApp;
        boolean explicitlyVisibleToInstantApp;
        if (type == 1) {
            activity = (Activity) this.mActivities.mActivities.get(component);
            if (activity == null) {
                return false;
            }
            visibleToInstantApp = (1048576 & activity.info.flags) != 0;
            explicitlyVisibleToInstantApp = (2097152 & activity.info.flags) == 0;
            if (!(visibleToInstantApp && explicitlyVisibleToInstantApp)) {
                z = false;
            }
            return z;
        } else if (type == 2) {
            activity = (Activity) this.mReceivers.mActivities.get(component);
            if (activity == null) {
                return false;
            }
            visibleToInstantApp = (1048576 & activity.info.flags) != 0;
            explicitlyVisibleToInstantApp = (2097152 & activity.info.flags) == 0;
            if (!visibleToInstantApp || explicitlyVisibleToInstantApp) {
                z = false;
            }
            return z;
        } else if (type == 3) {
            Service service = (Service) this.mServices.mServices.get(component);
            if (!(service == null || (1048576 & service.info.flags) == 0)) {
                z2 = true;
            }
            return z2;
        } else if (type == 4) {
            Provider provider = (Provider) this.mProviders.mProviders.get(component);
            if (!(provider == null || (1048576 & provider.info.flags) == 0)) {
                z2 = true;
            }
            return z2;
        } else if (type == 0) {
            return isComponentVisibleToInstantApp(component);
        } else {
            return false;
        }
    }

    private boolean filterAppAccessLPr(PackageSetting ps, int callingUid, ComponentName component, int componentType, int userId) {
        if (Process.isIsolated(callingUid)) {
            callingUid = this.mIsolatedOwners.get(callingUid);
        }
        boolean callerIsInstantApp = getInstantAppPackageName(callingUid) != null;
        if (ps == null) {
            return callerIsInstantApp;
        } else {
            if (callerIsInstantApp) {
                if (isCallerSameApp(ps.name, callingUid)) {
                    return false;
                }
                if (ps.getInstantApp(userId)) {
                    return true;
                }
                if (component == null) {
                    return ps.pkg.visibleToInstantApps ^ 1;
                }
                Instrumentation instrumentation = (Instrumentation) this.mInstrumentation.get(component);
                if (instrumentation == null || !isCallerSameApp(instrumentation.info.targetPackage, callingUid)) {
                    return isComponentVisibleToInstantApp(component, componentType) ^ 1;
                }
                return false;
            } else if (!ps.getInstantApp(userId) || isCallerSameApp(ps.name, callingUid) || canViewInstantApps(callingUid, userId)) {
                return false;
            } else {
                if (component != null) {
                    return true;
                }
                return this.mInstantAppRegistry.isInstantAccessGranted(userId, UserHandle.getAppId(callingUid), ps.appId) ^ 1;
            }
        }
    }

    private boolean filterAppAccessLPr(PackageSetting ps, int callingUid, int userId) {
        return filterAppAccessLPr(ps, callingUid, null, 0, userId);
    }

    private boolean filterSharedLibPackageLPr(PackageSetting ps, int uid, int userId, int flags) {
        PackageSetting packageSetting = ps;
        int i;
        if ((flags & 67108864) != 0) {
            int appId = UserHandle.getAppId(uid);
            if (appId == 1000 || appId == 2000 || appId == 0) {
                i = uid;
                return false;
            } else if (checkUidPermission("android.permission.INSTALL_PACKAGES", uid) == 0) {
                return false;
            }
        }
        i = uid;
        if (packageSetting == null || packageSetting.pkg == null || !packageSetting.pkg.applicationInfo.isStaticSharedLibrary()) {
            int i2 = userId;
            return false;
        }
        SharedLibraryEntry libEntry = getSharedLibraryEntryLPr(packageSetting.pkg.staticSharedLibName, packageSetting.pkg.staticSharedLibVersion);
        if (libEntry == null) {
            return false;
        }
        String[] uidPackageNames = getPackagesForUid(UserHandle.getUid(userId, UserHandle.getAppId(uid)));
        if (uidPackageNames == null) {
            return true;
        }
        for (String uidPackageName : uidPackageNames) {
            if (packageSetting.name.equals(uidPackageName)) {
                return false;
            }
            PackageSetting uidPs = this.mSettings.getPackageLPr(uidPackageName);
            if (uidPs != null) {
                int index = ArrayUtils.indexOf(uidPs.usesStaticLibraries, libEntry.info.getName());
                if (index >= 0 && uidPs.pkg.usesStaticLibrariesVersions[index] == libEntry.info.getLongVersion()) {
                    return false;
                }
            }
        }
        return true;
    }

    public String[] currentToCanonicalPackageNames(String[] names) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return names;
        }
        String[] out = new String[names.length];
        synchronized (this.mPackages) {
            int callingUserId = UserHandle.getUserId(callingUid);
            boolean canViewInstantApps = canViewInstantApps(callingUid, callingUserId);
            int i = names.length - 1;
            while (i >= 0) {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(names[i]);
                boolean translateName = false;
                if (!(ps == null || ps.realName == null)) {
                    boolean z;
                    if (ps.getInstantApp(callingUserId) && !canViewInstantApps) {
                        if (!this.mInstantAppRegistry.isInstantAccessGranted(callingUserId, UserHandle.getAppId(callingUid), ps.appId)) {
                            z = false;
                            translateName = z;
                        }
                    }
                    z = true;
                    translateName = z;
                }
                out[i] = translateName ? ps.realName : names[i];
                i--;
            }
        }
        return out;
    }

    public String[] canonicalToCurrentPackageNames(String[] names) {
        String[] strArr = names;
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return strArr;
        }
        String[] out = new String[strArr.length];
        synchronized (this.mPackages) {
            int callingUserId = UserHandle.getUserId(callingUid);
            boolean canViewInstantApps = canViewInstantApps(callingUid, callingUserId);
            boolean z = true;
            int i = strArr.length - 1;
            while (i >= 0) {
                String cur = this.mSettings.getRenamedPackageLPr(strArr[i]);
                boolean translateName = false;
                if (cur != null) {
                    PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(strArr[i]);
                    boolean z2 = false;
                    boolean targetIsInstantApp = (ps == null || !ps.getInstantApp(callingUserId)) ? false : z;
                    if (targetIsInstantApp && !canViewInstantApps) {
                        if (!this.mInstantAppRegistry.isInstantAccessGranted(callingUserId, UserHandle.getAppId(callingUid), ps.appId)) {
                            translateName = z2;
                        }
                    }
                    z2 = true;
                    translateName = z2;
                }
                out[i] = translateName ? cur : strArr[i];
                i--;
                z = true;
            }
        }
        return out;
    }

    /* JADX WARNING: Missing block: B:29:0x006d, code skipped:
            return -1;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public int getPackageUid(String packageName, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return -1;
        }
        int callingUid = Binder.getCallingUid();
        flags = updateFlagsForPackage(flags, userId, packageName);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "getPackageUid");
        synchronized (this.mPackages) {
            Package p = (Package) this.mPackages.get(packageName);
            int uid;
            if (p == null || !p.isMatch(flags)) {
                if ((4202496 & flags) != 0) {
                    PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                    if (!(ps == null || !ps.isMatch(flags) || filterAppAccessLPr(ps, callingUid, userId))) {
                        uid = UserHandle.getUid(userId, ps.appId);
                        return uid;
                    }
                }
            } else if (filterAppAccessLPr(p.mExtras, callingUid, userId)) {
                return -1;
            } else {
                uid = UserHandle.getUid(userId, p.applicationInfo.uid);
                return uid;
            }
        }
    }

    /* JADX WARNING: Missing block: B:29:0x006f, code skipped:
            return null;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public int[] getPackageGids(String packageName, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        flags = updateFlagsForPackage(flags, userId, packageName);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "getPackageGids");
        synchronized (this.mPackages) {
            Package p = (Package) this.mPackages.get(packageName);
            PackageSetting ps;
            int[] computeGids;
            if (p != null && p.isMatch(flags)) {
                ps = p.mExtras;
                if (filterAppAccessLPr(ps, callingUid, userId)) {
                    return null;
                }
                computeGids = ps.getPermissionsState().computeGids(userId);
                return computeGids;
            } else if ((4202496 & flags) != 0) {
                ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (!(ps == null || !ps.isMatch(flags) || filterAppAccessLPr(ps, callingUid, userId))) {
                    computeGids = ps.getPermissionsState().computeGids(userId);
                    return computeGids;
                }
            }
        }
    }

    public PermissionInfo getPermissionInfo(String name, String packageName, int flags) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(BehaviorId.PACKAGEMANAGER_GETPERMISSIONINFO);
        return this.mPermissionManager.getPermissionInfo(name, packageName, flags, getCallingUid());
    }

    public ParceledListSlice<PermissionInfo> queryPermissionsByGroup(String groupName, int flags) {
        List<PermissionInfo> permissionList = this.mPermissionManager.getPermissionInfoByGroup(groupName, flags, getCallingUid());
        return permissionList == null ? null : new ParceledListSlice(permissionList);
    }

    public PermissionGroupInfo getPermissionGroupInfo(String groupName, int flags) {
        return this.mPermissionManager.getPermissionGroupInfo(groupName, flags, getCallingUid());
    }

    public ParceledListSlice<PermissionGroupInfo> getAllPermissionGroups(int flags) {
        List<PermissionGroupInfo> permissionList = this.mPermissionManager.getAllPermissionGroups(flags, getCallingUid());
        return permissionList == null ? ParceledListSlice.emptyList() : new ParceledListSlice(permissionList);
    }

    private ApplicationInfo generateApplicationInfoFromSettingsLPw(String packageName, int flags, int filterCallingUid, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
        if (ps == null || filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags) || filterAppAccessLPr(ps, filterCallingUid, userId)) {
            return null;
        }
        if (ps.pkg == null) {
            PackageInfo pInfo = generatePackageInfo(ps, flags, userId);
            if (pInfo != null) {
                return pInfo.applicationInfo;
            }
            return null;
        }
        ApplicationInfo ai = PackageParser.generateApplicationInfo(ps.pkg, flags, ps.readUserState(userId), userId);
        if (ai != null) {
            ai.packageName = resolveExternalPackageNameLPr(ps.pkg);
        }
        return ai;
    }

    public ApplicationInfo getApplicationInfo(String packageName, int flags, int userId) {
        return getApplicationInfoInternal(packageName, flags, Binder.getCallingUid(), userId);
    }

    /* JADX WARNING: Missing block: B:31:0x008a, code skipped:
            return r1;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private ApplicationInfo getApplicationInfoInternal(String packageName, int flags, int filterCallingUid, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        flags = updateFlagsForApplication(flags, userId, packageName);
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get application info");
        synchronized (this.mPackages) {
            packageName = resolveInternalPackageNameLPr(packageName, -1);
            Package p = (Package) this.mPackages.get(packageName);
            if (isHwCustHiddenInfoPackage(p)) {
                return null;
            }
            if (DEBUG_PACKAGE_INFO) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("getApplicationInfo ");
                stringBuilder.append(packageName);
                stringBuilder.append(": ");
                stringBuilder.append(p);
                Log.v(str, stringBuilder.toString());
            }
            ApplicationInfo ai;
            if (p != null) {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (ps == null) {
                    return null;
                } else if (filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags)) {
                    return null;
                } else if (filterAppAccessLPr(ps, filterCallingUid, userId)) {
                    return null;
                } else {
                    ai = PackageParser.generateApplicationInfo(p, flags, ps.readUserState(userId), userId);
                    if (ai != null) {
                        ai.packageName = resolveExternalPackageNameLPr(p);
                    }
                }
            } else {
                if (!PLATFORM_PACKAGE_NAME.equals(packageName)) {
                    if (!"system".equals(packageName)) {
                        if ((4202496 & flags) != 0) {
                            ai = generateApplicationInfoFromSettingsLPw(packageName, flags, filterCallingUid, userId);
                            return ai;
                        }
                        return null;
                    }
                }
                ai = this.mAndroidApplication;
                return ai;
            }
        }
    }

    private String normalizePackageNameLPr(String packageName) {
        String normalizedPackageName = this.mSettings.getRenamedPackageLPr(packageName);
        return normalizedPackageName != null ? normalizedPackageName : packageName;
    }

    public void deletePreloadsFileCache() {
        if (UserHandle.isSameApp(Binder.getCallingUid(), 1000)) {
            File dir = Environment.getDataPreloadsFileCacheDirectory();
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Deleting preloaded file cache ");
            stringBuilder.append(dir);
            Slog.i(str, stringBuilder.toString());
            FileUtils.deleteContents(dir);
            return;
        }
        throw new SecurityException("Only system or settings may call deletePreloadsFileCache");
    }

    public void freeStorageAndNotify(String volumeUuid, long freeStorageSize, int storageFlags, IPackageDataObserver observer) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_CACHE", null);
        this.mHandler.post(new -$$Lambda$PackageManagerService$Iz1l7RVtATr5Ybl_zHeYuCbGMvA(this, volumeUuid, freeStorageSize, storageFlags, observer));
    }

    public static /* synthetic */ void lambda$freeStorageAndNotify$1(PackageManagerService packageManagerService, String volumeUuid, long freeStorageSize, int storageFlags, IPackageDataObserver observer) {
        boolean success = false;
        try {
            packageManagerService.freeStorage(volumeUuid, freeStorageSize, storageFlags);
            success = true;
        } catch (IOException e) {
            Slog.w(TAG, e);
        }
        if (observer != null) {
            try {
                observer.onRemoveCompleted(null, success);
            } catch (RemoteException e2) {
                Slog.w(TAG, e2);
            }
        }
    }

    public void freeStorage(String volumeUuid, long freeStorageSize, int storageFlags, IntentSender pi) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_CACHE", TAG);
        this.mHandler.post(new -$$Lambda$PackageManagerService$gqdNHYJiYM0w_nIH0nGMWWU8yzQ(this, volumeUuid, freeStorageSize, storageFlags, pi));
    }

    public static /* synthetic */ void lambda$freeStorage$2(PackageManagerService packageManagerService, String volumeUuid, long freeStorageSize, int storageFlags, IntentSender pi) {
        int i = 0;
        boolean success = false;
        try {
            packageManagerService.freeStorage(volumeUuid, freeStorageSize, storageFlags);
            success = true;
        } catch (IOException e) {
            Slog.w(TAG, e);
        }
        if (pi != null) {
            if (success) {
                i = 1;
            }
            try {
                pi.sendIntent(null, i, null, null, null);
            } catch (SendIntentException e2) {
                Slog.w(TAG, e2);
            }
        }
    }

    public void freeStorage(String volumeUuid, long bytes, int storageFlags) throws IOException {
        String str = volumeUuid;
        long j = bytes;
        int i = storageFlags;
        StorageManager storage = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        File file = storage.findPathForUuid(str);
        if (file.getUsableSpace() < j) {
            if (ENABLE_FREE_CACHE_V2) {
                boolean internalVolume = Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, str);
                boolean aggressive = (i & 1) != 0;
                long reservedBytes = storage.getStorageCacheBytes(file, i);
                if (internalVolume && (aggressive || SystemProperties.getBoolean("persist.sys.preloads.file_cache_expired", false))) {
                    deletePreloadsFileCache();
                    if (file.getUsableSpace() >= j) {
                        return;
                    }
                }
                if (internalVolume && aggressive) {
                    FileUtils.deleteContents(this.mCacheDir);
                    if (file.getUsableSpace() >= j) {
                        return;
                    }
                }
                try {
                    this.mInstaller.freeCache(str, j, reservedBytes, 8192);
                } catch (InstallerException e) {
                }
                if (file.getUsableSpace() < j) {
                    if (!internalVolume || !pruneUnusedStaticSharedLibraries(j, Global.getLong(this.mContext.getContentResolver(), "unused_static_shared_lib_min_cache_period", 7200000))) {
                        if (!internalVolume || !this.mInstantAppRegistry.pruneInstalledInstantApps(j, Global.getLong(this.mContext.getContentResolver(), "installed_instant_app_min_cache_period", UnixCalendar.WEEK_IN_MILLIS))) {
                            long j2;
                            try {
                                Installer installer = this.mInstaller;
                                String str2 = str;
                                long j3 = j;
                                j2 = UnixCalendar.WEEK_IN_MILLIS;
                                try {
                                    installer.freeCache(str2, j3, reservedBytes, 24576);
                                } catch (InstallerException e2) {
                                }
                            } catch (InstallerException e3) {
                                StorageManager storageManager = storage;
                                j2 = UnixCalendar.WEEK_IN_MILLIS;
                            }
                            if (file.getUsableSpace() < j) {
                                if (internalVolume && this.mInstantAppRegistry.pruneUninstalledInstantApps(j, Global.getLong(this.mContext.getContentResolver(), "uninstalled_instant_app_min_cache_period", j2))) {
                                    return;
                                }
                            }
                            return;
                        }
                        return;
                    }
                    return;
                }
                return;
            }
            try {
                this.mInstaller.freeCache(str, j, 0, 0);
            } catch (InstallerException e4) {
            }
            if (file.getUsableSpace() >= j) {
                return;
            }
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Failed to free ");
            stringBuilder.append(j);
            stringBuilder.append(" on storage device at ");
            stringBuilder.append(file);
            throw new IOException(stringBuilder.toString());
        }
    }

    /* JADX WARNING: Missing block: B:37:0x00ce, code skipped:
            if (r13 == null) goto L_0x0103;
     */
    /* JADX WARNING: Missing block: B:38:0x00d0, code skipped:
            r0 = r13.size();
            r1 = 0;
     */
    /* JADX WARNING: Missing block: B:39:0x00d5, code skipped:
            r8 = r1;
     */
    /* JADX WARNING: Missing block: B:40:0x00d6, code skipped:
            if (r8 >= r0) goto L_0x0103;
     */
    /* JADX WARNING: Missing block: B:41:0x00d8, code skipped:
            r9 = (android.content.pm.VersionedPackage) r13.get(r8);
     */
    /* JADX WARNING: Missing block: B:42:0x00ef, code skipped:
            if (deletePackageX(r9.getPackageName(), r9.getLongVersionCode(), 0, 2) != 1) goto L_0x00fc;
     */
    /* JADX WARNING: Missing block: B:43:0x00f1, code skipped:
            r3 = r19;
     */
    /* JADX WARNING: Missing block: B:44:0x00f9, code skipped:
            if (r3.getUsableSpace() < r23) goto L_0x00fe;
     */
    /* JADX WARNING: Missing block: B:45:0x00fb, code skipped:
            return true;
     */
    /* JADX WARNING: Missing block: B:46:0x00fc, code skipped:
            r3 = r19;
     */
    /* JADX WARNING: Missing block: B:47:0x00fe, code skipped:
            r1 = r8 + 1;
            r19 = r3;
     */
    /* JADX WARNING: Missing block: B:48:0x0103, code skipped:
            r3 = r19;
     */
    /* JADX WARNING: Missing block: B:49:0x0106, code skipped:
            return false;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private boolean pruneUnusedStaticSharedLibraries(long neededSpace, long maxCachePeriod) throws IOException {
        File volume;
        Throwable th;
        List<VersionedPackage> list;
        File file;
        StorageManager storage = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        File volume2 = storage.findPathForUuid(StorageManager.UUID_PRIVATE_INTERNAL);
        long now = System.currentTimeMillis();
        synchronized (this.mPackages) {
            StorageManager storage2;
            try {
                int[] allUsers = sUserManager.getUserIds();
                int libCount = this.mSharedLibraries.size();
                List<VersionedPackage> packagesToDelete = null;
                int i = 0;
                while (i < libCount) {
                    try {
                        int libCount2;
                        LongSparseArray<SharedLibraryEntry> versionedLib = (LongSparseArray) this.mSharedLibraries.valueAt(i);
                        if (versionedLib != null) {
                            int versionCount = versionedLib.size();
                            int j = 0;
                            while (j < versionCount) {
                                SharedLibraryInfo libInfo = ((SharedLibraryEntry) versionedLib.valueAt(j)).info;
                                if (libInfo.isStatic()) {
                                    int versionCount2;
                                    VersionedPackage declaringPackage = libInfo.getDeclaringPackage();
                                    libCount2 = libCount;
                                    LongSparseArray<SharedLibraryEntry> versionedLib2 = versionedLib;
                                    libCount = resolveInternalPackageNameLPr(declaringPackage.getPackageName(), declaringPackage.getLongVersionCode());
                                    PackageSetting ps = this.mSettings.getPackageLPr(libCount);
                                    if (ps != null) {
                                        storage2 = storage;
                                        volume = volume2;
                                        try {
                                            if (now - ps.lastUpdateTime < maxCachePeriod) {
                                                versionCount2 = versionCount;
                                            } else {
                                                if (packagesToDelete == null) {
                                                    packagesToDelete = new ArrayList();
                                                }
                                                versionCount2 = versionCount;
                                                packagesToDelete.add(new VersionedPackage(libCount, declaringPackage.getLongVersionCode()));
                                            }
                                        } catch (Throwable th2) {
                                            th = th2;
                                            list = packagesToDelete;
                                            libCount = volume;
                                            while (true) {
                                                try {
                                                    break;
                                                } catch (Throwable th3) {
                                                    th = th3;
                                                }
                                            }
                                            throw th;
                                        }
                                    }
                                    versionCount2 = versionCount;
                                    storage2 = storage;
                                    volume = volume2;
                                    j++;
                                    libCount = libCount2;
                                    versionedLib = versionedLib2;
                                    storage = storage2;
                                    volume2 = volume;
                                    versionCount = versionCount2;
                                }
                            }
                            libCount2 = libCount;
                            storage2 = storage;
                            volume = volume2;
                            i++;
                            libCount = libCount2;
                            storage = storage2;
                            volume2 = volume;
                        }
                        libCount2 = libCount;
                        storage2 = storage;
                        volume = volume2;
                        i++;
                        libCount = libCount2;
                        storage = storage2;
                        volume2 = volume;
                    } catch (Throwable th4) {
                        th = th4;
                        storage2 = storage;
                        file = volume2;
                        list = packagesToDelete;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                }
                volume = volume2;
                try {
                } catch (Throwable th5) {
                    th = th5;
                    file = volume;
                    while (true) {
                        break;
                    }
                    throw th;
                }
            } catch (Throwable th6) {
                th = th6;
                storage2 = storage;
                file = volume2;
                while (true) {
                    break;
                }
                throw th;
            }
        }
    }

    private int updateFlags(int flags, int userId) {
        if ((flags & 786432) != 0) {
            return flags;
        }
        if (getUserManagerInternal().isUserUnlockingOrUnlocked(userId)) {
            return flags | 786432;
        }
        return flags | 524288;
    }

    UserManagerInternal getUserManagerInternal() {
        if (this.mUserManagerInternal == null) {
            this.mUserManagerInternal = (UserManagerInternal) LocalServices.getService(UserManagerInternal.class);
        }
        return this.mUserManagerInternal;
    }

    private ActivityManagerInternal getActivityManagerInternal() {
        if (this.mActivityManagerInternal == null) {
            this.mActivityManagerInternal = (ActivityManagerInternal) LocalServices.getService(ActivityManagerInternal.class);
        }
        return this.mActivityManagerInternal;
    }

    private LocalService getDeviceIdleController() {
        if (this.mDeviceIdleController == null) {
            this.mDeviceIdleController = (LocalService) LocalServices.getService(LocalService.class);
        }
        return this.mDeviceIdleController;
    }

    private int updateFlagsForPackage(int flags, int userId, Object cookie) {
        int flags2;
        boolean isCallerSystemUser = UserHandle.getCallingUserId() == 0;
        boolean triaged = true;
        if ((flags & 15) != 0 && (269221888 & flags) == 0) {
            triaged = false;
        }
        if ((269492224 & flags) == 0) {
            triaged = false;
        }
        if ((flags & DumpState.DUMP_CHANGES) != 0) {
            PermissionManagerInternal permissionManagerInternal = this.mPermissionManager;
            int callingUid = Binder.getCallingUid();
            int isRecentsAccessingChildProfiles = isRecentsAccessingChildProfiles(Binder.getCallingUid(), userId) ^ 1;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("MATCH_ANY_USER flag requires INTERACT_ACROSS_USERS permission at ");
            stringBuilder.append(Debug.getCallers(5));
            permissionManagerInternal.enforceCrossUserPermission(callingUid, userId, false, false, isRecentsAccessingChildProfiles, stringBuilder.toString());
        } else if ((flags & 8192) != 0 && isCallerSystemUser && sUserManager.hasManagedProfile(0)) {
            flags2 = flags | DumpState.DUMP_CHANGES;
            return updateFlags(flags2, userId);
        }
        flags2 = flags;
        return updateFlags(flags2, userId);
    }

    private int updateFlagsForApplication(int flags, int userId, Object cookie) {
        return updateFlagsForPackage(flags, userId, cookie);
    }

    private int updateFlagsForComponent(int flags, int userId, Object cookie) {
        if ((cookie instanceof Intent) && (((Intent) cookie).getFlags() & 256) != 0) {
            flags |= 268435456;
        }
        if ((269221888 & flags) == 0) {
        }
        return updateFlags(flags, userId);
    }

    private Intent updateIntentForResolve(Intent intent) {
        if (intent.getSelector() != null) {
            intent = intent.getSelector();
        }
        if (DEBUG_PREFERRED) {
            intent.addFlags(8);
        }
        return intent;
    }

    int updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid) {
        return updateFlagsForResolve(flags, userId, intent, callingUid, false, false);
    }

    int updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid, boolean wantInstantApps) {
        return updateFlagsForResolve(flags, userId, intent, callingUid, wantInstantApps, false);
    }

    int updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid, boolean wantInstantApps, boolean onlyExposedExplicitly) {
        if (this.mSafeMode) {
            flags |= 1048576;
        }
        if (getInstantAppPackageName(callingUid) != null) {
            if (onlyExposedExplicitly) {
                flags |= DumpState.DUMP_HANDLE;
            }
            flags = (flags | DumpState.DUMP_SERVICE_PERMISSIONS) | DumpState.DUMP_VOLUMES;
        } else {
            boolean allowMatchInstant = false;
            boolean wantMatchInstant = (flags & DumpState.DUMP_VOLUMES) != 0;
            if (wantInstantApps || (wantMatchInstant && canViewInstantApps(callingUid, userId))) {
                allowMatchInstant = true;
            }
            flags &= -50331649;
            if (!allowMatchInstant) {
                flags &= -8388609;
            }
        }
        return updateFlagsForComponent(flags, userId, intent);
    }

    public ActivityInfo getActivityInfo(ComponentName component, int flags, int userId) {
        return getActivityInfoInternal(component, flags, Binder.getCallingUid(), userId);
    }

    private ActivityInfo getActivityInfoInternal(ComponentName component, int flags, int filterCallingUid, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        flags = updateFlagsForComponent(flags, userId, component);
        if (!isRecentsAccessingChildProfiles(Binder.getCallingUid(), userId)) {
            this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get activity info");
        }
        synchronized (this.mPackages) {
            Activity a = (Activity) this.mActivities.mActivities.get(component);
            if (DEBUG_PACKAGE_INFO) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("getActivityInfo ");
                stringBuilder.append(component);
                stringBuilder.append(": ");
                stringBuilder.append(a);
                Log.v(str, stringBuilder.toString());
            }
            ActivityInfo generateActivityInfo;
            if (a != null && this.mSettings.isEnabledAndMatchLPr(a.info, flags, userId)) {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                } else if (filterAppAccessLPr(ps, filterCallingUid, component, 1, userId)) {
                    return null;
                } else {
                    generateActivityInfo = PackageParser.generateActivityInfo(a, flags, ps.readUserState(userId), userId);
                    return generateActivityInfo;
                }
            } else if (this.mResolveComponentName.equals(component)) {
                generateActivityInfo = PackageParser.generateActivityInfo(this.mResolveActivity, flags, new PackageUserState(), userId);
                return generateActivityInfo;
            } else {
                return null;
            }
        }
    }

    private boolean isRecentsAccessingChildProfiles(int callingUid, int targetUserId) {
        boolean z = false;
        if (!getActivityManagerInternal().isCallerRecents(callingUid)) {
            return false;
        }
        long token = Binder.clearCallingIdentity();
        try {
            int callingUserId = UserHandle.getUserId(callingUid);
            if (ActivityManager.getCurrentUser() != callingUserId) {
                return z;
            }
            z = sUserManager.isSameProfileGroup(callingUserId, targetUserId);
            Binder.restoreCallingIdentity(token);
            return z;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public boolean activitySupportsIntent(ComponentName component, Intent intent, String resolvedType) {
        ComponentName componentName = component;
        synchronized (this.mPackages) {
            if (componentName == null) {
                try {
                    return false;
                } catch (Throwable th) {
                }
            } else if (componentName.equals(this.mResolveComponentName)) {
                return true;
            } else {
                int callingUid = Binder.getCallingUid();
                int callingUserId = UserHandle.getUserId(callingUid);
                Activity a = (Activity) this.mActivities.mActivities.get(componentName);
                if (a == null) {
                    return false;
                }
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(component.getPackageName());
                if (ps == null) {
                    return false;
                } else if (filterAppAccessLPr(ps, callingUid, componentName, 1, callingUserId)) {
                    return false;
                } else {
                    for (int i = 0; i < a.intents.size(); i++) {
                        if (((ActivityIntentInfo) a.intents.get(i)).match(intent.getAction(), resolvedType, intent.getScheme(), intent.getData(), intent.getCategories(), TAG) >= 0) {
                            return true;
                        }
                    }
                    return false;
                }
            }
        }
    }

    /* JADX WARNING: Missing block: B:24:0x0088, code skipped:
            return null;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public ActivityInfo getReceiverInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        flags = updateFlagsForComponent(flags, userId, component);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get receiver info");
        synchronized (this.mPackages) {
            Activity a = (Activity) this.mReceivers.mActivities.get(component);
            if (DEBUG_PACKAGE_INFO) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("getReceiverInfo ");
                stringBuilder.append(component);
                stringBuilder.append(": ");
                stringBuilder.append(a);
                Log.v(str, stringBuilder.toString());
            }
            if (a == null || !this.mSettings.isEnabledAndMatchLPr(a.info, flags, userId)) {
            } else {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                } else if (filterAppAccessLPr(ps, callingUid, component, 2, userId)) {
                    return null;
                } else {
                    ActivityInfo generateActivityInfo = PackageParser.generateActivityInfo(a, flags, ps.readUserState(userId), userId);
                    return generateActivityInfo;
                }
            }
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:19:0x0058  */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public ParceledListSlice<SharedLibraryInfo> getSharedLibraries(String packageName, int flags, int userId) {
        PackageManagerService packageManagerService = this;
        int i = userId;
        if (!sUserManager.exists(i)) {
            return null;
        }
        Preconditions.checkArgumentNonnegative(i, "userId must be >= 0");
        if (packageManagerService.getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        boolean z;
        boolean canSeeStaticLibraries;
        ParceledListSlice<SharedLibraryInfo> parceledListSlice;
        int flags2 = packageManagerService.updateFlagsForPackage(flags, i, null);
        int i2 = 67108864;
        boolean z2 = false;
        if (packageManagerService.mContext.checkCallingOrSelfPermission("android.permission.INSTALL_PACKAGES") == 0 || packageManagerService.mContext.checkCallingOrSelfPermission("android.permission.DELETE_PACKAGES") == 0) {
            String str = packageName;
        } else if (!(packageManagerService.canRequestPackageInstallsInternal(packageName, 67108864, i, false) || packageManagerService.mContext.checkCallingOrSelfPermission("android.permission.REQUEST_DELETE_PACKAGES") == 0)) {
            z = false;
            canSeeStaticLibraries = z;
            synchronized (packageManagerService.mPackages) {
                int libCount = packageManagerService.mSharedLibraries.size();
                List<SharedLibraryInfo> result = null;
                int i3 = 0;
                while (true) {
                    int i4 = i3;
                    if (i4 < libCount) {
                        LongSparseArray<SharedLibraryEntry> versionedLib = (LongSparseArray) packageManagerService.mSharedLibraries.valueAt(i4);
                        if (versionedLib != null) {
                            int versionCount = versionedLib.size();
                            i3 = z2;
                            while (true) {
                                int j = i3;
                                if (j >= versionCount) {
                                    continue;
                                    break;
                                }
                                SharedLibraryInfo libInfo;
                                SharedLibraryInfo libInfo2 = ((SharedLibraryEntry) versionedLib.valueAt(j)).info;
                                if (!canSeeStaticLibraries) {
                                    libInfo = libInfo2;
                                    if (libInfo.isStatic()) {
                                        break;
                                    }
                                }
                                libInfo = libInfo2;
                                long identity = Binder.clearCallingIdentity();
                                try {
                                    if (packageManagerService.getPackageInfoVersioned(libInfo.getDeclaringPackage(), flags2 | i2, i) == null) {
                                        Binder.restoreCallingIdentity(identity);
                                        i3 = j + 1;
                                        packageManagerService = this;
                                        i2 = 67108864;
                                    } else {
                                        SharedLibraryInfo sharedLibraryInfo = new SharedLibraryInfo(libInfo.getName(), libInfo.getLongVersion(), libInfo.getType(), libInfo.getDeclaringPackage(), packageManagerService.getPackagesUsingSharedLibraryLPr(libInfo, flags2, i));
                                        if (result == null) {
                                            result = new ArrayList();
                                        }
                                        result.add(sharedLibraryInfo);
                                        i3 = j + 1;
                                        packageManagerService = this;
                                        i2 = 67108864;
                                    }
                                } finally {
                                    Binder.restoreCallingIdentity(identity);
                                }
                            }
                        }
                        i3 = i4 + 1;
                        packageManagerService = this;
                        i2 = 67108864;
                        z2 = false;
                    } else {
                        parceledListSlice = result != null ? new ParceledListSlice(result) : null;
                    }
                }
            }
            return parceledListSlice;
        }
        z = true;
        canSeeStaticLibraries = z;
        synchronized (packageManagerService.mPackages) {
        }
        return parceledListSlice;
    }

    private List<VersionedPackage> getPackagesUsingSharedLibraryLPr(SharedLibraryInfo libInfo, int flags, int userId) {
        List<VersionedPackage> versionedPackages = null;
        int packageCount = this.mSettings.mPackages.size();
        for (int i = 0; i < packageCount; i++) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.valueAt(i);
            if (ps != null && ((PackageUserState) ps.getUserState().get(userId)).isAvailable(flags)) {
                String libName = libInfo.getName();
                if (libInfo.isStatic()) {
                    int libIdx = ArrayUtils.indexOf(ps.usesStaticLibraries, libName);
                    if (libIdx >= 0 && ps.usesStaticLibrariesVersions[libIdx] == libInfo.getLongVersion()) {
                        if (versionedPackages == null) {
                            versionedPackages = new ArrayList();
                        }
                        String dependentPackageName = ps.name;
                        if (ps.pkg != null && ps.pkg.applicationInfo.isStaticSharedLibrary()) {
                            dependentPackageName = ps.pkg.manifestPackageName;
                        }
                        versionedPackages.add(new VersionedPackage(dependentPackageName, ps.versionCode));
                    }
                } else if (ps.pkg != null && (ArrayUtils.contains(ps.pkg.usesLibraries, libName) || ArrayUtils.contains(ps.pkg.usesOptionalLibraries, libName))) {
                    if (versionedPackages == null) {
                        versionedPackages = new ArrayList();
                    }
                    versionedPackages.add(new VersionedPackage(ps.name, ps.versionCode));
                }
            }
        }
        return versionedPackages;
    }

    /* JADX WARNING: Missing block: B:24:0x0088, code skipped:
            return null;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public ServiceInfo getServiceInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        flags = updateFlagsForComponent(flags, userId, component);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get service info");
        synchronized (this.mPackages) {
            Service s = (Service) this.mServices.mServices.get(component);
            if (DEBUG_PACKAGE_INFO) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("getServiceInfo ");
                stringBuilder.append(component);
                stringBuilder.append(": ");
                stringBuilder.append(s);
                Log.v(str, stringBuilder.toString());
            }
            if (s == null || !this.mSettings.isEnabledAndMatchLPr(s.info, flags, userId)) {
            } else {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                } else if (filterAppAccessLPr(ps, callingUid, component, 3, userId)) {
                    return null;
                } else {
                    ServiceInfo generateServiceInfo = PackageParser.generateServiceInfo(s, flags, ps.readUserState(userId), userId);
                    return generateServiceInfo;
                }
            }
        }
    }

    /* JADX WARNING: Missing block: B:24:0x0088, code skipped:
            return null;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public ProviderInfo getProviderInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        flags = updateFlagsForComponent(flags, userId, component);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get provider info");
        synchronized (this.mPackages) {
            Provider p = (Provider) this.mProviders.mProviders.get(component);
            if (DEBUG_PACKAGE_INFO) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("getProviderInfo ");
                stringBuilder.append(component);
                stringBuilder.append(": ");
                stringBuilder.append(p);
                Log.v(str, stringBuilder.toString());
            }
            if (p == null || !this.mSettings.isEnabledAndMatchLPr(p.info, flags, userId)) {
            } else {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                } else if (filterAppAccessLPr(ps, callingUid, component, 4, userId)) {
                    return null;
                } else {
                    ProviderInfo generateProviderInfo = PackageParser.generateProviderInfo(p, flags, ps.readUserState(userId), userId);
                    return generateProviderInfo;
                }
            }
        }
    }

    public String[] getSystemSharedLibraryNames() {
        synchronized (this.mPackages) {
            int libCount = this.mSharedLibraries.size();
            Set<String> libs = null;
            for (int i = 0; i < libCount; i++) {
                LongSparseArray<SharedLibraryEntry> versionedLib = (LongSparseArray) this.mSharedLibraries.valueAt(i);
                if (versionedLib != null) {
                    int versionCount = versionedLib.size();
                    int j = 0;
                    while (j < versionCount) {
                        SharedLibraryEntry libEntry = (SharedLibraryEntry) versionedLib.valueAt(j);
                        if (libEntry.info.isStatic()) {
                            PackageSetting ps = this.mSettings.getPackageLPr(libEntry.apk);
                            if (ps == null || filterSharedLibPackageLPr(ps, Binder.getCallingUid(), UserHandle.getUserId(Binder.getCallingUid()), 67108864)) {
                                j++;
                            } else {
                                if (libs == null) {
                                    libs = new ArraySet();
                                }
                                libs.add(libEntry.info.getName());
                            }
                        } else {
                            if (libs == null) {
                                libs = new ArraySet();
                            }
                            libs.add(libEntry.info.getName());
                        }
                    }
                }
            }
            if (libs != null) {
                String[] libsArray = new String[libs.size()];
                libs.toArray(libsArray);
                return libsArray;
            }
            return null;
        }
    }

    public String getServicesSystemSharedLibraryPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mServicesSystemSharedLibraryPackageName;
        }
        return str;
    }

    public String getSharedSystemSharedLibraryPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mSharedSystemSharedLibraryPackageName;
        }
        return str;
    }

    private void updateSequenceNumberLP(PackageSetting pkgSetting, int[] userList) {
        for (int i = userList.length - 1; i >= 0; i--) {
            int userId = userList[i];
            if (!pkgSetting.getInstantApp(userId)) {
                SparseArray<String> changedPackages = (SparseArray) this.mChangedPackages.get(userId);
                if (changedPackages == null) {
                    changedPackages = new SparseArray();
                    this.mChangedPackages.put(userId, changedPackages);
                }
                Map<String, Integer> sequenceNumbers = (Map) this.mChangedPackagesSequenceNumbers.get(userId);
                if (sequenceNumbers == null) {
                    sequenceNumbers = new HashMap();
                    this.mChangedPackagesSequenceNumbers.put(userId, sequenceNumbers);
                }
                Integer sequenceNumber = (Integer) sequenceNumbers.get(pkgSetting.name);
                if (sequenceNumber != null) {
                    changedPackages.remove(sequenceNumber.intValue());
                }
                changedPackages.put(this.mChangedPackagesSequenceNumber, pkgSetting.name);
                sequenceNumbers.put(pkgSetting.name, Integer.valueOf(this.mChangedPackagesSequenceNumber));
            }
        }
        this.mChangedPackagesSequenceNumber++;
    }

    /* JADX WARNING: Missing block: B:26:0x004b, code skipped:
            return r1;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public ChangedPackages getChangedPackages(int sequenceNumber, int userId) {
        ChangedPackages changedPackages = null;
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            if (sequenceNumber >= this.mChangedPackagesSequenceNumber) {
                return null;
            }
            SparseArray<String> changedPackages2 = (SparseArray) this.mChangedPackages.get(userId);
            if (changedPackages2 == null) {
                return null;
            }
            List<String> packageNames = new ArrayList(this.mChangedPackagesSequenceNumber - sequenceNumber);
            for (int i = sequenceNumber; i < this.mChangedPackagesSequenceNumber; i++) {
                String packageName = (String) changedPackages2.get(i);
                if (packageName != null) {
                    packageNames.add(packageName);
                }
            }
            if (!packageNames.isEmpty()) {
                changedPackages = new ChangedPackages(this.mChangedPackagesSequenceNumber, packageNames);
            }
        }
    }

    public ParceledListSlice<FeatureInfo> getSystemAvailableFeatures() {
        ArrayList<FeatureInfo> res;
        synchronized (this.mAvailableFeatures) {
            res = new ArrayList(this.mAvailableFeatures.size() + 1);
            res.addAll(this.mAvailableFeatures.values());
        }
        FeatureInfo fi = new FeatureInfo();
        fi.reqGlEsVersion = SystemProperties.getInt("ro.opengles.version", 0);
        res.add(fi);
        return new ParceledListSlice(res);
    }

    /* JADX WARNING: Missing block: B:11:0x0017, code skipped:
            return r2;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean hasSystemFeature(String name, int version) {
        synchronized (this.mAvailableFeatures) {
            FeatureInfo feat = (FeatureInfo) this.mAvailableFeatures.get(name);
            boolean z = false;
            if (feat == null) {
                return false;
            } else if (feat.version >= version) {
                z = true;
            }
        }
    }

    public int checkPermission(String permName, String pkgName, int userId) {
        return this.mPermissionManager.checkPermission(permName, pkgName, getCallingUid(), userId);
    }

    public int checkUidPermission(String permName, int uid) {
        int checkUidPermission;
        synchronized (this.mPackages) {
            Package pkg;
            String[] packageNames = getPackagesForUid(uid);
            if (packageNames == null || packageNames.length <= 0) {
                pkg = null;
            } else {
                pkg = (Package) this.mPackages.get(packageNames[0]);
            }
            checkUidPermission = this.mPermissionManager.checkUidPermission(permName, pkg, uid, getCallingUid());
        }
        return checkUidPermission;
    }

    public boolean isPermissionRevokedByPolicy(String permission, String packageName, int userId) {
        if (UserHandle.getCallingUserId() != userId) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("isPermissionRevokedByPolicy for user ");
            stringBuilder.append(userId);
            this.mContext.enforceCallingPermission("android.permission.INTERACT_ACROSS_USERS_FULL", stringBuilder.toString());
        }
        boolean z = false;
        if (checkPermission(permission, packageName, userId) == 0) {
            return false;
        }
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            if (!isCallerSameApp(packageName, callingUid)) {
                return false;
            }
        } else if (isInstantApp(packageName, userId)) {
            return false;
        }
        long identity = Binder.clearCallingIdentity();
        try {
            if ((getPermissionFlags(permission, packageName, userId) & 4) != 0) {
                z = true;
            }
            Binder.restoreCallingIdentity(identity);
            return z;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(identity);
        }
    }

    public String getPermissionControllerPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mRequiredInstallerPackage;
        }
        return str;
    }

    private boolean addDynamicPermission(PermissionInfo info, final boolean async) {
        return this.mPermissionManager.addDynamicPermission(info, async, getCallingUid(), new PermissionCallback() {
            public void onPermissionChanged() {
                if (async) {
                    PackageManagerService.this.scheduleWriteSettingsLocked();
                } else {
                    PackageManagerService.this.mSettings.writeLPr();
                }
            }
        });
    }

    public boolean addPermission(PermissionInfo info) {
        boolean addDynamicPermission;
        synchronized (this.mPackages) {
            addDynamicPermission = addDynamicPermission(info, false);
        }
        return addDynamicPermission;
    }

    public boolean addPermissionAsync(PermissionInfo info) {
        boolean addDynamicPermission;
        synchronized (this.mPackages) {
            addDynamicPermission = addDynamicPermission(info, true);
        }
        return addDynamicPermission;
    }

    public void removePermission(String permName) {
        this.mPermissionManager.removeDynamicPermission(permName, getCallingUid(), this.mPermissionCallback);
    }

    public void grantRuntimePermission(String packageName, String permName, int userId) {
        this.mPermissionManager.grantRuntimePermission(permName, packageName, false, getCallingUid(), userId, this.mPermissionCallback);
    }

    public void revokeRuntimePermission(String packageName, String permName, int userId) {
        this.mPermissionManager.revokeRuntimePermission(permName, packageName, false, getCallingUid(), userId, this.mPermissionCallback);
    }

    public void resetRuntimePermissions() {
        this.mContext.enforceCallingOrSelfPermission("android.permission.REVOKE_RUNTIME_PERMISSIONS", "revokeRuntimePermission");
        int callingUid = Binder.getCallingUid();
        if (!(callingUid == 1000 || callingUid == 0)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "resetRuntimePermissions");
        }
        synchronized (this.mPackages) {
            this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, false, this.mPackages.values(), this.mPermissionCallback);
            for (int userId : UserManagerService.getInstance().getUserIds()) {
                int packageCount = this.mPackages.size();
                for (int i = 0; i < packageCount; i++) {
                    Package pkg = (Package) this.mPackages.valueAt(i);
                    if (pkg.mExtras instanceof PackageSetting) {
                        resetUserChangesToRuntimePermissionsAndFlagsLPw(pkg.mExtras, userId);
                    }
                }
            }
        }
    }

    public int getPermissionFlags(String permName, String packageName, int userId) {
        return this.mPermissionManager.getPermissionFlags(permName, packageName, getCallingUid(), userId);
    }

    public void updatePermissionFlags(String permName, String packageName, int flagMask, int flagValues, int userId) {
        this.mPermissionManager.updatePermissionFlags(permName, packageName, flagMask, flagValues, getCallingUid(), userId, this.mPermissionCallback);
    }

    public void updatePermissionFlagsForAllApps(int flagMask, int flagValues, int userId) {
        synchronized (this.mPackages) {
            if (this.mPermissionManager.updatePermissionFlagsForAllApps(flagMask, flagValues, getCallingUid(), userId, this.mPackages.values(), this.mPermissionCallback)) {
                this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
            }
        }
    }

    public boolean shouldShowRequestPermissionRationale(String permissionName, String packageName, int userId) {
        if (UserHandle.getCallingUserId() != userId) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("canShowRequestPermissionRationale for user ");
            stringBuilder.append(userId);
            this.mContext.enforceCallingPermission("android.permission.INTERACT_ACROSS_USERS_FULL", stringBuilder.toString());
        }
        boolean z = false;
        if (UserHandle.getAppId(getCallingUid()) != UserHandle.getAppId(getPackageUid(packageName, 268435456, userId)) || checkPermission(permissionName, packageName, userId) == 0) {
            return false;
        }
        long identity = Binder.clearCallingIdentity();
        try {
            int flags = getPermissionFlags(permissionName, packageName, userId);
            if ((flags & 22) != 0) {
                return false;
            }
            if ((flags & 1) != 0) {
                z = true;
            }
            return z;
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    public void addOnPermissionsChangeListener(IOnPermissionsChangeListener listener) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.OBSERVE_GRANT_REVOKE_PERMISSIONS", "addOnPermissionsChangeListener");
        synchronized (this.mPackages) {
            this.mOnPermissionChangeListeners.addListenerLocked(listener);
        }
    }

    public void removeOnPermissionsChangeListener(IOnPermissionsChangeListener listener) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            synchronized (this.mPackages) {
                this.mOnPermissionChangeListeners.removeListenerLocked(listener);
            }
            return;
        }
        throw new SecurityException("Instant applications don't have access to this method");
    }

    /* JADX WARNING: Missing block: B:17:0x0031, code skipped:
            return true;
     */
    /* JADX WARNING: Missing block: B:20:0x0034, code skipped:
            return false;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean isProtectedBroadcast(String actionName) {
        synchronized (this.mProtectedBroadcasts) {
            if (this.mProtectedBroadcasts.contains(actionName)) {
                return true;
            } else if (actionName == null || !(actionName.startsWith("android.net.netmon.lingerExpired") || actionName.startsWith("com.android.server.sip.SipWakeupTimer") || actionName.startsWith("com.android.internal.telephony.data-reconnect") || actionName.startsWith("android.net.netmon.launchCaptivePortalApp"))) {
            }
        }
    }

    /* JADX WARNING: Missing block: B:20:0x004d, code skipped:
            return -4;
     */
    /* JADX WARNING: Missing block: B:22:0x004f, code skipped:
            return -4;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public int checkSignatures(String pkg1, String pkg2) {
        synchronized (this.mPackages) {
            Package p1 = (Package) this.mPackages.get(pkg1);
            Package p2 = (Package) this.mPackages.get(pkg2);
            if (!(p1 == null || p1.mExtras == null || p2 == null)) {
                if (p2.mExtras != null) {
                    int callingUid = Binder.getCallingUid();
                    int callingUserId = UserHandle.getUserId(callingUid);
                    PackageSetting ps2 = p2.mExtras;
                    if (!filterAppAccessLPr(p1.mExtras, callingUid, callingUserId)) {
                        if (!filterAppAccessLPr(ps2, callingUid, callingUserId)) {
                            int compareSignatures = PackageManagerServiceUtils.compareSignatures(p1.mSigningDetails.signatures, p2.mSigningDetails.signatures);
                            return compareSignatures;
                        }
                    }
                }
            }
        }
    }

    public int checkUidSignatures(int uid1, int uid2) {
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
        uid1 = UserHandle.getAppId(uid1);
        uid2 = UserHandle.getAppId(uid2);
        synchronized (this.mPackages) {
            PackageSetting obj = this.mSettings.getUserIdLPr(uid1);
            if (obj != null) {
                Signature[] s1;
                if (obj instanceof SharedUserSetting) {
                    if (isCallerInstantApp) {
                        return -4;
                    }
                    s1 = ((SharedUserSetting) obj).signatures.mSigningDetails.signatures;
                } else if (obj instanceof PackageSetting) {
                    PackageSetting ps = obj;
                    if (filterAppAccessLPr(ps, callingUid, callingUserId)) {
                        return -4;
                    }
                    s1 = ps.signatures.mSigningDetails.signatures;
                } else {
                    return -4;
                }
                obj = this.mSettings.getUserIdLPr(uid2);
                if (obj != null) {
                    Signature[] s2;
                    if (obj instanceof SharedUserSetting) {
                        if (isCallerInstantApp) {
                            return -4;
                        }
                        s2 = ((SharedUserSetting) obj).signatures.mSigningDetails.signatures;
                    } else if (obj instanceof PackageSetting) {
                        PackageSetting ps2 = obj;
                        if (filterAppAccessLPr(ps2, callingUid, callingUserId)) {
                            return -4;
                        }
                        s2 = ps2.signatures.mSigningDetails.signatures;
                    } else {
                        return -4;
                    }
                    int compareSignatures = PackageManagerServiceUtils.compareSignatures(s1, s2);
                    return compareSignatures;
                }
                return -4;
            }
            return -4;
        }
    }

    /* JADX WARNING: Missing block: B:23:0x003e, code skipped:
            return false;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean hasSigningCertificate(String packageName, byte[] certificate, int type) {
        synchronized (this.mPackages) {
            Package p = (Package) this.mPackages.get(packageName);
            if (p != null) {
                if (p.mExtras != null) {
                    int callingUid = Binder.getCallingUid();
                    if (filterAppAccessLPr(p.mExtras, callingUid, UserHandle.getUserId(callingUid))) {
                        return false;
                    }
                    boolean hasCertificate;
                    switch (type) {
                        case 0:
                            hasCertificate = p.mSigningDetails.hasCertificate(certificate);
                            return hasCertificate;
                        case 1:
                            hasCertificate = p.mSigningDetails.hasSha256Certificate(certificate);
                            return hasCertificate;
                        default:
                            return false;
                    }
                }
            }
        }
    }

    public boolean hasUidSigningCertificate(int uid, byte[] certificate, int type) {
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        uid = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            PackageSetting obj = this.mSettings.getUserIdLPr(uid);
            if (obj != null) {
                SigningDetails signingDetails;
                if (obj instanceof SharedUserSetting) {
                    if (getInstantAppPackageName(callingUid) != null) {
                        return false;
                    }
                    signingDetails = ((SharedUserSetting) obj).signatures.mSigningDetails;
                } else if (obj instanceof PackageSetting) {
                    PackageSetting ps = obj;
                    if (filterAppAccessLPr(ps, callingUid, callingUserId)) {
                        return false;
                    }
                    signingDetails = ps.signatures.mSigningDetails;
                } else {
                    return false;
                }
                boolean hasCertificate;
                switch (type) {
                    case 0:
                        hasCertificate = signingDetails.hasCertificate(certificate);
                        return hasCertificate;
                    case 1:
                        hasCertificate = signingDetails.hasSha256Certificate(certificate);
                        return hasCertificate;
                    default:
                        return false;
                }
            }
            return false;
        }
    }

    private void killUid(int appId, int userId, String reason) {
        long identity = Binder.clearCallingIdentity();
        try {
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                try {
                    am.killUid(appId, userId, reason);
                } catch (RemoteException e) {
                }
            }
            Binder.restoreCallingIdentity(identity);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(identity);
        }
    }

    private boolean isCompatSignatureUpdateNeeded(Package scannedPkg) {
        return getSettingsVersionForPackage(scannedPkg).databaseVersion < 2;
    }

    private boolean isRecoverSignatureUpdateNeeded(Package scannedPkg) {
        return getSettingsVersionForPackage(scannedPkg).databaseVersion < 3;
    }

    /* JADX WARNING: Missing block: B:32:0x0088, code skipped:
            return r4;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public List<String> getAllPackages() {
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        synchronized (this.mPackages) {
            if (canViewInstantApps(callingUid, callingUserId)) {
                ArrayList arrayList = new ArrayList(this.mPackages.keySet());
                return arrayList;
            }
            String instantAppPkgName = getInstantAppPackageName(callingUid);
            List<String> result = new ArrayList();
            if (instantAppPkgName != null) {
                for (Package pkg : this.mPackages.values()) {
                    if (pkg.visibleToInstantApps) {
                        result.add(pkg.packageName);
                    }
                }
            } else {
                for (Package pkg2 : this.mPackages.values()) {
                    PackageSetting ps = pkg2.mExtras != null ? (PackageSetting) pkg2.mExtras : null;
                    if (ps == null || !ps.getInstantApp(callingUserId) || this.mInstantAppRegistry.isInstantAccessGranted(callingUserId, UserHandle.getAppId(callingUid), ps.appId)) {
                        result.add(pkg2.packageName);
                    }
                }
            }
        }
    }

    /* JADX WARNING: Missing block: B:40:0x00e8, code skipped:
            return null;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public String[] getPackagesForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        int i = 0;
        boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
        int userId = UserHandle.getUserId(uid);
        int uid2 = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            SettingBase obj = this.mSettings.getUserIdLPr(uid2);
            if (obj instanceof SharedUserSetting) {
                if (isCallerInstantApp) {
                    return null;
                }
                SharedUserSetting sus;
                SharedUserSetting sus2 = (SharedUserSetting) obj;
                String[] res = new String[sus2.packages.size()];
                Iterator<PackageSetting> it = sus2.packages.iterator();
                while (it.hasNext()) {
                    PackageSetting ps = (PackageSetting) it.next();
                    if (this.mIsUpgrade) {
                        PackageSetting psNow = (PackageSetting) this.mSettings.mPackages.get(ps.name);
                        if (!(psNow == null || psNow.appId == ps.appId)) {
                            res = (String[]) ArrayUtils.removeElement(String.class, res, res[i]);
                            StringBuilder sbWarn = new StringBuilder();
                            sbWarn.append("getPackagesForUid ");
                            sbWarn.append(uid2);
                            sbWarn.append(" warning, found package ");
                            sbWarn.append(ps.name);
                            sbWarn.append(" was user id ");
                            sbWarn.append(ps.appId);
                            sbWarn.append(", but mismatch ");
                            sbWarn.append(psNow.appId);
                            sbWarn.append(" now!");
                            sus = sus2;
                            Slog.w(TAG, sbWarn.toString());
                            sus2 = sus;
                        }
                    }
                    sus = sus2;
                    if (ps.getInstalled(userId)) {
                        int i2 = i + 1;
                        res[i] = ps.name;
                        i = i2;
                    } else {
                        res = (String[]) ArrayUtils.removeElement(String.class, res, res[i]);
                    }
                    sus2 = sus;
                }
                sus = sus2;
                return res;
            } else if (obj instanceof PackageSetting) {
                PackageSetting ps2 = (PackageSetting) obj;
                if (ps2.getInstalled(userId) && !filterAppAccessLPr(ps2, callingUid, userId)) {
                    String[] strArr = new String[]{ps2.name};
                    return strArr;
                }
            }
        }
    }

    public String getNameForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            SettingBase obj = this.mSettings.getUserIdLPr(UserHandle.getAppId(uid));
            if (obj instanceof SharedUserSetting) {
                SharedUserSetting sus = (SharedUserSetting) obj;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(sus.name);
                stringBuilder.append(":");
                stringBuilder.append(sus.userId);
                String stringBuilder2 = stringBuilder.toString();
                return stringBuilder2;
            } else if (obj instanceof PackageSetting) {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return null;
                }
                String str = ps.name;
                return str;
            } else {
                return null;
            }
        }
    }

    public String[] getNamesForUids(int[] uids) {
        if (uids == null || uids.length == 0) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return null;
        }
        String[] names = new String[uids.length];
        synchronized (this.mPackages) {
            for (int i = uids.length - 1; i >= 0; i--) {
                SettingBase obj = this.mSettings.getUserIdLPr(UserHandle.getAppId(uids[i]));
                if (obj instanceof SharedUserSetting) {
                    SharedUserSetting sus = (SharedUserSetting) obj;
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("shared:");
                    stringBuilder.append(sus.name);
                    names[i] = stringBuilder.toString();
                } else if (obj instanceof PackageSetting) {
                    PackageSetting ps = (PackageSetting) obj;
                    if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                        names[i] = null;
                    } else {
                        names[i] = ps.name;
                    }
                } else {
                    names[i] = null;
                }
            }
        }
        return names;
    }

    public int getUidForSharedUser(String sharedUserName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null || sharedUserName == null) {
            return -1;
        }
        synchronized (this.mPackages) {
            try {
                SharedUserSetting suid = this.mSettings.getSharedUserLPw(sharedUserName, 0, 0, false);
                if (suid != null) {
                    int i = suid.userId;
                    return i;
                }
            } catch (PackageManagerException e) {
            } catch (Throwable th) {
            }
        }
        return -1;
    }

    public int getFlagsForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return 0;
        }
        synchronized (this.mPackages) {
            SettingBase obj = this.mSettings.getUserIdLPr(UserHandle.getAppId(uid));
            if (obj instanceof SharedUserSetting) {
                int i = ((SharedUserSetting) obj).pkgFlags;
                return i;
            } else if (obj instanceof PackageSetting) {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return 0;
                }
                int i2 = ps.pkgFlags;
                return i2;
            } else {
                return 0;
            }
        }
    }

    public int getPrivateFlagsForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return 0;
        }
        synchronized (this.mPackages) {
            SettingBase obj = this.mSettings.getUserIdLPr(UserHandle.getAppId(uid));
            if (obj instanceof SharedUserSetting) {
                int i = ((SharedUserSetting) obj).pkgPrivateFlags;
                return i;
            } else if (obj instanceof PackageSetting) {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return 0;
                }
                int i2 = ps.pkgPrivateFlags;
                return i2;
            } else {
                return 0;
            }
        }
    }

    /* JADX WARNING: Missing block: B:23:0x004a, code skipped:
            return false;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean isUidPrivileged(int uid) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return false;
        }
        uid = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            SettingBase obj = this.mSettings.getUserIdLPr(uid);
            if (obj instanceof SharedUserSetting) {
                Iterator<PackageSetting> it = ((SharedUserSetting) obj).packages.iterator();
                while (it.hasNext()) {
                    if (((PackageSetting) it.next()).isPrivileged()) {
                        return true;
                    }
                }
            } else if (obj instanceof PackageSetting) {
                boolean isPrivileged = ((PackageSetting) obj).isPrivileged();
                return isPrivileged;
            }
        }
    }

    public String[] getAppOpPermissionPackages(String permName) {
        return this.mPermissionManager.getAppOpPermissionPackages(permName);
    }

    public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId) {
        return resolveIntentInternal(intent, resolvedType, flags, userId, false, Binder.getCallingUid());
    }

    private ResolveInfo resolveIntentInternal(Intent intent, String resolvedType, int flags, int userId, boolean resolveForStart, int filterCallingUid) {
        Throwable th;
        int flags2;
        try {
            Trace.traceBegin(262144, "resolveIntent");
            int i = userId;
            if (sUserManager.exists(i)) {
                int callingUid = Binder.getCallingUid();
                flags2 = updateFlagsForResolve(flags, i, intent, filterCallingUid, resolveForStart);
                try {
                    this.mPermissionManager.enforceCrossUserPermission(callingUid, i, false, false, "resolve intent");
                    Trace.traceBegin(262144, "queryIntentActivities");
                    List<ResolveInfo> query = queryIntentActivitiesInternal(intent, resolvedType, flags2, filterCallingUid, i, resolveForStart, true);
                    Trace.traceEnd(262144);
                    ResolveInfo bestChoice = chooseBestActivity(intent, resolvedType, flags2, query, userId);
                    if (!(bestChoice == null || query == null || query.size() <= 1)) {
                        String str = TAG;
                        StringBuilder stringBuilder = new StringBuilder();
                        stringBuilder.append("resolve intent for uid:");
                        stringBuilder.append(callingUid);
                        stringBuilder.append(", matchs:");
                        stringBuilder.append(query.size());
                        stringBuilder.append(", res:");
                        stringBuilder.append(bestChoice);
                        Slog.d(str, stringBuilder.toString());
                    }
                    Trace.traceEnd(262144);
                    return bestChoice;
                } catch (Throwable th2) {
                    th = th2;
                    Trace.traceEnd(262144);
                    throw th;
                }
            }
            Trace.traceEnd(262144);
            return null;
        } catch (Throwable th3) {
            th = th3;
            flags2 = flags;
            Trace.traceEnd(262144);
            throw th;
        }
    }

    public ResolveInfo findPersistentPreferredActivity(Intent intent, int userId) {
        if (!UserHandle.isSameApp(Binder.getCallingUid(), 1000)) {
            throw new SecurityException("findPersistentPreferredActivity can only be run by the system");
        } else if (!sUserManager.exists(userId)) {
            return null;
        } else {
            ResolveInfo findPersistentPreferredActivityLP;
            int callingUid = Binder.getCallingUid();
            Intent intent2 = updateIntentForResolve(intent);
            String resolvedType = intent2.resolveTypeIfNeeded(this.mContext.getContentResolver());
            int flags = updateFlagsForResolve(0, userId, intent2, callingUid, false);
            List<ResolveInfo> query = queryIntentActivitiesInternal(intent2, resolvedType, flags, userId);
            synchronized (this.mPackages) {
                findPersistentPreferredActivityLP = findPersistentPreferredActivityLP(intent2, resolvedType, flags, query, false, userId);
            }
            return findPersistentPreferredActivityLP;
        }
    }

    public void setLastChosenActivity(Intent intent, String resolvedType, int flags, IntentFilter filter, int match, ComponentName activity) {
        Intent intent2 = intent;
        String str = resolvedType;
        int i = flags;
        IntentFilter intentFilter = filter;
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            int userId = UserHandle.getCallingUserId();
            if (DEBUG_PREFERRED) {
                String str2 = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("setLastChosenActivity intent=");
                stringBuilder.append(intent2);
                stringBuilder.append(" resolvedType=");
                stringBuilder.append(str);
                stringBuilder.append(" flags=");
                stringBuilder.append(i);
                stringBuilder.append(" filter=");
                stringBuilder.append(intentFilter);
                stringBuilder.append(" match=");
                stringBuilder.append(match);
                stringBuilder.append(" activity=");
                stringBuilder.append(activity);
                Log.v(str2, stringBuilder.toString());
                intentFilter.dump(new PrintStreamPrinter(System.out), "    ");
            } else {
                int i2 = match;
                ComponentName componentName = activity;
            }
            intent2.setComponent(null);
            findPreferredActivity(intent2, str, i, queryIntentActivitiesInternal(intent2, str, i, userId), 0, false, true, false, userId);
            addPreferredActivityInternal(intentFilter, match, null, activity, false, userId, "Setting last chosen");
        }
    }

    public ResolveInfo getLastChosenActivity(Intent intent, String resolvedType, int flags) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        int userId = UserHandle.getCallingUserId();
        if (DEBUG_PREFERRED) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Querying last chosen activity for ");
            stringBuilder.append(intent);
            Log.v(str, stringBuilder.toString());
        }
        return findPreferredActivity(intent, resolvedType, flags, queryIntentActivitiesInternal(intent, resolvedType, flags, userId), 0, false, false, false, userId);
    }

    private boolean areWebInstantAppsDisabled() {
        return this.mWebInstantAppsDisabled;
    }

    /* JADX WARNING: Missing block: B:52:0x00b9, code skipped:
            return false;
     */
    /* JADX WARNING: Missing block: B:60:0x00dc, code skipped:
            return false;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private boolean isInstantAppResolutionAllowed(Intent intent, List<ResolveInfo> resolvedActivities, int userId, boolean skipPackageCheck) {
        List<ResolveInfo> list = resolvedActivities;
        int i = userId;
        if (this.mInstantAppResolverConnection == null || this.mInstantAppInstallerActivity == null || intent.getComponent() != null || (intent.getFlags() & 512) != 0) {
            return false;
        }
        if (!skipPackageCheck && intent.getPackage() != null) {
            return false;
        }
        if (intent.isWebIntent()) {
            if (intent.getData() == null || TextUtils.isEmpty(intent.getData().getHost())) {
                return false;
            }
            if (areWebInstantAppsDisabled()) {
                return false;
            }
        } else if (!(list == null || resolvedActivities.size() == 0) || (intent.getFlags() & 2048) == 0) {
            return false;
        }
        synchronized (this.mPackages) {
            int count = list == null ? 0 : resolvedActivities.size();
            for (int n = 0; n < count; n++) {
                ResolveInfo info = (ResolveInfo) list.get(n);
                String packageName = info.activityInfo.packageName;
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (ps != null) {
                    if (!info.handleAllWebDataURI) {
                        int status = (int) (getDomainVerificationStatusLPr(ps, i) >> 32);
                        if (status == 2 || status == 4) {
                            if (DEBUG_INSTANT) {
                                String str = TAG;
                                StringBuilder stringBuilder = new StringBuilder();
                                stringBuilder.append("DENY instant app; pkg: ");
                                stringBuilder.append(packageName);
                                stringBuilder.append(", status: ");
                                stringBuilder.append(status);
                                Slog.v(str, stringBuilder.toString());
                            }
                        }
                    }
                    if (ps.getInstantApp(i)) {
                        if (DEBUG_INSTANT) {
                            String str2 = TAG;
                            StringBuilder stringBuilder2 = new StringBuilder();
                            stringBuilder2.append("DENY instant app installed; pkg: ");
                            stringBuilder2.append(packageName);
                            Slog.v(str2, stringBuilder2.toString());
                        }
                    }
                }
            }
            return true;
        }
    }

    private void requestInstantAppResolutionPhaseTwo(AuxiliaryResolveInfo responseObj, Intent origIntent, String resolvedType, String callingPackage, Bundle verificationBundle, int userId) {
        this.mHandler.sendMessage(this.mHandler.obtainMessage(20, new InstantAppRequest(responseObj, origIntent, resolvedType, callingPackage, userId, verificationBundle, false)));
    }

    private ResolveInfo chooseBestActivity(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, int userId) {
        List<ResolveInfo> list = query;
        int i = userId;
        if (list != null) {
            int N = query.size();
            if (N == 1) {
                return (ResolveInfo) list.get(0);
            }
            if (N > 1) {
                boolean debug = (intent.getFlags() & 8) != 0;
                ResolveInfo r0 = (ResolveInfo) list.get(0);
                ResolveInfo r1 = (ResolveInfo) list.get(1);
                if (DEBUG_INTENT_MATCHING || debug) {
                    String str = TAG;
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append(r0.activityInfo.name);
                    stringBuilder.append("=");
                    stringBuilder.append(r0.priority);
                    stringBuilder.append(" vs ");
                    stringBuilder.append(r1.activityInfo.name);
                    stringBuilder.append("=");
                    stringBuilder.append(r1.priority);
                    Slog.v(str, stringBuilder.toString());
                }
                ResolveInfo resolveInfo;
                if (r0.priority != r1.priority || r0.preferredOrder != r1.preferredOrder) {
                    resolveInfo = r0;
                } else if (r0.isDefault != r1.isDefault) {
                    ResolveInfo resolveInfo2 = r1;
                    resolveInfo = r0;
                } else {
                    ResolveInfo ri = findPreferredActivity(intent, resolvedType, flags, list, r0.priority, true, false, debug, i);
                    if (ri != null) {
                        return ri;
                    }
                    for (int i2 = 0; i2 < N; i2++) {
                        ResolveInfo ri2 = (ResolveInfo) list.get(i2);
                        if (ri2.activityInfo.applicationInfo.isInstantApp()) {
                            if (((int) (getDomainVerificationStatusLPr((PackageSetting) this.mSettings.mPackages.get(ri2.activityInfo.packageName), i) >> 32)) != 4) {
                                return ri2;
                            }
                        }
                    }
                    ri = new ResolveInfo(this.mResolveInfo);
                    ri.activityInfo = new ActivityInfo(ri.activityInfo);
                    ri.activityInfo.labelRes = ResolverActivity.getLabelRes(intent.getAction());
                    String intentPackage = intent.getPackage();
                    if (!TextUtils.isEmpty(intentPackage) && allHavePackage(list, intentPackage)) {
                        ApplicationInfo appi = ((ResolveInfo) list.get(0)).activityInfo.applicationInfo;
                        ri.resolvePackageName = intentPackage;
                        if (userNeedsBadging(i)) {
                            ri.noResourceId = true;
                        } else {
                            ri.icon = appi.icon;
                        }
                        ri.iconResourceId = appi.icon;
                        ri.labelRes = appi.labelRes;
                    }
                    ri.activityInfo.applicationInfo = new ApplicationInfo(ri.activityInfo.applicationInfo);
                    if (i != 0) {
                        ri.activityInfo.applicationInfo.uid = UserHandle.getUid(i, UserHandle.getAppId(ri.activityInfo.applicationInfo.uid));
                    }
                    if (ri.activityInfo.metaData == null) {
                        ri.activityInfo.metaData = new Bundle();
                    }
                    ri.activityInfo.metaData.putBoolean("android.dock_home", true);
                    return ri;
                }
                return (ResolveInfo) list.get(0);
            }
        }
        return null;
    }

    private boolean allHavePackage(List<ResolveInfo> list, String packageName) {
        if (ArrayUtils.isEmpty(list)) {
            return false;
        }
        int N = list.size();
        for (int i = 0; i < N; i++) {
            ResolveInfo ri = (ResolveInfo) list.get(i);
            ActivityInfo ai = ri != null ? ri.activityInfo : null;
            if (ai == null || !packageName.equals(ai.packageName)) {
                return false;
            }
        }
        return true;
    }

    private ResolveInfo findPersistentPreferredActivityLP(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, boolean debug, int userId) {
        List<PersistentPreferredActivity> pprefs;
        List<ResolveInfo> list;
        PackageManagerService packageManagerService = this;
        int i = flags;
        int i2 = userId;
        int N = query.size();
        PersistentPreferredIntentResolver ppir = (PersistentPreferredIntentResolver) packageManagerService.mSettings.mPersistentPreferredActivities.get(i2);
        if (DEBUG_PREFERRED || debug) {
            Slog.v(TAG, "Looking for presistent preferred activities...");
        }
        int i3 = 0;
        if (ppir != null) {
            pprefs = ppir.queryIntent(intent, resolvedType, (65536 & i) != 0, i2);
        } else {
            Intent intent2 = intent;
            String str = resolvedType;
            pprefs = null;
        }
        if (pprefs != null && pprefs.size() > 0) {
            int M = pprefs.size();
            int i4 = 0;
            while (i4 < M) {
                PersistentPreferredActivity ppa = (PersistentPreferredActivity) pprefs.get(i4);
                if (DEBUG_PREFERRED || debug) {
                    String str2 = TAG;
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("Checking PersistentPreferredActivity ds=");
                    stringBuilder.append(ppa.countDataSchemes() > 0 ? ppa.getDataScheme(i3) : "<none>");
                    stringBuilder.append("\n  component=");
                    stringBuilder.append(ppa.mComponent);
                    Slog.v(str2, stringBuilder.toString());
                    ppa.dump(new LogPrinter(2, TAG, 3), "  ");
                }
                ActivityInfo ai = packageManagerService.getActivityInfo(ppa.mComponent, i | 512, i2);
                if (DEBUG_PREFERRED || debug) {
                    Slog.v(TAG, "Found persistent preferred activity:");
                    if (ai != null) {
                        ai.dump(new LogPrinter(2, TAG, 3), "  ");
                    } else {
                        Slog.v(TAG, "  null");
                    }
                }
                if (ai != null) {
                    int j = 0;
                    while (j < N) {
                        ResolveInfo ri = (ResolveInfo) query.get(j);
                        if (ri.activityInfo.applicationInfo.packageName.equals(ai.applicationInfo.packageName) && ri.activityInfo.name.equals(ai.name)) {
                            if (DEBUG_PREFERRED || debug) {
                                String str3 = TAG;
                                StringBuilder stringBuilder2 = new StringBuilder();
                                stringBuilder2.append("Returning persistent preferred activity: ");
                                stringBuilder2.append(ri.activityInfo.packageName);
                                stringBuilder2.append(SliceAuthority.DELIMITER);
                                stringBuilder2.append(ri.activityInfo.name);
                                Slog.v(str3, stringBuilder2.toString());
                            } else {
                                int i5 = j;
                            }
                            return ri;
                        }
                        j++;
                        i = flags;
                    }
                }
                list = query;
                i4++;
                packageManagerService = this;
                i = flags;
                i3 = 0;
            }
        }
        list = query;
        return null;
    }

    /* JADX WARNING: Removed duplicated region for block: B:260:0x00d1 A:{SYNTHETIC} */
    /* JADX WARNING: Removed duplicated region for block: B:59:0x00ce A:{Catch:{ all -> 0x00db }} */
    /* JADX WARNING: Removed duplicated region for block: B:173:0x0322 A:{Catch:{ all -> 0x0410 }} */
    /* JADX WARNING: Removed duplicated region for block: B:169:0x02f6 A:{Catch:{ all -> 0x0485, all -> 0x003c }} */
    /* JADX WARNING: Removed duplicated region for block: B:206:0x0413  */
    /* JADX WARNING: Removed duplicated region for block: B:175:0x0328 A:{Catch:{ all -> 0x0410 }} */
    /* JADX WARNING: Removed duplicated region for block: B:220:0x0464 A:{SYNTHETIC, Splitter:B:220:0x0464} */
    /* JADX WARNING: Removed duplicated region for block: B:123:0x022b A:{Catch:{ all -> 0x0485, all -> 0x003c }} */
    /* JADX WARNING: Removed duplicated region for block: B:121:0x0203 A:{Catch:{ all -> 0x0485, all -> 0x003c }} */
    /* JADX WARNING: Removed duplicated region for block: B:104:0x01ae A:{Catch:{ all -> 0x0485, all -> 0x003c }} */
    /* JADX WARNING: Removed duplicated region for block: B:98:0x0182 A:{Catch:{ all -> 0x0485, all -> 0x003c }} */
    /* JADX WARNING: Removed duplicated region for block: B:242:0x04ac A:{Catch:{ all -> 0x0485, all -> 0x003c }} */
    /* JADX WARNING: Removed duplicated region for block: B:242:0x04ac A:{Catch:{ all -> 0x0485, all -> 0x003c }} */
    /* JADX WARNING: Removed duplicated region for block: B:242:0x04ac A:{Catch:{ all -> 0x0485, all -> 0x003c }} */
    /* JADX WARNING: Removed duplicated region for block: B:242:0x04ac A:{Catch:{ all -> 0x0485, all -> 0x003c }} */
    /* JADX WARNING: Removed duplicated region for block: B:242:0x04ac A:{Catch:{ all -> 0x0485, all -> 0x003c }} */
    /* JADX WARNING: Removed duplicated region for block: B:242:0x04ac A:{Catch:{ all -> 0x0485, all -> 0x003c }} */
    /* JADX WARNING: Removed duplicated region for block: B:242:0x04ac A:{Catch:{ all -> 0x0485, all -> 0x003c }} */
    /* JADX WARNING: Exception block dominator not found, dom blocks: [B:10:0x003a, B:94:0x0174] */
    /* JADX WARNING: Missing block: B:13:0x003c, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:14:0x003d, code skipped:
            r12 = r8;
            r16 = r9;
     */
    /* JADX WARNING: Missing block: B:229:0x0485, code skipped:
            r0 = th;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    ResolveInfo findPreferredActivity(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, int priority, boolean always, boolean removeMatches, boolean debug, int userId) {
        Throwable N;
        String str = resolvedType;
        List list = query;
        int i = userId;
        if (!sUserManager.exists(i)) {
            return null;
        }
        int flags2 = updateFlagsForResolve(flags, i, intent, Binder.getCallingUid(), false);
        Intent intent2 = updateIntentForResolve(intent);
        ArrayMap arrayMap = this.mPackages;
        synchronized (arrayMap) {
            ArrayMap arrayMap2 = arrayMap;
            Intent intent3 = intent2;
            try {
                ResolveInfo pri = findPersistentPreferredActivityLP(intent2, str, flags2, list, debug, i);
                if (pri != null) {
                    return pri;
                }
                List<PreferredActivity> prefs;
                PreferredIntentResolver pir = (PreferredIntentResolver) this.mSettings.mPreferredActivities.get(i);
                if (DEBUG_PREFERRED || debug) {
                    Slog.v(TAG, "Looking for preferred activities...");
                }
                if (pir != null) {
                    prefs = pir.queryIntent(intent3, str, (65536 & flags2) != 0, i);
                } else {
                    prefs = null;
                }
                if (prefs != null && prefs.size() > 0) {
                    boolean changed = false;
                    ResolveInfo pri2;
                    boolean changed2;
                    List<PreferredActivity> list2;
                    try {
                        String str2;
                        StringBuilder stringBuilder;
                        if (DEBUG_PREFERRED || debug) {
                            Slog.v(TAG, "Figuring out best match...");
                        }
                        int N2 = query.size();
                        int match = 0;
                        int j = 0;
                        while (j < N2) {
                            ResolveInfo ri;
                            ResolveInfo ri2;
                            try {
                                ri = (ResolveInfo) list.get(j);
                                if (!DEBUG_PREFERRED) {
                                    if (!debug) {
                                        pri2 = pri;
                                        changed2 = changed;
                                        ri2 = ri;
                                        if (ri2.match <= match) {
                                            match = ri2.match;
                                        }
                                        j++;
                                        pri = pri2;
                                        changed = changed2;
                                        str = resolvedType;
                                    }
                                }
                                str2 = TAG;
                                pri2 = pri;
                            } catch (Throwable th) {
                                N = th;
                                pri2 = pri;
                                changed2 = changed;
                                list2 = prefs;
                                if (changed2) {
                                }
                                throw N;
                            }
                            try {
                                stringBuilder = new StringBuilder();
                                changed2 = changed;
                                try {
                                    stringBuilder.append("Match for ");
                                    ri2 = ri;
                                } catch (Throwable th2) {
                                    N = th2;
                                    list2 = prefs;
                                    if (changed2) {
                                    }
                                    throw N;
                                }
                            } catch (Throwable th3) {
                                N = th3;
                                changed2 = changed;
                                list2 = prefs;
                                if (changed2) {
                                }
                                throw N;
                            }
                            try {
                                stringBuilder.append(ri2.activityInfo);
                                stringBuilder.append(": 0x");
                                stringBuilder.append(Integer.toHexString(match));
                                Slog.v(str2, stringBuilder.toString());
                                if (ri2.match <= match) {
                                }
                                j++;
                                pri = pri2;
                                changed = changed2;
                                str = resolvedType;
                            } catch (Throwable th4) {
                                N = th4;
                            }
                        }
                        changed2 = changed;
                        try {
                            String str3;
                            StringBuilder stringBuilder2;
                            if (DEBUG_PREFERRED || debug) {
                                str3 = TAG;
                                stringBuilder2 = new StringBuilder();
                                stringBuilder2.append("Best match: 0x");
                                stringBuilder2.append(Integer.toHexString(match));
                                Slog.v(str3, stringBuilder2.toString());
                            }
                            int match2 = 268369920 & match;
                            boolean M = prefs.size();
                            changed = false;
                            while (changed < M) {
                                boolean M2;
                                int match3;
                                int N3;
                                IntentFilter pa = (PreferredActivity) prefs.get(changed);
                                if (!DEBUG_PREFERRED) {
                                    if (!debug) {
                                        M2 = M;
                                        list2 = prefs;
                                        if (pa.mPref.mMatch == match2) {
                                            if (!DEBUG_PREFERRED) {
                                                if (debug) {
                                                }
                                            }
                                            str2 = TAG;
                                            prefs = new StringBuilder();
                                            prefs.append("Skipping bad match ");
                                            prefs.append(Integer.toHexString(pa.mPref.mMatch));
                                            Slog.v(str2, prefs.toString());
                                        } else if (!always || pa.mPref.mAlways) {
                                            ActivityInfo ai = getActivityInfo(pa.mPref.mComponent, ((flags2 | 512) | 524288) | 262144, i);
                                            if (DEBUG_PREFERRED == null) {
                                                if (!debug) {
                                                    match3 = match2;
                                                    if (ai != null) {
                                                        str3 = TAG;
                                                        prefs = new StringBuilder();
                                                        prefs.append("Removing dangling preferred activity: ");
                                                        prefs.append(pa.mPref.mComponent);
                                                        Slog.w(str3, prefs.toString());
                                                        pir.removeFilter(pa);
                                                        N3 = N2;
                                                        changed2 = true;
                                                    } else {
                                                        match2 = 0;
                                                        while (match2 < N2) {
                                                            ResolveInfo prefs2 = (ResolveInfo) list.get(match2);
                                                            if (prefs2.activityInfo.applicationInfo.packageName.equals(ai.applicationInfo.packageName)) {
                                                                if (prefs2.activityInfo.name.equals(ai.name)) {
                                                                    if (removeMatches) {
                                                                        pir.removeFilter(pa);
                                                                        try {
                                                                            if (DEBUG_PREFERRED) {
                                                                                N3 = N2;
                                                                                N2 = TAG;
                                                                                stringBuilder = new StringBuilder();
                                                                                stringBuilder.append("Removing match ");
                                                                                stringBuilder.append(pa.mPref.mComponent);
                                                                                Slog.v(N2, stringBuilder.toString());
                                                                            } else {
                                                                                N3 = N2;
                                                                            }
                                                                            changed2 = true;
                                                                        } catch (Throwable th5) {
                                                                            N = th5;
                                                                            changed2 = true;
                                                                            str = resolvedType;
                                                                            if (changed2) {
                                                                            }
                                                                            throw N;
                                                                        }
                                                                    }
                                                                    boolean N4;
                                                                    boolean audioType;
                                                                    boolean notSameSet;
                                                                    StringBuilder stringBuilder3;
                                                                    N3 = N2;
                                                                    int i2 = match2;
                                                                    ActivityInfo activityInfo = ai;
                                                                    if (always) {
                                                                        if (pa.mPref.sameSet(list) == 0) {
                                                                            N4 = true;
                                                                            audioType = intent3.getAction() == null && intent3.getAction().equals("android.intent.action.VIEW") && intent3.getData() != null && intent3.getData().getScheme() != null && ((intent3.getData().getScheme().equals("file") || intent3.getData().getScheme().equals("content")) && intent3.getType() != null && intent3.getType().startsWith("audio/"));
                                                                            if (audioType) {
                                                                                notSameSet = N4;
                                                                                str = resolvedType;
                                                                            } else {
                                                                                str2 = TAG;
                                                                                stringBuilder3 = new StringBuilder();
                                                                                notSameSet = N4;
                                                                                stringBuilder3.append("preferred activity for ");
                                                                                stringBuilder3.append(intent3);
                                                                                stringBuilder3.append(" type ");
                                                                                str = resolvedType;
                                                                                try {
                                                                                    stringBuilder3.append(str);
                                                                                    stringBuilder3.append(", do not dropping preferred activity");
                                                                                    Slog.i(str2, stringBuilder3.toString());
                                                                                    notSameSet = false;
                                                                                } catch (Throwable th6) {
                                                                                    N = th6;
                                                                                    if (changed2) {
                                                                                        if (DEBUG_PREFERRED) {
                                                                                            Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                                                                                        }
                                                                                        scheduleWritePackageRestrictionsLocked(i);
                                                                                    }
                                                                                    throw N;
                                                                                }
                                                                            }
                                                                            boolean z;
                                                                            if (notSameSet) {
                                                                                z = audioType;
                                                                            } else {
                                                                                if (intent3.hasCategory("android.intent.category.HOME") != 0) {
                                                                                    if ((intent3.getFlags() & 512) != 0) {
                                                                                        z = audioType;
                                                                                    }
                                                                                }
                                                                                if (pa.mPref.isSuperset(list) != 0) {
                                                                                    if (DEBUG_PREFERRED != 0) {
                                                                                        N2 = TAG;
                                                                                        stringBuilder2 = new StringBuilder();
                                                                                        stringBuilder2.append("Result set changed, but PreferredActivity is still valid as only non-preferred components were removed for ");
                                                                                        stringBuilder2.append(intent3);
                                                                                        stringBuilder2.append(" type ");
                                                                                        stringBuilder2.append(str);
                                                                                        Slog.i(N2, stringBuilder2.toString());
                                                                                    }
                                                                                    PreferredActivity preferredActivity = new PreferredActivity(pa, pa.mPref.mMatch, pa.mPref.discardObsoleteComponents(list), pa.mPref.mComponent, pa.mPref.mAlways);
                                                                                    pir.removeFilter(pa);
                                                                                    pir.addFilter(preferredActivity);
                                                                                    changed2 = true;
                                                                                } else {
                                                                                    N2 = TAG;
                                                                                    audioType = new StringBuilder();
                                                                                    audioType.append("Result set changed, dropping preferred activity for ");
                                                                                    audioType.append(intent3);
                                                                                    audioType.append(" type ");
                                                                                    audioType.append(str);
                                                                                    Slog.i(N2, audioType.toString());
                                                                                    if (this.mIsDefaultGoogleCalendar != 0) {
                                                                                        this.mIsDefaultPreferredActivityChanged = true;
                                                                                    }
                                                                                    if (DEBUG_PREFERRED != 0) {
                                                                                        N2 = TAG;
                                                                                        audioType = new StringBuilder();
                                                                                        audioType.append("Removing preferred activity since set changed ");
                                                                                        audioType.append(pa.mPref.mComponent);
                                                                                        Slog.v(N2, audioType.toString());
                                                                                    }
                                                                                    pir.removeFilter(pa);
                                                                                    pir.addFilter(new PreferredActivity(pa, pa.mPref.mMatch, null, pa.mPref.mComponent, false));
                                                                                    if (true) {
                                                                                        if (DEBUG_PREFERRED) {
                                                                                            Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                                                                                        }
                                                                                        scheduleWritePackageRestrictionsLocked(i);
                                                                                    }
                                                                                    return null;
                                                                                }
                                                                            }
                                                                            if (DEBUG_PREFERRED || debug) {
                                                                                str3 = TAG;
                                                                                stringBuilder3 = new StringBuilder();
                                                                                stringBuilder3.append("Returning preferred activity: ");
                                                                                stringBuilder3.append(prefs2.activityInfo.packageName);
                                                                                stringBuilder3.append(SliceAuthority.DELIMITER);
                                                                                stringBuilder3.append(prefs2.activityInfo.name);
                                                                                Slog.v(str3, stringBuilder3.toString());
                                                                            }
                                                                            if (this.mIsDefaultGoogleCalendar != 0 || prefs2.activityInfo.packageName == 0 || "com.android.calendar".equals(prefs2.activityInfo.packageName) == 0) {
                                                                                if (changed2) {
                                                                                    if (DEBUG_PREFERRED != 0) {
                                                                                        Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                                                                                    }
                                                                                    scheduleWritePackageRestrictionsLocked(i);
                                                                                }
                                                                                return prefs2;
                                                                            }
                                                                            Log.i(TAG, "break huawei calendar, set default calendar is google calendar");
                                                                            changed++;
                                                                            M = M2;
                                                                            prefs = list2;
                                                                            match2 = match3;
                                                                            N2 = N3;
                                                                        }
                                                                    }
                                                                    N4 = false;
                                                                    if (intent3.getAction() == null) {
                                                                    }
                                                                    if (audioType) {
                                                                    }
                                                                    if (notSameSet) {
                                                                    }
                                                                    str3 = TAG;
                                                                    stringBuilder3 = new StringBuilder();
                                                                    stringBuilder3.append("Returning preferred activity: ");
                                                                    stringBuilder3.append(prefs2.activityInfo.packageName);
                                                                    stringBuilder3.append(SliceAuthority.DELIMITER);
                                                                    stringBuilder3.append(prefs2.activityInfo.name);
                                                                    Slog.v(str3, stringBuilder3.toString());
                                                                    if (this.mIsDefaultGoogleCalendar != 0) {
                                                                    }
                                                                    if (changed2) {
                                                                    }
                                                                    return prefs2;
                                                                }
                                                            }
                                                            match2++;
                                                        }
                                                        N3 = N2;
                                                        str = resolvedType;
                                                        changed++;
                                                        M = M2;
                                                        prefs = list2;
                                                        match2 = match3;
                                                        N2 = N3;
                                                    }
                                                    str = resolvedType;
                                                    changed++;
                                                    M = M2;
                                                    prefs = list2;
                                                    match2 = match3;
                                                    N2 = N3;
                                                }
                                            }
                                            Slog.v(TAG, "Found preferred activity:");
                                            if (ai != null) {
                                                match3 = match2;
                                                ai.dump(new LogPrinter(2, TAG, 3), "  ");
                                            } else {
                                                match3 = match2;
                                                Slog.v(TAG, "  null");
                                            }
                                            if (ai != null) {
                                            }
                                            str = resolvedType;
                                            changed++;
                                            M = M2;
                                            prefs = list2;
                                            match2 = match3;
                                            N2 = N3;
                                        } else if (DEBUG_PREFERRED || debug) {
                                            Slog.v(TAG, "Skipping mAlways=false entry");
                                        }
                                        N3 = N2;
                                        match3 = match2;
                                        str = resolvedType;
                                        changed++;
                                        M = M2;
                                        prefs = list2;
                                        match2 = match3;
                                        N2 = N3;
                                    }
                                }
                                String str4 = TAG;
                                StringBuilder stringBuilder4 = new StringBuilder();
                                M2 = M;
                                stringBuilder4.append("Checking PreferredActivity ds=");
                                stringBuilder4.append(pa.countDataSchemes() > 0 ? pa.getDataScheme(0) : "<none>");
                                stringBuilder4.append("\n  component=");
                                stringBuilder4.append(pa.mPref.mComponent);
                                Slog.v(str4, stringBuilder4.toString());
                                list2 = prefs;
                                pa.dump(new LogPrinter(2, TAG, 3), "  ");
                                if (pa.mPref.mMatch == match2) {
                                }
                                N3 = N2;
                                match3 = match2;
                                str = resolvedType;
                                changed++;
                                M = M2;
                                prefs = list2;
                                match2 = match3;
                                N2 = N3;
                            }
                            str = resolvedType;
                            if (changed2) {
                                if (DEBUG_PREFERRED) {
                                    Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                                }
                                scheduleWritePackageRestrictionsLocked(i);
                            }
                        } catch (Throwable th7) {
                            N = th7;
                            list2 = prefs;
                            str = resolvedType;
                            if (changed2) {
                            }
                            throw N;
                        }
                    } catch (Throwable th8) {
                        N = th8;
                        pri2 = pri;
                        list2 = prefs;
                        changed2 = changed;
                        if (changed2) {
                        }
                        throw N;
                    }
                }
                return hwFindPreferredActivity(intent3, str, flags2, list, priority, always, removeMatches, debug, userId);
            } catch (Throwable th9) {
                N = th9;
                Intent intent4 = intent3;
                int i3 = flags2;
                while (true) {
                    try {
                        break;
                    } catch (Throwable th10) {
                        N = th10;
                    }
                }
                throw N;
            }
        }
    }

    public boolean canForwardTo(Intent intent, String resolvedType, int sourceUserId, int targetUserId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        List<CrossProfileIntentFilter> matches = getMatchingCrossProfileIntentFilters(intent, resolvedType, sourceUserId);
        boolean z = false;
        if (matches != null) {
            int size = matches.size();
            for (int i = 0; i < size; i++) {
                if (((CrossProfileIntentFilter) matches.get(i)).getTargetUserId() == targetUserId) {
                    return true;
                }
            }
        }
        int i2 = targetUserId;
        int i3;
        if (intent == null || !intent.hasWebURI()) {
            i3 = sourceUserId;
            return false;
        }
        int callingUid = Binder.getCallingUid();
        i3 = sourceUserId;
        UserInfo parent = getProfileParent(i3);
        synchronized (this.mPackages) {
            if (getCrossProfileDomainPreferredLpr(intent, resolvedType, updateFlagsForResolve(0, parent.id, intent, callingUid, false), i3, parent.id) != null) {
                z = true;
            }
        }
        return z;
    }

    private UserInfo getProfileParent(int userId) {
        long identity = Binder.clearCallingIdentity();
        try {
            UserInfo profileParent = sUserManager.getProfileParent(userId);
            return profileParent;
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    private List<CrossProfileIntentFilter> getMatchingCrossProfileIntentFilters(Intent intent, String resolvedType, int userId) {
        CrossProfileIntentResolver resolver = (CrossProfileIntentResolver) this.mSettings.mCrossProfileIntentResolvers.get(userId);
        if (resolver != null) {
            return resolver.queryIntent(intent, resolvedType, false, userId);
        }
        return null;
    }

    public ParceledListSlice<ResolveInfo> queryIntentActivities(Intent intent, String resolvedType, int flags, int userId) {
        try {
            Trace.traceBegin(262144, "queryIntentActivities");
            ParceledListSlice<ResolveInfo> parceledListSlice = new ParceledListSlice(queryIntentActivitiesInternal(intent, resolvedType, flags, userId));
            return parceledListSlice;
        } finally {
            Trace.traceEnd(262144);
        }
    }

    /* JADX WARNING: Missing block: B:12:0x0032, code skipped:
            return r4;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private String getInstantAppPackageName(int callingUid) {
        synchronized (this.mPackages) {
            if (Process.isIsolated(callingUid)) {
                callingUid = this.mIsolatedOwners.get(callingUid);
            }
            PackageSetting obj = this.mSettings.getUserIdLPr(UserHandle.getAppId(callingUid));
            String str = null;
            if (obj instanceof PackageSetting) {
                PackageSetting ps = obj;
                if (ps.getInstantApp(UserHandle.getUserId(callingUid))) {
                    str = ps.pkg.packageName;
                }
            } else {
                return null;
            }
        }
    }

    protected List<ResolveInfo> queryIntentActivitiesInternal(Intent intent, String resolvedType, int flags, int userId) {
        return queryIntentActivitiesInternal(intent, resolvedType, flags, Binder.getCallingUid(), userId, false, true);
    }

    /* JADX WARNING: Removed duplicated region for block: B:68:0x00e6  */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    protected List<ResolveInfo> queryIntentActivitiesInternal(Intent intent, String resolvedType, int flags, int filterCallingUid, int userId, boolean resolveForStart, boolean allowDynamicSplits) {
        Throwable result;
        String str;
        String pkgName;
        boolean hasNonNegativePriorityResult;
        String str2;
        PackageManagerService packageManagerService;
        PackageManagerService packageManagerService2;
        int i;
        String str3 = resolvedType;
        int i2 = filterCallingUid;
        int i3 = userId;
        if (!sUserManager.exists(i3)) {
            return Collections.emptyList();
        }
        String instantAppPkgName = getInstantAppPackageName(i2);
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), i3, false, false, "query intent activities");
        if (intent == null) {
            return Collections.emptyList();
        }
        Intent intent2;
        String pkgName2 = intent.getPackage();
        ComponentName comp = intent.getComponent();
        if (comp != null || intent.getSelector() == null) {
            intent2 = intent;
        } else {
            Intent intent3 = intent.getSelector();
            comp = intent3.getComponent();
            intent2 = intent3;
        }
        ComponentName comp2 = comp;
        int i4 = (comp2 == null && pkgName2 == null) ? 0 : 1;
        boolean z = true;
        int flags2 = updateFlagsForResolve(flags, i3, intent2, i2, resolveForStart, i4);
        boolean isTargetHiddenFromInstantApp;
        boolean z2;
        ResolveInfo ri;
        String str4;
        if (comp2 != null) {
            List list = new ArrayList(z);
            ActivityInfo ai = getActivityInfo(comp2, flags2, i3);
            if (ai != null) {
                boolean matchInstantApp = (DumpState.DUMP_VOLUMES & flags2) != 0 ? z : false;
                boolean matchVisibleToInstantAppOnly = (DumpState.DUMP_SERVICE_PERMISSIONS & flags2) != 0 ? z : false;
                boolean matchExplicitlyVisibleOnly = (DumpState.DUMP_HANDLE & flags2) != 0 ? z : false;
                boolean isCallerInstantApp = instantAppPkgName != null ? z : false;
                z = comp2.getPackageName().equals(instantAppPkgName);
                comp2 = (ai.applicationInfo.privateFlags & 128) != null ? true : null;
                boolean isTargetVisibleToInstantApp = (ai.flags & 1048576) != 0;
                if (isTargetVisibleToInstantApp) {
                    if ((ai.flags & 2097152) == 0) {
                        pkgName2 = true;
                        isTargetHiddenFromInstantApp = isTargetVisibleToInstantApp || (matchExplicitlyVisibleOnly && pkgName2 == null);
                        z2 = z && (!(matchInstantApp || isCallerInstantApp || comp2 == null) || (matchVisibleToInstantAppOnly && isCallerInstantApp && isTargetHiddenFromInstantApp));
                        if (!z2) {
                            ri = new ResolveInfo();
                            ri.activityInfo = ai;
                            list.add(ri);
                        }
                    }
                }
                pkgName2 = null;
                if (isTargetVisibleToInstantApp) {
                }
                if (z) {
                }
                if (z2) {
                }
            } else {
                str4 = pkgName2;
                this.mHwPMSEx.handleActivityInfoNotFound(flags2, intent2, i2, list);
            }
            List pkgName3 = list;
            return applyPostResolutionFilter(list, instantAppPkgName, allowDynamicSplits, i2, resolveForStart, i3, intent2);
        }
        int flags3 = flags2;
        ComponentName componentName = comp2;
        str4 = pkgName2;
        isTargetHiddenFromInstantApp = false;
        boolean addInstant = false;
        ArrayMap arrayMap = this.mPackages;
        synchronized (arrayMap) {
            String str5;
            int i5;
            Intent intent4;
            Intent intent5;
            List<ResolveInfo> result2;
            List<ResolveInfo> result3;
            ArrayMap arrayMap2;
            if (str4 == null) {
                String str6 = resolvedType;
                try {
                    List<CrossProfileIntentFilter> matchingFilters = getMatchingCrossProfileIntentFilters(intent2, str6, i3);
                    ri = querySkipCurrentProfileIntents(matchingFilters, intent2, str6, flags3, i3);
                    String xpResult;
                    Intent intent6;
                    List applyPostResolutionFilter;
                    if (ri != null) {
                        try {
                            List<ResolveInfo> xpResult2 = new ArrayList(1);
                            xpResult2.add(ri);
                            List filterIfNotSystemUser = filterIfNotSystemUser(xpResult2, i3);
                            xpResult = str6;
                            intent6 = intent2;
                            arrayMap2 = arrayMap;
                            try {
                                applyPostResolutionFilter = applyPostResolutionFilter(filterIfNotSystemUser, instantAppPkgName, allowDynamicSplits, i2, resolveForStart, i3, intent6);
                                return applyPostResolutionFilter;
                            } catch (Throwable th) {
                                result = th;
                                str5 = instantAppPkgName;
                                instantAppPkgName = i3;
                                str = str4;
                                intent6 = flags3;
                                throw result;
                            }
                        } catch (Throwable th2) {
                            result = th2;
                            xpResult = str6;
                            arrayMap2 = arrayMap;
                            str5 = instantAppPkgName;
                            instantAppPkgName = i3;
                            i5 = flags3;
                            str = str4;
                            throw result;
                        }
                    }
                    List<ResolveInfo> result4;
                    xpResult = str6;
                    intent6 = intent2;
                    arrayMap2 = arrayMap;
                    pkgName = str4;
                    try {
                        intent4 = intent6;
                        try {
                            result4 = filterIfNotSystemUser(this.mActivities.queryIntent(intent4, xpResult, flags3, i3), i3);
                            z2 = isInstantAppResolutionAllowed(intent4, result4, i3, false);
                        } catch (Throwable th3) {
                            result = th3;
                            str5 = instantAppPkgName;
                            instantAppPkgName = i3;
                            intent6 = flags3;
                            intent5 = intent4;
                            throw result;
                        }
                    } catch (Throwable th4) {
                        result = th4;
                        str5 = instantAppPkgName;
                        instantAppPkgName = i3;
                        intent5 = intent6;
                        str = pkgName;
                        throw result;
                    }
                    try {
                        addInstant = false;
                        result2 = result4;
                        ResolveInfo xpResolveInfo = queryCrossProfileIntents(matchingFilters, intent4, xpResult, flags3, i3, hasNonNegativePriority(result4));
                        if (xpResolveInfo != null) {
                            try {
                                if (isUserEnabled(xpResolveInfo.targetUserId)) {
                                    if (filterIfNotSystemUser(Collections.singletonList(xpResolveInfo), i3).size() > 0) {
                                        addInstant = true;
                                    }
                                    if (addInstant) {
                                        result2.add(xpResolveInfo);
                                        isTargetHiddenFromInstantApp = true;
                                    }
                                }
                            } catch (Throwable th5) {
                                result = th5;
                                instantAppPkgName = i3;
                                addInstant = z2;
                                hasNonNegativePriorityResult = pkgName;
                                throw result;
                            }
                        }
                        str4 = isTargetHiddenFromInstantApp;
                        try {
                            if (intent4.hasWebURI()) {
                                ResolveInfo xpResolveInfo2;
                                CrossProfileDomainInfo xpDomainInfo;
                                Intent intent7;
                                int i6;
                                UserInfo parent = getProfileParent(i3);
                                if (parent != null) {
                                    try {
                                        xpResolveInfo2 = xpResolveInfo;
                                        xpDomainInfo = getCrossProfileDomainPreferredLpr(intent4, xpResult, flags3, i3, parent.id);
                                    } catch (Throwable th6) {
                                        result = th6;
                                        str5 = instantAppPkgName;
                                        instantAppPkgName = i3;
                                        i5 = flags3;
                                        addInstant = z2;
                                        str2 = str4;
                                        hasNonNegativePriorityResult = pkgName;
                                        throw result;
                                    }
                                }
                                UserInfo userInfo = parent;
                                xpResolveInfo2 = xpResolveInfo;
                                xpDomainInfo = null;
                                if (xpDomainInfo != null) {
                                    if (xpResolveInfo2 != null) {
                                        result2.remove(xpResolveInfo2);
                                    }
                                    try {
                                        if (result2.size() != 0 || z2) {
                                            intent7 = intent4;
                                            str5 = instantAppPkgName;
                                            i6 = i3;
                                            i5 = flags3;
                                            packageManagerService = this;
                                        } else {
                                            result2.add(xpDomainInfo.resolveInfo);
                                            intent7 = intent4;
                                            i6 = i3;
                                            i5 = flags3;
                                            packageManagerService = this;
                                            try {
                                                applyPostResolutionFilter = applyPostResolutionFilter(result2, instantAppPkgName, allowDynamicSplits, filterCallingUid, resolveForStart, i6, intent7);
                                                return applyPostResolutionFilter;
                                            } catch (Throwable th7) {
                                                result = th7;
                                                packageManagerService2 = packageManagerService;
                                                i = i6;
                                                intent5 = intent7;
                                                isTargetHiddenFromInstantApp = str4;
                                                throw result;
                                            }
                                        }
                                    } catch (Throwable th8) {
                                        result = th8;
                                        str5 = instantAppPkgName;
                                        i5 = flags3;
                                        instantAppPkgName = i3;
                                        addInstant = z2;
                                        str2 = str4;
                                        intent5 = intent4;
                                        throw result;
                                    }
                                }
                                intent7 = intent4;
                                str5 = instantAppPkgName;
                                i6 = i3;
                                i5 = flags3;
                                packageManagerService = this;
                                try {
                                    if (result2.size() <= 1 && !z2) {
                                        applyPostResolutionFilter = packageManagerService.applyPostResolutionFilter(result2, str5, allowDynamicSplits, filterCallingUid, resolveForStart, i6, intent7);
                                        return applyPostResolutionFilter;
                                    }
                                } catch (Throwable th9) {
                                    result = th9;
                                    packageManagerService2 = packageManagerService;
                                    i = i6;
                                    intent5 = intent7;
                                    addInstant = z2;
                                    str2 = str4;
                                    str = pkgName;
                                    throw result;
                                }
                                intent4 = packageManagerService;
                                instantAppPkgName = i6;
                                intent5 = intent7;
                                CrossProfileDomainInfo crossProfileDomainInfo = xpDomainInfo;
                                try {
                                    result4 = packageManagerService.filterCandidatesWithDomainPreferredActivitiesLPr(intent7, i5, result2, xpDomainInfo, instantAppPkgName);
                                    isTargetHiddenFromInstantApp = true;
                                } catch (Throwable th10) {
                                    result = th10;
                                    isTargetHiddenFromInstantApp = str4;
                                    throw result;
                                }
                            }
                            str5 = instantAppPkgName;
                            instantAppPkgName = i3;
                            i5 = flags3;
                            intent5 = intent4;
                            intent4 = this;
                            result4 = result2;
                            isTargetHiddenFromInstantApp = str4;
                            result3 = result4;
                            addInstant = z2;
                            str = pkgName;
                        } catch (Throwable th11) {
                            result = th11;
                            str5 = instantAppPkgName;
                            instantAppPkgName = i3;
                            i5 = flags3;
                            intent5 = intent4;
                            addInstant = z2;
                            str2 = str4;
                            throw result;
                        }
                    } catch (Throwable th12) {
                        result = th12;
                        str5 = instantAppPkgName;
                        instantAppPkgName = i3;
                        i5 = flags3;
                        intent5 = intent4;
                        addInstant = z2;
                        throw result;
                    }
                } catch (Throwable th13) {
                    result = th13;
                    arrayMap2 = arrayMap;
                    str5 = instantAppPkgName;
                    instantAppPkgName = i3;
                    i5 = flags3;
                    intent5 = intent2;
                    str = str4;
                    throw result;
                }
            }
            arrayMap2 = arrayMap;
            str5 = instantAppPkgName;
            instantAppPkgName = i3;
            i5 = flags3;
            intent4 = this;
            pkgName = str4;
            intent5 = intent2;
            try {
            } catch (Throwable th14) {
                result = th14;
                str = pkgName;
                throw result;
            }
            try {
                Package pkg = (Package) intent4.mPackages.get(pkgName);
                List<ResolveInfo> result5 = null;
                if (pkg != null) {
                    result5 = intent4.filterIfNotSystemUser(intent4.mActivities.queryIntentForPackage(intent5, resolvedType, i5, pkg.activities, instantAppPkgName), instantAppPkgName);
                }
                if (result5 != null) {
                    if (result5.size() == 0) {
                    }
                    result3 = result5;
                }
                addInstant = intent4.isInstantAppResolutionAllowed(intent5, null, instantAppPkgName, true);
                if (result5 == null) {
                    result3 = new ArrayList();
                }
                result3 = result5;
            } catch (Throwable th15) {
                result = th15;
                throw result;
            }
            if (addInstant) {
                result2 = intent4.maybeAddInstantAppInstaller(result3, intent5, resolvedType, i5, instantAppPkgName, resolveForStart);
            } else {
                result2 = result3;
            }
            if (isTargetHiddenFromInstantApp) {
                Collections.sort(result2, mResolvePrioritySorter);
            }
            return intent4.applyPostResolutionFilter(result2, str5, allowDynamicSplits, filterCallingUid, resolveForStart, instantAppPkgName, intent5);
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:25:0x009d  */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private List<ResolveInfo> maybeAddInstantAppInstaller(List<ResolveInfo> result, Intent intent, String resolvedType, int flags, int userId, boolean resolveForStart) {
        ResolveInfo localInstantApp;
        AuxiliaryResolveInfo auxiliaryResponse;
        PackageSetting ps;
        List<ResolveInfo> list = result;
        int i = userId;
        boolean alreadyResolvedLocally = (flags & DumpState.DUMP_VOLUMES) != 0;
        ResolveInfo localInstantApp2 = null;
        boolean blockResolution = false;
        Intent intent2;
        String str;
        if (alreadyResolvedLocally) {
            intent2 = intent;
            str = resolvedType;
        } else {
            intent2 = intent;
            str = resolvedType;
            List<ResolveInfo> instantApps = this.mActivities.queryIntent(intent2, str, (DumpState.DUMP_VOLUMES | (flags | 64)) | DumpState.DUMP_SERVICE_PERMISSIONS, i);
            for (int i2 = instantApps.size() - 1; i2 >= 0; i2--) {
                ResolveInfo info = (ResolveInfo) instantApps.get(i2);
                String packageName = info.activityInfo.packageName;
                PackageSetting ps2 = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (ps2.getInstantApp(i)) {
                    StringBuilder stringBuilder;
                    if (((int) (getDomainVerificationStatusLPr(ps2, i) >> 32)) == 3) {
                        if (DEBUG_INSTANT) {
                            String str2 = TAG;
                            stringBuilder = new StringBuilder();
                            stringBuilder.append("Instant app marked to never run; pkg: ");
                            stringBuilder.append(packageName);
                            Slog.v(str2, stringBuilder.toString());
                        }
                        blockResolution = true;
                    } else {
                        if (DEBUG_INSTANT) {
                            boolean blockResolution2 = TAG;
                            stringBuilder = new StringBuilder();
                            stringBuilder.append("Found installed instant app; pkg: ");
                            stringBuilder.append(packageName);
                            Slog.v(blockResolution2, stringBuilder.toString());
                        }
                        localInstantApp2 = info;
                    }
                    localInstantApp = localInstantApp2;
                    auxiliaryResponse = null;
                    if (!blockResolution) {
                        if (localInstantApp == null) {
                            Trace.traceBegin(262144, "resolveEphemeral");
                            auxiliaryResponse = InstantAppResolver.doInstantAppResolutionPhaseOne(this.mInstantAppResolverConnection, new InstantAppRequest(null, intent2, str, null, i, null, resolveForStart));
                            Trace.traceEnd(262144);
                        } else {
                            ApplicationInfo ai = localInstantApp.activityInfo.applicationInfo;
                            auxiliaryResponse = new AuxiliaryResolveInfo(null, ai.packageName, ai.longVersionCode, null);
                        }
                    }
                    if (!intent.isWebIntent() && auxiliaryResponse == null) {
                        return list;
                    }
                    ps = (PackageSetting) this.mSettings.mPackages.get(this.mInstantAppInstallerActivity.packageName);
                    if (ps != null || ps.getUserState().get(i) == null || !((PackageUserState) ps.getUserState().get(i)).isEnabled(this.mInstantAppInstallerActivity, 0)) {
                        return list;
                    }
                    localInstantApp2 = new ResolveInfo(this.mInstantAppInstallerInfo);
                    localInstantApp2.activityInfo = PackageParser.generateActivityInfo(this.mInstantAppInstallerActivity, 0, ps.readUserState(i), i);
                    localInstantApp2.match = 5799936;
                    localInstantApp2.filter = new IntentFilter();
                    if (intent.getAction() != null) {
                        localInstantApp2.filter.addAction(intent.getAction());
                    }
                    if (!(intent.getData() == null || intent.getData().getPath() == null)) {
                        localInstantApp2.filter.addDataPath(intent.getData().getPath(), 0);
                    }
                    localInstantApp2.isInstantAppAvailable = true;
                    localInstantApp2.isDefault = true;
                    localInstantApp2.auxiliaryInfo = auxiliaryResponse;
                    if (DEBUG_INSTANT) {
                        Slog.v(TAG, "Adding ephemeral installer to the ResolveInfo list");
                    }
                    list.add(localInstantApp2);
                    return list;
                }
            }
        }
        boolean z = alreadyResolvedLocally;
        localInstantApp = localInstantApp2;
        auxiliaryResponse = null;
        if (blockResolution) {
        }
        if (!intent.isWebIntent()) {
        }
        ps = (PackageSetting) this.mSettings.mPackages.get(this.mInstantAppInstallerActivity.packageName);
        if (ps != null) {
        }
        return list;
    }

    private CrossProfileDomainInfo getCrossProfileDomainPreferredLpr(Intent intent, String resolvedType, int flags, int sourceUserId, int parentUserId) {
        int i = sourceUserId;
        int i2 = parentUserId;
        if (!sUserManager.hasUserRestriction("allow_parent_profile_app_linking", i)) {
            return null;
        }
        List<ResolveInfo> resultTargetUser = this.mActivities.queryIntent(intent, resolvedType, flags, i2);
        List<ResolveInfo> list;
        if (resultTargetUser == null) {
            resultTargetUser = null;
        } else if (resultTargetUser.isEmpty()) {
            list = resultTargetUser;
            resultTargetUser = null;
        } else {
            CrossProfileDomainInfo result = null;
            int size = resultTargetUser.size();
            int i3 = 0;
            while (i3 < size) {
                Intent intent2;
                ResolveInfo riTargetUser = (ResolveInfo) resultTargetUser.get(i3);
                if (!riTargetUser.handleAllWebDataURI) {
                    PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(riTargetUser.activityInfo.packageName);
                    if (ps != null) {
                        int status = (int) (getDomainVerificationStatusLPr(ps, i2) >> 32);
                        if (result == null) {
                            list = resultTargetUser;
                            CrossProfileDomainInfo resultTargetUser2 = new CrossProfileDomainInfo();
                            resultTargetUser2.resolveInfo = createForwardingResolveInfoUnchecked(new IntentFilter(), i, i2);
                            resultTargetUser2.bestDomainVerificationStatus = status;
                            result = resultTargetUser2;
                        } else {
                            list = resultTargetUser;
                            result.bestDomainVerificationStatus = bestDomainVerificationStatus(status, result.bestDomainVerificationStatus);
                        }
                        i3++;
                        resultTargetUser = list;
                        intent2 = intent;
                    }
                }
                list = resultTargetUser;
                i3++;
                resultTargetUser = list;
                intent2 = intent;
            }
            if (result == null || result.bestDomainVerificationStatus != 3) {
                return result;
            }
            return null;
        }
        return resultTargetUser;
    }

    private int bestDomainVerificationStatus(int status1, int status2) {
        if (status1 == 3) {
            return status2;
        }
        if (status2 == 3) {
            return status1;
        }
        return (int) MathUtils.max(status1, status2);
    }

    private boolean isUserEnabled(int userId) {
        long callingId = Binder.clearCallingIdentity();
        try {
            UserInfo userInfo = sUserManager.getUserInfo(userId);
            boolean z = userInfo != null && userInfo.isEnabled();
            Binder.restoreCallingIdentity(callingId);
            return z;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private List<ResolveInfo> filterIfNotSystemUser(List<ResolveInfo> resolveInfos, int userId) {
        if (userId == 0) {
            return resolveInfos;
        }
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            if ((((ResolveInfo) resolveInfos.get(i)).activityInfo.flags & 536870912) != 0) {
                resolveInfos.remove(i);
            }
        }
        return resolveInfos;
    }

    private List<ResolveInfo> applyPostResolutionFilter(List<ResolveInfo> resolveInfos, String ephemeralPkgName, boolean allowDynamicSplits, int filterCallingUid, boolean resolveForStart, int userId, Intent intent) {
        int i;
        PackageManagerService packageManagerService = this;
        List<ResolveInfo> list = resolveInfos;
        String str = ephemeralPkgName;
        int i2 = userId;
        boolean z = true;
        boolean blockInstant = intent.isWebIntent() && areWebInstantAppsDisabled();
        int i3 = resolveInfos.size() - 1;
        while (i3 >= 0) {
            boolean z2;
            ResolveInfo info = (ResolveInfo) list.get(i3);
            if (info.isInstantAppAvailable && blockInstant) {
                list.remove(i3);
            } else if (!allowDynamicSplits || info.activityInfo == null || info.activityInfo.splitName == null || ArrayUtils.contains(info.activityInfo.applicationInfo.splitNames, info.activityInfo.splitName)) {
                i = filterCallingUid;
                z2 = z;
                if (!(str == null || str.equals(info.activityInfo.packageName) || ((resolveForStart && ((intent.isWebIntent() || (intent.getFlags() & 2048) != 0) && intent.getPackage() == null && intent.getComponent() == null)) || (!info.activityInfo.applicationInfo.isInstantApp() && (info.activityInfo.flags & 1048576) != 0)))) {
                    list.remove(i3);
                }
                i3--;
                z = z2;
                packageManagerService = this;
            } else if (packageManagerService.mInstantAppInstallerActivity == null) {
                if (DEBUG_INSTALL) {
                    Slog.v(TAG, "No installer - not adding it to the ResolveInfo list");
                }
                list.remove(i3);
            } else if (blockInstant && packageManagerService.isInstantApp(info.activityInfo.packageName, i2)) {
                list.remove(i3);
            } else {
                if (DEBUG_INSTALL) {
                    Slog.v(TAG, "Adding installer to the ResolveInfo list");
                }
                ResolveInfo installerInfo = new ResolveInfo(packageManagerService.mInstantAppInstallerInfo);
                AuxiliaryResolveInfo auxiliaryResolveInfo = r12;
                AuxiliaryResolveInfo auxiliaryResolveInfo2 = new AuxiliaryResolveInfo(packageManagerService.findInstallFailureActivity(info.activityInfo.packageName, filterCallingUid, i2), info.activityInfo.packageName, info.activityInfo.applicationInfo.longVersionCode, info.activityInfo.splitName);
                installerInfo.auxiliaryInfo = auxiliaryResolveInfo;
                installerInfo.filter = new IntentFilter();
                installerInfo.resolvePackageName = info.getComponentInfo().packageName;
                installerInfo.labelRes = info.resolveLabelResId();
                installerInfo.icon = info.resolveIconResId();
                z2 = true;
                installerInfo.isInstantAppAvailable = true;
                list.set(i3, installerInfo);
                i3--;
                z = z2;
                packageManagerService = this;
            }
            i = filterCallingUid;
            z2 = z;
            i3--;
            z = z2;
            packageManagerService = this;
        }
        i = filterCallingUid;
        return list;
    }

    private ComponentName findInstallFailureActivity(String packageName, int filterCallingUid, int userId) {
        Intent failureActivityIntent = new Intent("android.intent.action.INSTALL_FAILURE");
        failureActivityIntent.setPackage(packageName);
        List<ResolveInfo> result = queryIntentActivitiesInternal(failureActivityIntent, null, 0, filterCallingUid, userId, false, false);
        int NR = result.size();
        if (NR > 0) {
            for (int i = 0; i < NR; i++) {
                ResolveInfo info = (ResolveInfo) result.get(i);
                if (info.activityInfo.splitName == null) {
                    return new ComponentName(packageName, info.activityInfo.name);
                }
            }
        }
        return null;
    }

    private boolean hasNonNegativePriority(List<ResolveInfo> resolveInfos) {
        return resolveInfos.size() > 0 && ((ResolveInfo) resolveInfos.get(0)).priority >= 0;
    }

    /* JADX WARNING: Missing block: B:123:0x0265, code skipped:
            if (DEBUG_PREFERRED != false) goto L_0x026b;
     */
    /* JADX WARNING: Missing block: B:125:0x0269, code skipped:
            if (DEBUG_DOMAIN_VERIFICATION == false) goto L_0x02ae;
     */
    /* JADX WARNING: Missing block: B:126:0x026b, code skipped:
            r0 = TAG;
            r2 = new java.lang.StringBuilder();
            r2.append("Filtered results with preferred activities. New candidates count: ");
            r2.append(r8.size());
            android.util.Slog.v(r0, r2.toString());
            r0 = r8.iterator();
     */
    /* JADX WARNING: Missing block: B:128:0x028d, code skipped:
            if (r0.hasNext() == false) goto L_0x02ae;
     */
    /* JADX WARNING: Missing block: B:129:0x028f, code skipped:
            r2 = (android.content.pm.ResolveInfo) r0.next();
            r3 = TAG;
            r4 = new java.lang.StringBuilder();
            r4.append("  + ");
            r4.append(r2.activityInfo);
            android.util.Slog.v(r3, r4.toString());
     */
    /* JADX WARNING: Missing block: B:130:0x02ae, code skipped:
            return r8;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private List<ResolveInfo> filterCandidatesWithDomainPreferredActivitiesLPr(Intent intent, int matchFlags, List<ResolveInfo> candidates, CrossProfileDomainInfo xpDomainInfo, int userId) {
        Throwable th;
        int i;
        List<ResolveInfo> list;
        PackageManagerService packageManagerService = this;
        List list2 = candidates;
        CrossProfileDomainInfo crossProfileDomainInfo = xpDomainInfo;
        int i2 = userId;
        boolean debug = (intent.getFlags() & 8) != 0;
        if (DEBUG_PREFERRED || DEBUG_DOMAIN_VERIFICATION) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Filtering results with preferred activities. Candidates count: ");
            stringBuilder.append(candidates.size());
            Slog.v(str, stringBuilder.toString());
        }
        ArrayList<ResolveInfo> result = new ArrayList();
        ArrayList<ResolveInfo> alwaysList = new ArrayList();
        ArrayList<ResolveInfo> undefinedList = new ArrayList();
        ArrayList<ResolveInfo> alwaysAskList = new ArrayList();
        ArrayList<ResolveInfo> neverList = new ArrayList();
        ArrayList<ResolveInfo> matchAllList = new ArrayList();
        synchronized (packageManagerService.mPackages) {
            try {
                int linkGeneration;
                int count = candidates.size();
                int n = 0;
                while (n < count) {
                    ResolveInfo info = (ResolveInfo) list2.get(n);
                    String packageName = info.activityInfo.packageName;
                    int count2 = count;
                    PackageSetting count3 = (PackageSetting) packageManagerService.mSettings.mPackages.get(packageName);
                    if (count3 != null) {
                        if (info.handleAllWebDataURI != null) {
                            matchAllList.add(info);
                        } else {
                            long packedStatus = packageManagerService.getDomainVerificationStatusLPr(count3, i2);
                            PackageSetting ps = count3;
                            count = (int) (packedStatus >> 32);
                            linkGeneration = (int) (packedStatus & -1);
                            String str2;
                            StringBuilder stringBuilder2;
                            StringBuilder stringBuilder3;
                            if (count == 2) {
                                try {
                                    if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                        str2 = TAG;
                                        stringBuilder2 = new StringBuilder();
                                        stringBuilder2.append("  + always: ");
                                        stringBuilder2.append(info.activityInfo.packageName);
                                        stringBuilder2.append(" : linkgen=");
                                        stringBuilder2.append(linkGeneration);
                                        Slog.i(str2, stringBuilder2.toString());
                                    }
                                    info.preferredOrder = linkGeneration;
                                    alwaysList.add(info);
                                } catch (Throwable th2) {
                                    th = th2;
                                    list = candidates;
                                    i = userId;
                                    throw th;
                                }
                            } else if (count == 3) {
                                if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                    str2 = TAG;
                                    stringBuilder3 = new StringBuilder();
                                    stringBuilder3.append("  + never: ");
                                    stringBuilder3.append(info.activityInfo.packageName);
                                    Slog.i(str2, stringBuilder3.toString());
                                }
                                neverList.add(info);
                            } else if (count == 4) {
                                if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                    str2 = TAG;
                                    stringBuilder3 = new StringBuilder();
                                    stringBuilder3.append("  + always-ask: ");
                                    stringBuilder3.append(info.activityInfo.packageName);
                                    Slog.i(str2, stringBuilder3.toString());
                                }
                                alwaysAskList.add(info);
                            } else {
                                if (count != 0) {
                                    if (count == 1) {
                                    }
                                }
                                if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                    String str3 = TAG;
                                    stringBuilder2 = new StringBuilder();
                                    stringBuilder2.append("  + ask: ");
                                    stringBuilder2.append(info.activityInfo.packageName);
                                    Slog.i(str3, stringBuilder2.toString());
                                }
                                undefinedList.add(info);
                            }
                        }
                    }
                    n++;
                    count = count2;
                    packageManagerService = this;
                    List<ResolveInfo> list22 = candidates;
                    i2 = userId;
                }
                boolean includeBrowser = false;
                if (alwaysList.size() > 0) {
                    result.addAll(alwaysList);
                } else {
                    result.addAll(undefinedList);
                    if (!(crossProfileDomainInfo == null || crossProfileDomainInfo.bestDomainVerificationStatus == 3)) {
                        result.add(crossProfileDomainInfo.resolveInfo);
                    }
                    includeBrowser = true;
                }
                if (alwaysAskList.size() > 0) {
                    Iterator it = result.iterator();
                    while (it.hasNext()) {
                        ((ResolveInfo) it.next()).preferredOrder = 0;
                    }
                    i2 = 0;
                    result.addAll(alwaysAskList);
                    includeBrowser = true;
                } else {
                    i2 = 0;
                }
                if (includeBrowser) {
                    if (DEBUG_DOMAIN_VERIFICATION) {
                        Slog.v(TAG, "   ...including browsers in candidate set");
                    }
                    if ((matchFlags & 131072) != 0) {
                        result.addAll(matchAllList);
                        boolean z = includeBrowser;
                        i = userId;
                    } else {
                        try {
                            StringBuilder stringBuilder4;
                            String defaultBrowserPackageName = getDefaultBrowserPackageName(userId);
                            int numCandidates = matchAllList.size();
                            count = 0;
                            ResolveInfo defaultBrowserMatch = null;
                            while (true) {
                                linkGeneration = numCandidates;
                                if (i2 >= linkGeneration) {
                                    break;
                                }
                                int maxMatchPrio;
                                int numCandidates2 = linkGeneration;
                                linkGeneration = (ResolveInfo) matchAllList.get(i2);
                                if (linkGeneration.priority > count) {
                                    count = linkGeneration.priority;
                                }
                                if (linkGeneration.activityInfo.packageName.equals(defaultBrowserPackageName)) {
                                    if (defaultBrowserMatch != null) {
                                        maxMatchPrio = count;
                                        if (defaultBrowserMatch.priority < linkGeneration.priority) {
                                        }
                                    } else {
                                        maxMatchPrio = count;
                                    }
                                    if (debug) {
                                        count = TAG;
                                        stringBuilder4 = new StringBuilder();
                                        stringBuilder4.append("Considering default browser match ");
                                        stringBuilder4.append(linkGeneration);
                                        Slog.v(count, stringBuilder4.toString());
                                    }
                                    defaultBrowserMatch = linkGeneration;
                                } else {
                                    maxMatchPrio = count;
                                }
                                i2++;
                                numCandidates = numCandidates2;
                                count = maxMatchPrio;
                                crossProfileDomainInfo = xpDomainInfo;
                            }
                            if (defaultBrowserMatch == null || defaultBrowserMatch.priority < count || TextUtils.isEmpty(defaultBrowserPackageName)) {
                                result.addAll(matchAllList);
                            } else {
                                if (debug) {
                                    String str4 = TAG;
                                    stringBuilder4 = new StringBuilder();
                                    stringBuilder4.append("Default browser match ");
                                    stringBuilder4.append(defaultBrowserMatch);
                                    Slog.v(str4, stringBuilder4.toString());
                                }
                                result.add(defaultBrowserMatch);
                            }
                        } catch (Throwable th3) {
                            th = th3;
                            throw th;
                        }
                    }
                    if (result.size() == 0) {
                        result.addAll(candidates);
                        result.removeAll(neverList);
                    } else {
                        list = candidates;
                    }
                } else {
                    list = candidates;
                    i = userId;
                }
            } catch (Throwable th4) {
                th = th4;
                List list3 = list22;
                i = i2;
                throw th;
            }
        }
    }

    private long getDomainVerificationStatusLPr(PackageSetting ps, int userId) {
        long result = ps.getDomainVerificationStatusForUser(userId);
        if ((result >> 32) != 0 || ps.getIntentFilterVerificationInfo() == null) {
            return result;
        }
        return ((long) ps.getIntentFilterVerificationInfo().getStatus()) << 32;
    }

    private ResolveInfo querySkipCurrentProfileIntents(List<CrossProfileIntentFilter> matchingFilters, Intent intent, String resolvedType, int flags, int sourceUserId) {
        if (matchingFilters != null) {
            int size = matchingFilters.size();
            for (int i = 0; i < size; i++) {
                CrossProfileIntentFilter filter = (CrossProfileIntentFilter) matchingFilters.get(i);
                if ((filter.getFlags() & 2) != 0) {
                    ResolveInfo resolveInfo = createForwardingResolveInfo(filter, intent, resolvedType, flags, sourceUserId);
                    if (resolveInfo != null) {
                        return resolveInfo;
                    }
                }
            }
        }
        return null;
    }

    private ResolveInfo queryCrossProfileIntents(List<CrossProfileIntentFilter> matchingFilters, Intent intent, String resolvedType, int flags, int sourceUserId, boolean matchInCurrentProfile) {
        List<CrossProfileIntentFilter> list = matchingFilters;
        if (list != null) {
            SparseBooleanArray alreadyTriedUserIds = new SparseBooleanArray();
            int size = matchingFilters.size();
            for (int i = 0; i < size; i++) {
                CrossProfileIntentFilter filter = (CrossProfileIntentFilter) list.get(i);
                int targetUserId = filter.getTargetUserId();
                boolean skipCurrentProfile = (filter.getFlags() & 2) != 0;
                boolean skipCurrentProfileIfNoMatchFound = (filter.getFlags() & 4) != 0;
                if (!(skipCurrentProfile || alreadyTriedUserIds.get(targetUserId) || (skipCurrentProfileIfNoMatchFound && matchInCurrentProfile))) {
                    ResolveInfo resolveInfo = createForwardingResolveInfo(filter, intent, resolvedType, flags, sourceUserId);
                    if (resolveInfo != null) {
                        return resolveInfo;
                    }
                    alreadyTriedUserIds.put(targetUserId, true);
                }
            }
        }
        return null;
    }

    private ResolveInfo createForwardingResolveInfo(CrossProfileIntentFilter filter, Intent intent, String resolvedType, int flags, int sourceUserId) {
        int targetUserId = filter.getTargetUserId();
        List<ResolveInfo> resultTargetUser = this.mActivities.queryIntent(intent, resolvedType, flags, targetUserId);
        if (resultTargetUser != null && isUserEnabled(targetUserId)) {
            for (int i = resultTargetUser.size() - 1; i >= 0; i--) {
                if ((((ResolveInfo) resultTargetUser.get(i)).activityInfo.applicationInfo.flags & 1073741824) == 0) {
                    return createForwardingResolveInfoUnchecked(filter, sourceUserId, targetUserId);
                }
            }
        }
        return null;
    }

    private ResolveInfo createForwardingResolveInfoUnchecked(IntentFilter filter, int sourceUserId, int targetUserId) {
        ResolveInfo forwardingResolveInfo = new ResolveInfo();
        long ident = Binder.clearCallingIdentity();
        try {
            String className;
            boolean targetIsProfile = sUserManager.getUserInfo(targetUserId).isManagedProfile();
            if (targetIsProfile) {
                className = IntentForwarderActivity.FORWARD_INTENT_TO_MANAGED_PROFILE;
            } else {
                className = IntentForwarderActivity.FORWARD_INTENT_TO_PARENT;
            }
            ActivityInfo forwardingActivityInfo = getActivityInfo(new ComponentName(this.mAndroidApplication.packageName, className), 0, sourceUserId);
            if (!targetIsProfile) {
                forwardingActivityInfo.showUserIcon = targetUserId;
                forwardingResolveInfo.noResourceId = true;
            }
            forwardingResolveInfo.activityInfo = forwardingActivityInfo;
            forwardingResolveInfo.priority = 0;
            forwardingResolveInfo.preferredOrder = 0;
            forwardingResolveInfo.match = 0;
            forwardingResolveInfo.isDefault = true;
            forwardingResolveInfo.filter = filter;
            forwardingResolveInfo.targetUserId = targetUserId;
            return forwardingResolveInfo;
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public ParceledListSlice<ResolveInfo> queryIntentActivityOptions(ComponentName caller, Intent[] specifics, String[] specificTypes, Intent intent, String resolvedType, int flags, int userId) {
        return new ParceledListSlice(queryIntentActivityOptionsInternal(caller, specifics, specificTypes, intent, resolvedType, flags, userId));
    }

    private List<ResolveInfo> queryIntentActivityOptionsInternal(ComponentName caller, Intent[] specifics, String[] specificTypes, Intent intent, String resolvedType, int flags, int userId) {
        PackageManagerService packageManagerService = this;
        Intent[] intentArr = specifics;
        Intent intent2 = intent;
        int i = userId;
        if (!sUserManager.exists(i)) {
            return Collections.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        int i2 = i;
        int flags2 = packageManagerService.updateFlagsForResolve(flags, i2, intent2, callingUid, false);
        packageManagerService.mPermissionManager.enforceCrossUserPermission(callingUid, i2, false, false, "query intent activity options");
        if (intent2 == null) {
            return Collections.emptyList();
        }
        int specificsPos;
        int specificsPos2;
        StringBuilder stringBuilder;
        String action;
        String str;
        int i3;
        String resultsAction = intent.getAction();
        List<ResolveInfo> results = packageManagerService.queryIntentActivitiesInternal(intent2, resolvedType, flags2 | 64, i);
        if (DEBUG_INTENT_MATCHING) {
            String str2 = TAG;
            StringBuilder stringBuilder2 = new StringBuilder();
            stringBuilder2.append("Query ");
            stringBuilder2.append(intent2);
            stringBuilder2.append(": ");
            stringBuilder2.append(results);
            Log.v(str2, stringBuilder2.toString());
        }
        if (intentArr != null) {
            specificsPos = 0;
            specificsPos2 = 0;
            while (specificsPos2 < intentArr.length) {
                Intent sintent = intentArr[specificsPos2];
                if (sintent != null) {
                    ActivityInfo ai;
                    ResolveInfo ri;
                    ResolveInfo ri2;
                    if (DEBUG_INTENT_MATCHING) {
                        String str3 = TAG;
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("Specific #");
                        stringBuilder.append(specificsPos2);
                        stringBuilder.append(": ");
                        stringBuilder.append(sintent);
                        Log.v(str3, stringBuilder.toString());
                    }
                    action = sintent.getAction();
                    if (resultsAction != null && resultsAction.equals(action)) {
                        action = null;
                    }
                    ComponentName comp = sintent.getComponent();
                    ResolveInfo resolveInfo;
                    if (comp == null) {
                        ResolveInfo ri3;
                        if (specificTypes != null) {
                            resolveInfo = null;
                            ri3 = specificTypes[specificsPos2];
                        } else {
                            resolveInfo = null;
                            ri3 = null;
                        }
                        ri3 = packageManagerService.resolveIntent(sintent, ri3, flags2, i);
                        if (ri3 != null) {
                            ResolveInfo resolveInfo2 = packageManagerService.mResolveInfo;
                            ai = ri3.activityInfo;
                            ri = ri3;
                            comp = new ComponentName(ai.applicationInfo.packageName, ai.name);
                        }
                    } else {
                        resolveInfo = null;
                        ai = packageManagerService.getActivityInfo(comp, flags2, i);
                        if (ai != null) {
                            ri = resolveInfo;
                        }
                    }
                    if (DEBUG_INTENT_MATCHING) {
                        String str4 = TAG;
                        StringBuilder stringBuilder3 = new StringBuilder();
                        stringBuilder3.append("Specific #");
                        stringBuilder3.append(specificsPos2);
                        stringBuilder3.append(": ");
                        stringBuilder3.append(ai);
                        Log.v(str4, stringBuilder3.toString());
                    }
                    int N = results.size();
                    int j = specificsPos;
                    while (j < N) {
                        ComponentName comp2;
                        ResolveInfo sri = (ResolveInfo) results.get(j);
                        if (!(sri.activityInfo.name.equals(comp.getClassName()) && sri.activityInfo.applicationInfo.packageName.equals(comp.getPackageName())) && (action == null || !sri.filter.matchAction(action))) {
                            comp2 = comp;
                        } else {
                            results.remove(j);
                            if (DEBUG_INTENT_MATCHING) {
                                str = TAG;
                                StringBuilder stringBuilder4 = new StringBuilder();
                                comp2 = comp;
                                stringBuilder4.append("Removing duplicate item from ");
                                stringBuilder4.append(j);
                                stringBuilder4.append(" due to specific ");
                                stringBuilder4.append(specificsPos);
                                Log.v(str, stringBuilder4.toString());
                            } else {
                                comp2 = comp;
                            }
                            if (ri == null) {
                                ri = sri;
                            }
                            j--;
                            N--;
                        }
                        j++;
                        comp = comp2;
                        intent2 = intent;
                    }
                    if (ri == null) {
                        ri2 = new ResolveInfo();
                        ri2.activityInfo = ai;
                    } else {
                        ri2 = ri;
                    }
                    results.add(specificsPos, ri2);
                    ri2.specificIndex = specificsPos2;
                    specificsPos++;
                }
                specificsPos2++;
                String str5 = resolvedType;
                packageManagerService = this;
                intentArr = specifics;
                intent2 = intent;
            }
        } else {
            specificsPos = 0;
        }
        specificsPos2 = results.size();
        for (i2 = specificsPos; i2 < specificsPos2 - 1; i2++) {
            ResolveInfo rii = (ResolveInfo) results.get(i2);
            if (rii.filter != null) {
                Iterator<String> it = rii.filter.actionsIterator();
                if (it != null) {
                    while (it.hasNext()) {
                        str = (String) it.next();
                        if (resultsAction == null || !resultsAction.equals(str)) {
                            int j2 = i2 + 1;
                            while (j2 < specificsPos2) {
                                ResolveInfo rij = (ResolveInfo) results.get(j2);
                                if (rij.filter != null && rij.filter.hasAction(str)) {
                                    results.remove(j2);
                                    if (DEBUG_INTENT_MATCHING) {
                                        String str6 = TAG;
                                        StringBuilder stringBuilder5 = new StringBuilder();
                                        stringBuilder5.append("Removing duplicate item from ");
                                        stringBuilder5.append(j2);
                                        stringBuilder5.append(" due to action ");
                                        stringBuilder5.append(str);
                                        stringBuilder5.append(" at ");
                                        stringBuilder5.append(i2);
                                        Log.v(str6, stringBuilder5.toString());
                                    }
                                    j2--;
                                    specificsPos2--;
                                }
                                j2++;
                            }
                        }
                    }
                    if ((flags2 & 64) == 0) {
                        rii.filter = null;
                    }
                }
            }
        }
        if (caller != null) {
            specificsPos2 = results.size();
            for (i3 = 0; i3 < specificsPos2; i3++) {
                ActivityInfo ainfo = ((ResolveInfo) results.get(i3)).activityInfo;
                if (caller.getPackageName().equals(ainfo.applicationInfo.packageName) && caller.getClassName().equals(ainfo.name)) {
                    results.remove(i3);
                    break;
                }
            }
        }
        if ((flags2 & 64) == 0) {
            specificsPos2 = results.size();
            int i4 = 0;
            while (true) {
                i3 = i4;
                if (i3 >= specificsPos2) {
                    break;
                }
                ((ResolveInfo) results.get(i3)).filter = null;
                i4 = i3 + 1;
            }
        }
        if (DEBUG_INTENT_MATCHING) {
            action = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("Result: ");
            stringBuilder.append(results);
            Log.v(action, stringBuilder.toString());
        }
        return results;
    }

    public ParceledListSlice<ResolveInfo> queryIntentReceivers(Intent intent, String resolvedType, int flags, int userId) {
        return new ParceledListSlice(queryIntentReceiversInternal(intent, resolvedType, flags, userId, false));
    }

    /* JADX WARNING: Removed duplicated region for block: B:62:0x00cc  */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private List<ResolveInfo> queryIntentReceiversInternal(Intent intent, String resolvedType, int flags, int userId, boolean allowDynamicSplits) {
        int i = userId;
        if (!sUserManager.exists(i)) {
            return Collections.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        int i2 = i;
        this.mPermissionManager.enforceCrossUserPermission(callingUid, i2, false, false, "query intent receivers");
        String instantAppPkgName = getInstantAppPackageName(callingUid);
        int flags2 = updateFlagsForResolve(flags, i2, intent, callingUid, false);
        if (intent == null) {
            return Collections.emptyList();
        }
        Intent intent2;
        ComponentName comp = intent.getComponent();
        if (comp != null || intent.getSelector() == null) {
            intent2 = intent;
        } else {
            Intent intent3 = intent.getSelector();
            comp = intent3.getComponent();
            intent2 = intent3;
        }
        ComponentName comp2 = comp;
        if (comp2 != null) {
            List<ResolveInfo> list = new ArrayList(1);
            ActivityInfo ai = getReceiverInfo(comp2, flags2, i);
            if (ai != null) {
                boolean isTargetHiddenFromInstantApp;
                boolean blockResolution;
                boolean matchInstantApp = (DumpState.DUMP_VOLUMES & flags2) != 0;
                boolean matchVisibleToInstantAppOnly = (DumpState.DUMP_SERVICE_PERMISSIONS & flags2) != 0;
                boolean matchExplicitlyVisibleOnly = (DumpState.DUMP_HANDLE & flags2) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                boolean isTargetSameInstantApp = comp2.getPackageName().equals(instantAppPkgName);
                boolean isTargetInstantApp = (ai.applicationInfo.privateFlags & 128) != 0;
                boolean isTargetVisibleToInstantApp = (ai.flags & 1048576) != 0;
                if (isTargetVisibleToInstantApp) {
                    if ((ai.flags & 2097152) == null) {
                        comp2 = true;
                        isTargetHiddenFromInstantApp = isTargetVisibleToInstantApp || (matchExplicitlyVisibleOnly && comp2 == null);
                        blockResolution = isTargetSameInstantApp && (!(matchInstantApp || isCallerInstantApp || !isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && isTargetHiddenFromInstantApp));
                        if (!blockResolution) {
                            ResolveInfo ri = new ResolveInfo();
                            ri.activityInfo = ai;
                            list.add(ri);
                        }
                    }
                }
                comp2 = null;
                if (isTargetVisibleToInstantApp) {
                }
                if (isTargetSameInstantApp) {
                }
                if (blockResolution) {
                }
            }
            ActivityInfo comp3 = ai;
            return applyPostResolutionFilter(list, instantAppPkgName, allowDynamicSplits, callingUid, false, i, intent2);
        }
        synchronized (this.mPackages) {
            String pkgName = intent2.getPackage();
            List applyPostResolutionFilter;
            if (pkgName == null) {
                applyPostResolutionFilter = applyPostResolutionFilter(this.mReceivers.queryIntent(intent2, resolvedType, flags2, i), instantAppPkgName, allowDynamicSplits, callingUid, false, i, intent2);
                return applyPostResolutionFilter;
            }
            Package pkg = (Package) this.mPackages.get(pkgName);
            if (pkg != null) {
                applyPostResolutionFilter = applyPostResolutionFilter(this.mReceivers.queryIntentForPackage(intent2, resolvedType, flags2, pkg.receivers, i), instantAppPkgName, allowDynamicSplits, callingUid, false, i, intent2);
                return applyPostResolutionFilter;
            }
            applyPostResolutionFilter = Collections.emptyList();
            return applyPostResolutionFilter;
        }
    }

    public ResolveInfo resolveService(Intent intent, String resolvedType, int flags, int userId) {
        return resolveServiceInternal(intent, resolvedType, flags, userId, Binder.getCallingUid());
    }

    private ResolveInfo resolveServiceInternal(Intent intent, String resolvedType, int flags, int userId, int callingUid) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        List<ResolveInfo> query = queryIntentServicesInternal(intent, resolvedType, updateFlagsForResolve(flags, userId, intent, callingUid, false), userId, callingUid, false);
        if (query == null || query.size() < 1) {
            return null;
        }
        return (ResolveInfo) query.get(0);
    }

    public ParceledListSlice<ResolveInfo> queryIntentServices(Intent intent, String resolvedType, int flags, int userId) {
        return new ParceledListSlice(queryIntentServicesInternal(intent, resolvedType, flags, userId, Binder.getCallingUid(), false));
    }

    private List<ResolveInfo> queryIntentServicesInternal(Intent intent, String resolvedType, int flags, int userId, int callingUid, boolean includeInstantApps) {
        Throwable th;
        int i = userId;
        if (!sUserManager.exists(i)) {
            return Collections.emptyList();
        }
        int i2 = i;
        this.mPermissionManager.enforceCrossUserPermission(callingUid, i2, false, false, "query intent receivers");
        int i3 = callingUid;
        String instantAppPkgName = getInstantAppPackageName(i3);
        int flags2 = updateFlagsForResolve(flags, i2, intent, i3, includeInstantApps);
        if (intent == null) {
            return Collections.emptyList();
        }
        Intent intent2;
        ComponentName comp = intent.getComponent();
        if (comp != null || intent.getSelector() == null) {
            intent2 = intent;
        } else {
            Intent intent3 = intent.getSelector();
            comp = intent3.getComponent();
            intent2 = intent3;
        }
        ComponentName comp2 = comp;
        if (comp2 != null) {
            List<ResolveInfo> list = new ArrayList(1);
            ServiceInfo si = getServiceInfo(comp2, flags2, i);
            if (si != null) {
                boolean matchInstantApp = (DumpState.DUMP_VOLUMES & flags2) != 0;
                boolean matchVisibleToInstantAppOnly = (DumpState.DUMP_SERVICE_PERMISSIONS & flags2) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                boolean isTargetSameInstantApp = comp2.getPackageName().equals(instantAppPkgName);
                boolean isTargetInstantApp = (si.applicationInfo.privateFlags & 128) != 0;
                boolean isTargetHiddenFromInstantApp = (si.flags & 1048576) == 0;
                boolean z = !isTargetSameInstantApp && (!(matchInstantApp || isCallerInstantApp || !isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && isTargetHiddenFromInstantApp));
                if (!z) {
                    ResolveInfo ri = new ResolveInfo();
                    ri.serviceInfo = si;
                    list.add(ri);
                }
            }
            return list;
        }
        synchronized (this.mPackages) {
            String str;
            try {
                String pkgName = intent2.getPackage();
                List applyPostServiceResolutionFilter;
                if (pkgName == null) {
                    applyPostServiceResolutionFilter = applyPostServiceResolutionFilter(this.mServices.queryIntent(intent2, resolvedType, flags2, i), instantAppPkgName);
                    return applyPostServiceResolutionFilter;
                }
                str = resolvedType;
                Package pkg = (Package) this.mPackages.get(pkgName);
                if (pkg != null) {
                    applyPostServiceResolutionFilter = applyPostServiceResolutionFilter(this.mServices.queryIntentForPackage(intent2, str, flags2, pkg.services, i), instantAppPkgName);
                    return applyPostServiceResolutionFilter;
                }
                applyPostServiceResolutionFilter = Collections.emptyList();
                return applyPostServiceResolutionFilter;
            } catch (Throwable th2) {
                th = th2;
                throw th;
            }
        }
    }

    private List<ResolveInfo> applyPostServiceResolutionFilter(List<ResolveInfo> resolveInfos, String instantAppPkgName) {
        if (instantAppPkgName == null) {
            return resolveInfos;
        }
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            ResolveInfo info = (ResolveInfo) resolveInfos.get(i);
            boolean isEphemeralApp = info.serviceInfo.applicationInfo.isInstantApp();
            if (isEphemeralApp && instantAppPkgName.equals(info.serviceInfo.packageName)) {
                if (!(info.serviceInfo.splitName == null || ArrayUtils.contains(info.serviceInfo.applicationInfo.splitNames, info.serviceInfo.splitName))) {
                    if (DEBUG_INSTANT) {
                        Slog.v(TAG, "Adding ephemeral installer to the ResolveInfo list");
                    }
                    ResolveInfo installerInfo = new ResolveInfo(this.mInstantAppInstallerInfo);
                    installerInfo.auxiliaryInfo = new AuxiliaryResolveInfo(null, info.serviceInfo.packageName, info.serviceInfo.applicationInfo.longVersionCode, info.serviceInfo.splitName);
                    installerInfo.filter = new IntentFilter();
                    installerInfo.resolvePackageName = info.getComponentInfo().packageName;
                    resolveInfos.set(i, installerInfo);
                }
            } else if (isEphemeralApp || (info.serviceInfo.flags & 1048576) == 0) {
                resolveInfos.remove(i);
            }
        }
        return resolveInfos;
    }

    public ParceledListSlice<ResolveInfo> queryIntentContentProviders(Intent intent, String resolvedType, int flags, int userId) {
        return new ParceledListSlice(queryIntentContentProvidersInternal(intent, resolvedType, flags, userId));
    }

    private List<ResolveInfo> queryIntentContentProvidersInternal(Intent intent, String resolvedType, int flags, int userId) {
        Throwable th;
        int i = userId;
        if (!sUserManager.exists(i)) {
            return Collections.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        String instantAppPkgName = getInstantAppPackageName(callingUid);
        int flags2 = updateFlagsForResolve(flags, i, intent, callingUid, false);
        if (intent == null) {
            return Collections.emptyList();
        }
        Intent intent2;
        ComponentName comp = intent.getComponent();
        if (comp != null || intent.getSelector() == null) {
            intent2 = intent;
        } else {
            Intent intent3 = intent.getSelector();
            comp = intent3.getComponent();
            intent2 = intent3;
        }
        ComponentName comp2 = comp;
        if (comp2 != null) {
            List<ResolveInfo> list = new ArrayList(1);
            ProviderInfo pi = getProviderInfo(comp2, flags2, i);
            if (pi != null) {
                boolean matchInstantApp = (DumpState.DUMP_VOLUMES & flags2) != 0;
                boolean matchVisibleToInstantAppOnly = (DumpState.DUMP_SERVICE_PERMISSIONS & flags2) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                boolean isTargetSameInstantApp = comp2.getPackageName().equals(instantAppPkgName);
                boolean isTargetInstantApp = (pi.applicationInfo.privateFlags & 128) != 0;
                boolean isTargetHiddenFromInstantApp = (pi.flags & 1048576) == 0;
                boolean z = !isTargetSameInstantApp && (!(matchInstantApp || isCallerInstantApp || !isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && isTargetHiddenFromInstantApp));
                if (!z) {
                    ResolveInfo ri = new ResolveInfo();
                    ri.providerInfo = pi;
                    list.add(ri);
                }
            }
            return list;
        }
        synchronized (this.mPackages) {
            String str;
            try {
                String pkgName = intent2.getPackage();
                List applyPostContentProviderResolutionFilter;
                if (pkgName == null) {
                    applyPostContentProviderResolutionFilter = applyPostContentProviderResolutionFilter(this.mProviders.queryIntent(intent2, resolvedType, flags2, i), instantAppPkgName);
                    return applyPostContentProviderResolutionFilter;
                }
                str = resolvedType;
                Package pkg = (Package) this.mPackages.get(pkgName);
                if (pkg != null) {
                    applyPostContentProviderResolutionFilter = applyPostContentProviderResolutionFilter(this.mProviders.queryIntentForPackage(intent2, str, flags2, pkg.providers, i), instantAppPkgName);
                    return applyPostContentProviderResolutionFilter;
                }
                applyPostContentProviderResolutionFilter = Collections.emptyList();
                return applyPostContentProviderResolutionFilter;
            } catch (Throwable th2) {
                th = th2;
                throw th;
            }
        }
    }

    private List<ResolveInfo> applyPostContentProviderResolutionFilter(List<ResolveInfo> resolveInfos, String instantAppPkgName) {
        if (instantAppPkgName == null) {
            return resolveInfos;
        }
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            ResolveInfo info = (ResolveInfo) resolveInfos.get(i);
            boolean isEphemeralApp = info.providerInfo.applicationInfo.isInstantApp();
            if (isEphemeralApp && instantAppPkgName.equals(info.providerInfo.packageName)) {
                if (!(info.providerInfo.splitName == null || ArrayUtils.contains(info.providerInfo.applicationInfo.splitNames, info.providerInfo.splitName))) {
                    if (DEBUG_INSTANT) {
                        Slog.v(TAG, "Adding ephemeral installer to the ResolveInfo list");
                    }
                    ResolveInfo installerInfo = new ResolveInfo(this.mInstantAppInstallerInfo);
                    installerInfo.auxiliaryInfo = new AuxiliaryResolveInfo(null, info.providerInfo.packageName, info.providerInfo.applicationInfo.longVersionCode, info.providerInfo.splitName);
                    installerInfo.filter = new IntentFilter();
                    installerInfo.resolvePackageName = info.getComponentInfo().packageName;
                    resolveInfos.set(i, installerInfo);
                }
            } else if (isEphemeralApp || (info.providerInfo.flags & 1048576) == 0) {
                resolveInfos.remove(i);
            }
        }
        return resolveInfos;
    }

    public void onSystemServiceStartComplete() {
        synchronized (this.mPackages) {
            Slog.v(TAG, "onSystemServiceStartComplete() clear installed-packages cache");
            this.mCacheInstalledPackages = null;
        }
    }

    /* JADX WARNING: Missing block: B:66:0x01d8, code skipped:
            r2 = TAG;
            r5 = new java.lang.StringBuilder();
            r5.append("getInstalledPackages cost ");
            r5.append(android.os.SystemClock.uptimeMillis() - r0);
            r5.append(" ms, flags: ");
            r5.append(r13);
            r5.append(", userId: ");
            r5.append(r14);
            r5.append(", callingUid: ");
            r5.append(r8);
            r5.append(", callingPid: ");
            r5.append(r9);
            android.util.Log.i(r2, r5.toString());
     */
    /* JADX WARNING: Missing block: B:67:0x0213, code skipped:
            return r4;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public ParceledListSlice<PackageInfo> getInstalledPackages(int flags, int userId) {
        long startTime = SystemClock.uptimeMillis();
        int callingUid = Binder.getCallingUid();
        int callingPid = Binder.getCallingPid();
        int originFlag = flags;
        try {
            HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(BehaviorId.PACKAGEMANAGER_GETINSTALLEDPACKAGES);
            ParceledListSlice emptyList;
            String str;
            StringBuilder stringBuilder;
            if (getInstantAppPackageName(callingUid) != null) {
                emptyList = ParceledListSlice.emptyList();
                str = TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("getInstalledPackages cost ");
                stringBuilder.append(SystemClock.uptimeMillis() - startTime);
                stringBuilder.append(" ms, flags: ");
                stringBuilder.append(flags);
                stringBuilder.append(", userId: ");
                stringBuilder.append(userId);
                stringBuilder.append(", callingUid: ");
                stringBuilder.append(callingUid);
                stringBuilder.append(", callingPid: ");
                stringBuilder.append(callingPid);
                Log.i(str, stringBuilder.toString());
                return emptyList;
            } else if (sUserManager.exists(userId)) {
                flags = updateFlagsForPackage(flags, userId, null);
                boolean listUninstalled = (4202496 & flags) != 0;
                this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get installed packages");
                synchronized (this.mPackages) {
                    ArrayList<PackageInfo> list;
                    if (userId == 0) {
                        if (this.mCacheInstalledPackages != null) {
                            ParceledListSlice<PackageInfo> cache = (ParceledListSlice) this.mCacheInstalledPackages.get(Integer.valueOf(flags));
                            if (cache != null) {
                                String str2 = TAG;
                                StringBuilder stringBuilder2 = new StringBuilder();
                                stringBuilder2.append("getInstalledPackages() return cache, origin flags: ");
                                stringBuilder2.append(originFlag);
                                Slog.v(str2, stringBuilder2.toString());
                                String str3 = TAG;
                                stringBuilder = new StringBuilder();
                                stringBuilder.append("getInstalledPackages cost ");
                                stringBuilder.append(SystemClock.uptimeMillis() - startTime);
                                stringBuilder.append(" ms, flags: ");
                                stringBuilder.append(flags);
                                stringBuilder.append(", userId: ");
                                stringBuilder.append(userId);
                                stringBuilder.append(", callingUid: ");
                                stringBuilder.append(callingUid);
                                stringBuilder.append(", callingPid: ");
                                stringBuilder.append(callingPid);
                                Log.i(str3, stringBuilder.toString());
                                return cache;
                            }
                        }
                    }
                    if (listUninstalled) {
                        list = new ArrayList(this.mSettings.mPackages.size());
                        for (PackageSetting ps : this.mSettings.mPackages.values()) {
                            if (!filterSharedLibPackageLPr(ps, callingUid, userId, flags)) {
                                if (!filterAppAccessLPr(ps, callingUid, userId)) {
                                    PackageInfo pi = generatePackageInfo(ps, flags, userId);
                                    if (pi != null) {
                                        list.add(pi);
                                    }
                                }
                            }
                        }
                    } else {
                        list = new ArrayList(this.mPackages.size());
                        for (Package p : this.mPackages.values()) {
                            PackageSetting ps2 = p.mExtras;
                            if (!filterSharedLibPackageLPr(ps2, callingUid, userId, flags)) {
                                if (!filterAppAccessLPr(ps2, callingUid, userId)) {
                                    PackageInfo pi2 = generatePackageInfo((PackageSetting) p.mExtras, flags, userId);
                                    if (pi2 != null) {
                                        list.add(pi2);
                                    }
                                }
                            }
                        }
                    }
                    ParceledListSlice<PackageInfo> ret = new ParceledListSlice(list);
                    if (userId == 0 && this.mCacheInstalledPackages != null) {
                        this.mCacheInstalledPackages.put(Integer.valueOf(flags), ret);
                        String str4 = TAG;
                        StringBuilder stringBuilder3 = new StringBuilder();
                        stringBuilder3.append("getInstalledPackages() cache installed packages, origin flags: ");
                        stringBuilder3.append(originFlag);
                        Slog.v(str4, stringBuilder3.toString());
                    }
                }
            } else {
                emptyList = ParceledListSlice.emptyList();
                str = TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("getInstalledPackages cost ");
                stringBuilder.append(SystemClock.uptimeMillis() - startTime);
                stringBuilder.append(" ms, flags: ");
                stringBuilder.append(flags);
                stringBuilder.append(", userId: ");
                stringBuilder.append(userId);
                stringBuilder.append(", callingUid: ");
                stringBuilder.append(callingUid);
                stringBuilder.append(", callingPid: ");
                stringBuilder.append(callingPid);
                Log.i(str, stringBuilder.toString());
                return emptyList;
            }
        } catch (Throwable th) {
            StringBuilder stringBuilder4 = new StringBuilder();
            stringBuilder4.append("getInstalledPackages cost ");
            stringBuilder4.append(SystemClock.uptimeMillis() - startTime);
            stringBuilder4.append(" ms, flags: ");
            stringBuilder4.append(flags);
            stringBuilder4.append(", userId: ");
            stringBuilder4.append(userId);
            stringBuilder4.append(", callingUid: ");
            stringBuilder4.append(callingUid);
            stringBuilder4.append(", callingPid: ");
            stringBuilder4.append(callingPid);
            Log.i(TAG, stringBuilder4.toString());
        }
    }

    private void addPackageHoldingPermissions(ArrayList<PackageInfo> list, PackageSetting ps, String[] permissions, boolean[] tmp, int flags, int userId) {
        PermissionsState permissionsState = ps.getPermissionsState();
        int i = 0;
        int numMatch = 0;
        for (int i2 = 0; i2 < permissions.length; i2++) {
            if (permissionsState.hasPermission(permissions[i2], userId)) {
                tmp[i2] = true;
                numMatch++;
            } else {
                tmp[i2] = false;
            }
        }
        if (numMatch != 0) {
            PackageInfo pi = generatePackageInfo(ps, flags, userId);
            if (pi != null) {
                if ((flags & 4096) == 0) {
                    if (numMatch == permissions.length) {
                        pi.requestedPermissions = permissions;
                    } else {
                        pi.requestedPermissions = new String[numMatch];
                        numMatch = 0;
                        while (i < permissions.length) {
                            if (tmp[i]) {
                                pi.requestedPermissions[numMatch] = permissions[i];
                                numMatch++;
                            }
                            i++;
                        }
                    }
                }
                list.add(pi);
            }
        }
    }

    public ParceledListSlice<PackageInfo> getPackagesHoldingPermissions(String[] permissions, int flags, int userId) {
        Throwable th;
        Object obj = permissions;
        int i = userId;
        if (!sUserManager.exists(i)) {
            return ParceledListSlice.emptyList();
        }
        int flags2 = updateFlagsForPackage(flags, i, obj);
        boolean z = true;
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), i, true, false, "get packages holding permissions");
        boolean listUninstalled = (flags2 & 4202496) != 0;
        ArrayMap arrayMap = this.mPackages;
        synchronized (arrayMap) {
            try {
                ArrayList<PackageInfo> list = new ArrayList();
                boolean[] tmpBools = new boolean[obj.length];
                PackageSetting ps;
                if (listUninstalled) {
                    for (PackageSetting ps2 : this.mSettings.mPackages.values()) {
                        addPackageHoldingPermissions(list, ps2, obj, tmpBools, flags2, i);
                    }
                } else {
                    for (Package pkg : this.mPackages.values()) {
                        ps2 = (PackageSetting) pkg.mExtras;
                        if (ps2 != null) {
                            z = arrayMap;
                            addPackageHoldingPermissions(list, ps2, obj, tmpBools, flags2, i);
                        } else {
                            z = arrayMap;
                        }
                        arrayMap = z;
                    }
                }
                ArrayMap arrayMap2 = arrayMap;
                ParceledListSlice parceledListSlice = new ParceledListSlice(list);
                return parceledListSlice;
            } catch (Throwable th2) {
                th = th2;
                throw th;
            }
        }
    }

    public ParceledListSlice<ApplicationInfo> getInstalledApplications(int flags, int userId) {
        long startTime = SystemClock.uptimeMillis();
        int callingUid = Binder.getCallingUid();
        int callingPid = Binder.getCallingPid();
        try {
            HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(BehaviorId.PACKAGEMANAGER_GETINSTALLEDAPPLICATIONS);
            ParceledListSlice emptyList;
            String str;
            StringBuilder stringBuilder;
            if (getInstantAppPackageName(callingUid) != null) {
                emptyList = ParceledListSlice.emptyList();
                str = TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("getInstalledApplications cost ");
                stringBuilder.append(SystemClock.uptimeMillis() - startTime);
                stringBuilder.append(" ms, flags: ");
                stringBuilder.append(flags);
                stringBuilder.append(", userId: ");
                stringBuilder.append(userId);
                stringBuilder.append(", callingUid: ");
                stringBuilder.append(callingUid);
                stringBuilder.append(", callingPid: ");
                stringBuilder.append(callingPid);
                Log.i(str, stringBuilder.toString());
                return emptyList;
            } else if (sUserManager.exists(userId)) {
                ParceledListSlice parceledListSlice;
                flags = updateFlagsForApplication(flags, userId, null);
                boolean listUninstalled = (4202496 & flags) != 0;
                this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get installed application info");
                synchronized (this.mPackages) {
                    ArrayList<ApplicationInfo> list;
                    ApplicationInfo ai;
                    if (listUninstalled) {
                        list = new ArrayList(this.mSettings.mPackages.size());
                        for (PackageSetting ps : this.mSettings.mPackages.values()) {
                            int effectiveFlags = flags;
                            if (ps.isSystem()) {
                                effectiveFlags |= DumpState.DUMP_CHANGES;
                            }
                            if (ps.pkg == null) {
                                ai = generateApplicationInfoFromSettingsLPw(ps.name, callingUid, effectiveFlags, userId);
                            } else if (!filterSharedLibPackageLPr(ps, callingUid, userId, flags)) {
                                if (!filterAppAccessLPr(ps, callingUid, userId)) {
                                    ai = PackageParser.generateApplicationInfo(ps.pkg, effectiveFlags, ps.readUserState(userId), userId);
                                    if (ai != null) {
                                        ai.packageName = resolveExternalPackageNameLPr(ps.pkg);
                                    }
                                }
                            }
                            if (ai != null) {
                                list.add(ai);
                            }
                        }
                    } else {
                        list = new ArrayList(this.mPackages.size());
                        for (Package p : this.mPackages.values()) {
                            if (p.mExtras != null) {
                                PackageSetting ps2 = p.mExtras;
                                if (!filterSharedLibPackageLPr(ps2, Binder.getCallingUid(), userId, flags)) {
                                    if (!filterAppAccessLPr(ps2, callingUid, userId)) {
                                        ai = PackageParser.generateApplicationInfo(p, flags, ps2.readUserState(userId), userId);
                                        if (ai != null) {
                                            ai.packageName = resolveExternalPackageNameLPr(p);
                                            list.add(ai);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    parceledListSlice = new ParceledListSlice(list);
                }
                String str2 = TAG;
                StringBuilder stringBuilder2 = new StringBuilder();
                stringBuilder2.append("getInstalledApplications cost ");
                stringBuilder2.append(SystemClock.uptimeMillis() - startTime);
                stringBuilder2.append(" ms, flags: ");
                stringBuilder2.append(flags);
                stringBuilder2.append(", userId: ");
                stringBuilder2.append(userId);
                stringBuilder2.append(", callingUid: ");
                stringBuilder2.append(callingUid);
                stringBuilder2.append(", callingPid: ");
                stringBuilder2.append(callingPid);
                Log.i(str2, stringBuilder2.toString());
                return parceledListSlice;
            } else {
                emptyList = ParceledListSlice.emptyList();
                str = TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("getInstalledApplications cost ");
                stringBuilder.append(SystemClock.uptimeMillis() - startTime);
                stringBuilder.append(" ms, flags: ");
                stringBuilder.append(flags);
                stringBuilder.append(", userId: ");
                stringBuilder.append(userId);
                stringBuilder.append(", callingUid: ");
                stringBuilder.append(callingUid);
                stringBuilder.append(", callingPid: ");
                stringBuilder.append(callingPid);
                Log.i(str, stringBuilder.toString());
                return emptyList;
            }
        } catch (Throwable th) {
            StringBuilder stringBuilder3 = new StringBuilder();
            stringBuilder3.append("getInstalledApplications cost ");
            stringBuilder3.append(SystemClock.uptimeMillis() - startTime);
            stringBuilder3.append(" ms, flags: ");
            stringBuilder3.append(flags);
            stringBuilder3.append(", userId: ");
            stringBuilder3.append(userId);
            stringBuilder3.append(", callingUid: ");
            stringBuilder3.append(callingUid);
            stringBuilder3.append(", callingPid: ");
            stringBuilder3.append(callingPid);
            Log.i(TAG, stringBuilder3.toString());
        }
    }

    public ParceledListSlice<InstantAppInfo> getInstantApps(int userId) {
        if (!canViewInstantApps(Binder.getCallingUid(), userId)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS", "getEphemeralApplications");
        }
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getEphemeralApplications");
        synchronized (this.mPackages) {
            List<InstantAppInfo> instantApps = this.mInstantAppRegistry.getInstantAppsLPr(userId);
            if (instantApps != null) {
                ParceledListSlice parceledListSlice = new ParceledListSlice(instantApps);
                return parceledListSlice;
            }
            return null;
        }
    }

    /* JADX WARNING: Missing block: B:21:0x0056, code skipped:
            return r3;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean isInstantApp(String packageName, int userId) {
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "isInstantApp");
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            if (Process.isIsolated(callingUid)) {
                callingUid = this.mIsolatedOwners.get(callingUid);
            }
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            boolean returnAllowed = false;
            if (ps != null && !ps.getInstantApp(userId)) {
                return false;
            } else if (ps != null && (isCallerSameApp(packageName, callingUid) || canViewInstantApps(callingUid, userId) || this.mInstantAppRegistry.isInstantAccessGranted(userId, UserHandle.getAppId(callingUid), ps.appId))) {
                returnAllowed = true;
            }
        }
    }

    public byte[] getInstantAppCookie(String packageName, int userId) {
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getInstantAppCookie");
        if (!isCallerSameApp(packageName, Binder.getCallingUid())) {
            return null;
        }
        byte[] instantAppCookieLPw;
        synchronized (this.mPackages) {
            instantAppCookieLPw = this.mInstantAppRegistry.getInstantAppCookieLPw(packageName, userId);
        }
        return instantAppCookieLPw;
    }

    public boolean setInstantAppCookie(String packageName, byte[] cookie, int userId) {
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, true, "setInstantAppCookie");
        if (!isCallerSameApp(packageName, Binder.getCallingUid())) {
            return false;
        }
        boolean instantAppCookieLPw;
        synchronized (this.mPackages) {
            instantAppCookieLPw = this.mInstantAppRegistry.setInstantAppCookieLPw(packageName, cookie, userId);
        }
        return instantAppCookieLPw;
    }

    public Bitmap getInstantAppIcon(String packageName, int userId) {
        Bitmap instantAppIconLPw;
        if (!canViewInstantApps(Binder.getCallingUid(), userId)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS", "getInstantAppIcon");
        }
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getInstantAppIcon");
        synchronized (this.mPackages) {
            instantAppIconLPw = this.mInstantAppRegistry.getInstantAppIconLPw(packageName, userId);
        }
        return instantAppIconLPw;
    }

    private boolean isCallerSameApp(String packageName, int uid) {
        Package pkg = (Package) this.mPackages.get(packageName);
        return pkg != null && UserHandle.getAppId(uid) == pkg.applicationInfo.uid;
    }

    public ParceledListSlice<ApplicationInfo> getPersistentApplications(int flags) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return ParceledListSlice.emptyList();
        }
        return new ParceledListSlice(getPersistentApplicationsInternal(flags));
    }

    private List<ApplicationInfo> getPersistentApplicationsInternal(int flags) {
        ArrayList<ApplicationInfo> finalList = new ArrayList();
        synchronized (this.mPackages) {
            int userId = UserHandle.getCallingUserId();
            for (Package p : this.mPackages.values()) {
                if (p.applicationInfo != null) {
                    boolean matchesAware = false;
                    boolean matchesUnaware = ((262144 & flags) == 0 || p.applicationInfo.isDirectBootAware()) ? false : true;
                    if ((524288 & flags) != 0 && p.applicationInfo.isDirectBootAware()) {
                        matchesAware = true;
                    }
                    if ((p.applicationInfo.flags & 8) != 0 && ((!this.mSafeMode || isSystemApp(p)) && (matchesUnaware || matchesAware))) {
                        PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(p.packageName);
                        if (ps != null) {
                            ApplicationInfo ai = PackageParser.generateApplicationInfo(p, flags, ps.readUserState(userId), userId);
                            if (ai != null) {
                                finalList.add(ai);
                            }
                        }
                    }
                }
            }
        }
        return finalList;
    }

    public ProviderInfo resolveContentProvider(String name, int flags, int userId) {
        return resolveContentProviderInternal(name, flags, userId);
    }

    private ProviderInfo resolveContentProviderInternal(String name, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        flags = updateFlagsForComponent(flags, userId, name);
        int callingUid = Binder.getCallingUid();
        synchronized (this.mPackages) {
            PackageSetting packageSetting;
            Provider provider = (Provider) this.mProvidersByAuthority.get(name);
            if (provider != null) {
                packageSetting = (PackageSetting) this.mSettings.mPackages.get(provider.owner.packageName);
            } else {
                packageSetting = null;
            }
            PackageSetting ps = packageSetting;
            if (ps == null) {
                return null;
            } else if (this.mSettings.isEnabledAndMatchLPr(provider.info, flags, userId)) {
                if (filterAppAccessLPr(ps, callingUid, new ComponentName(provider.info.packageName, provider.info.name), 4, userId)) {
                    return null;
                }
                ProviderInfo generateProviderInfo = PackageParser.generateProviderInfo(provider, flags, ps.readUserState(userId), userId);
                return generateProviderInfo;
            } else {
                return null;
            }
        }
    }

    @Deprecated
    public void querySyncProviders(List<String> outNames, List<ProviderInfo> outInfo) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            synchronized (this.mPackages) {
                int userId = UserHandle.getCallingUserId();
                for (Entry<String, Provider> entry : this.mProvidersByAuthority.entrySet()) {
                    Provider p = (Provider) entry.getValue();
                    PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(p.owner.packageName);
                    if (!(ps == null || !p.syncable || (this.mSafeMode && (p.info.applicationInfo.flags & 1) == 0))) {
                        ProviderInfo info = PackageParser.generateProviderInfo(p, null, ps.readUserState(userId), userId);
                        if (info != null) {
                            outNames.add((String) entry.getKey());
                            outInfo.add(info);
                        }
                    }
                }
            }
        }
    }

    /* JADX WARNING: Missing block: B:60:0x00e7, code skipped:
            if (r14 == null) goto L_0x00f4;
     */
    /* JADX WARNING: Missing block: B:61:0x00e9, code skipped:
            java.util.Collections.sort(r14, mProviderInitOrderSorter);
     */
    /* JADX WARNING: Missing block: B:62:0x00f3, code skipped:
            return new android.content.pm.ParceledListSlice(r14);
     */
    /* JADX WARNING: Missing block: B:64:0x00f8, code skipped:
            return android.content.pm.ParceledListSlice.emptyList();
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public ParceledListSlice<ProviderInfo> queryContentProviders(String processName, int uid, int flags, String metaDataKey) {
        int userId;
        Throwable th;
        String str = processName;
        String str2 = metaDataKey;
        int callingUid = Binder.getCallingUid();
        if (str != null) {
            userId = UserHandle.getUserId(uid);
        } else {
            userId = UserHandle.getCallingUserId();
        }
        int userId2 = userId;
        if (!sUserManager.exists(userId2)) {
            return ParceledListSlice.emptyList();
        }
        int flags2 = updateFlagsForComponent(flags, userId2, str);
        synchronized (this.mPackages) {
            Iterator<Provider> i = this.mProviders.mProviders.values().iterator();
            ArrayList<ProviderInfo> finalList = null;
            while (i.hasNext()) {
                int i2;
                try {
                    Iterator<Provider> i3;
                    Provider p = (Provider) i.next();
                    PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(p.owner.packageName);
                    if (!(ps == null || p.info.authority == null)) {
                        if (str != null) {
                            if (!p.info.processName.equals(str)) {
                                i2 = uid;
                            } else if (UserHandle.isSameApp(p.info.applicationInfo.uid, uid)) {
                            }
                            i3 = i;
                            i = i3;
                        } else {
                            i2 = uid;
                        }
                        if (this.mSettings.isEnabledAndMatchLPr(p.info, flags2, userId2)) {
                            if (str2 != null) {
                                if (p.metaData != null) {
                                    if (!p.metaData.containsKey(str2)) {
                                    }
                                }
                                i3 = i;
                                i = i3;
                            }
                            i3 = i;
                            PackageSetting i4 = ps;
                            if (filterAppAccessLPr(ps, callingUid, new ComponentName(p.info.packageName, p.info.name), 4, userId2)) {
                                i = i3;
                            } else {
                                ArrayList<ProviderInfo> finalList2;
                                if (finalList == null) {
                                    finalList2 = new ArrayList(3);
                                } else {
                                    finalList2 = finalList;
                                }
                                try {
                                    ProviderInfo info = PackageParser.generateProviderInfo(p, flags2, i4.readUserState(userId2), userId2);
                                    if (info != null) {
                                        finalList2.add(info);
                                    }
                                    finalList = finalList2;
                                    i = i3;
                                } catch (Throwable th2) {
                                    th = th2;
                                    throw th;
                                }
                            }
                        }
                    }
                    i3 = i;
                    i = i3;
                } catch (Throwable th3) {
                    th = th3;
                    throw th;
                }
            }
        }
    }

    public InstrumentationInfo getInstrumentationInfo(ComponentName component, int flags) {
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            if (component == null) {
                return null;
            }
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return null;
            } else if (filterAppAccessLPr(ps, callingUid, component, 0, callingUserId)) {
                return null;
            } else {
                InstrumentationInfo generateInstrumentationInfo = PackageParser.generateInstrumentationInfo((Instrumentation) this.mInstrumentation.get(component), flags);
                return generateInstrumentationInfo;
            }
        }
    }

    public ParceledListSlice<InstrumentationInfo> queryInstrumentation(String targetPackage, int flags) {
        int callingUid = Binder.getCallingUid();
        if (filterAppAccessLPr((PackageSetting) this.mSettings.mPackages.get(targetPackage), callingUid, UserHandle.getUserId(callingUid))) {
            return ParceledListSlice.emptyList();
        }
        return new ParceledListSlice(queryInstrumentationInternal(targetPackage, flags));
    }

    private List<InstrumentationInfo> queryInstrumentationInternal(String targetPackage, int flags) {
        ArrayList<InstrumentationInfo> finalList = new ArrayList();
        synchronized (this.mPackages) {
            for (Instrumentation p : this.mInstrumentation.values()) {
                if (targetPackage == null || targetPackage.equals(p.info.targetPackage)) {
                    InstrumentationInfo ii = PackageParser.generateInstrumentationInfo(p, flags);
                    if (ii != null) {
                        finalList.add(ii);
                    }
                }
            }
        }
        return finalList;
    }

    private void scanDirTracedLI(File scanDir, int parseFlags, int scanFlags, long currentTime) {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("scanDir [");
        stringBuilder.append(scanDir.getAbsolutePath());
        stringBuilder.append("]");
        Trace.traceBegin(262144, stringBuilder.toString());
        try {
            scanDirLI(scanDir, parseFlags, scanFlags, currentTime);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    protected void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) {
        scanDirLI(dir, parseFlags, scanFlags, currentTime, 0);
    }

    protected void scanDirLI(File scanDir, int parseFlags, int scanFlags, long currentTime, int hwFlags) {
        if (HWFLOW) {
            this.mStartTimer = SystemClock.uptimeMillis();
        }
        File[] files = scanDir.listFiles();
        String str;
        StringBuilder stringBuilder;
        if (ArrayUtils.isEmpty(files)) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("No files in app dir ");
            stringBuilder.append(scanDir);
            Log.d(str, stringBuilder.toString());
            return;
        }
        if (DEBUG_PACKAGE_SCANNING) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("Scanning app dir ");
            stringBuilder.append(scanDir);
            stringBuilder.append(" scanFlags=");
            stringBuilder.append(scanFlags);
            stringBuilder.append(" flags=0x");
            stringBuilder.append(Integer.toHexString(parseFlags));
            stringBuilder.append(" hwFlags=0x");
            stringBuilder.append(Integer.toHexString(hwFlags));
            Log.d(str, stringBuilder.toString());
        }
        scanPackageFilesLI(files, parseFlags, scanFlags, currentTime, hwFlags);
    }

    /* JADX WARNING: Removed duplicated region for block: B:93:0x01ce A:{Catch:{ Throwable -> 0x01f0, all -> 0x01ed }} */
    /* JADX WARNING: Removed duplicated region for block: B:90:0x01ae A:{Catch:{ Throwable -> 0x01f0, all -> 0x01ed }} */
    /* JADX WARNING: Removed duplicated region for block: B:90:0x01ae A:{Catch:{ Throwable -> 0x01f0, all -> 0x01ed }} */
    /* JADX WARNING: Removed duplicated region for block: B:93:0x01ce A:{Catch:{ Throwable -> 0x01f0, all -> 0x01ed }} */
    /* JADX WARNING: Removed duplicated region for block: B:103:0x01fd A:{ExcHandler: Throwable (th java.lang.Throwable), Splitter:B:1:0x0018} */
    /* JADX WARNING: Failed to process nested try/catch */
    /* JADX WARNING: Missing block: B:40:0x00b2, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:41:0x00b3, code skipped:
            r15 = r23;
     */
    /* JADX WARNING: Missing block: B:103:0x01fd, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:104:0x01fe, code skipped:
            r15 = r23;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    protected void scanPackageFilesLI(File[] files, int parseFlags, int scanFlags, long currentTime, int hwFlags) {
        Throwable th;
        Throwable th2;
        PackageManagerException e;
        ParseResult parseResult;
        String str;
        StringBuilder stringBuilder;
        boolean z;
        File[] fileArr = files;
        int i = hwFlags;
        ParallelPackageParser parallelPackageParser = new ParallelPackageParser(this.mSeparateProcesses, this.mOnlyCore, this.mMetrics, this.mCacheDir, this.mParallelPackageParserCallback);
        int i2;
        try {
            boolean z2;
            int length = fileArr.length;
            int fileCount = 0;
            int fileCount2 = 0;
            while (true) {
                z2 = true;
                if (fileCount2 >= length) {
                    break;
                }
                File file = fileArr[fileCount2];
                if ((!PackageParser.isApkFile(file) && !file.isDirectory()) || PackageInstallerService.isStageName(file.getName())) {
                    z2 = false;
                }
                if (z2) {
                    StringBuilder stringBuilder2 = new StringBuilder();
                    stringBuilder2.append(file.getPath());
                    stringBuilder2.append(".apk");
                    if (!isUninstallApk(stringBuilder2.toString())) {
                        HwCustEmergDataManager emergDataManager = HwCustEmergDataManager.getDefault();
                        if (emergDataManager != null && !emergDataManager.isEmergencyState() && emergDataManager.getEmergencyPkgName().contains(file.getName())) {
                            Log.i(TAG, "dont scan EmergencyData.apk");
                        } else if ((134217728 & i) == 0 || isCustApkRecorded(file)) {
                            try {
                                parallelPackageParser.submit(file, parseFlags);
                                fileCount++;
                                fileCount2++;
                            } catch (Throwable th3) {
                                th = th3;
                                th2 = null;
                                $closeResource(th2, parallelPackageParser);
                                throw th;
                            }
                        } else if (DEBUG_PACKAGE_SCANNING) {
                            String str2 = TAG;
                            StringBuilder stringBuilder3 = new StringBuilder();
                            stringBuilder3.append("Ignore illegal APK: ");
                            stringBuilder3.append(file.getAbsolutePath());
                            Slog.w(str2, stringBuilder3.toString());
                        }
                    }
                }
                i2 = parseFlags;
                fileCount2++;
            }
            i2 = parseFlags;
            int fileCount3 = fileCount;
            while (fileCount3 > 0) {
                int errorCode;
                ParseResult parseResult2 = parallelPackageParser.take();
                Throwable throwable = parseResult2.throwable;
                int i3;
                if (throwable == null) {
                    if (parseResult2.pkg.applicationInfo.isStaticSharedLibrary()) {
                        renameStaticSharedLibraryPackage(parseResult2.pkg);
                    }
                    if (true == z2) {
                        fileCount2 = scanFlags;
                        try {
                            if (!parseResult2.pkg.codePath.startsWith(SYSTEM_ROOT_DIR)) {
                                try {
                                    if (locationIsProduct(parseResult2.pkg.codePath)) {
                                        fileCount2 |= 2097152;
                                    } else if (locationIsVendor(parseResult2.pkg.codePath)) {
                                        fileCount2 |= 1048576;
                                    }
                                } catch (PackageManagerException e2) {
                                    e = e2;
                                    i3 = 1;
                                    th2 = throwable;
                                    parseResult = parseResult2;
                                    errorCode = e.error;
                                    str = TAG;
                                    stringBuilder = new StringBuilder();
                                    stringBuilder.append("Failed to scan ");
                                    stringBuilder.append(parseResult.scanFile);
                                    stringBuilder.append(": ");
                                    stringBuilder.append(e.getMessage());
                                    Slog.w(str, stringBuilder.toString());
                                    if ((scanFlags & 131072) == 0) {
                                    }
                                    fileCount3--;
                                    z2 = z;
                                }
                            }
                            parseResult2.pkg.applicationInfo.hwFlags = i;
                            length = i;
                            if (isPreRemovableApp(parseResult2.pkg.codePath) && (length & DumpState.DUMP_HANDLE) == 0) {
                                length |= DumpState.DUMP_HANDLE;
                                parseResult2.pkg.applicationInfo.hwFlags = length;
                            }
                            i3 = 1;
                            parseResult = parseResult2;
                            try {
                                scanPackageChildLI(parseResult2.pkg, i2, fileCount2, currentTime, null, length);
                            } catch (PackageManagerException e3) {
                                e = e3;
                            }
                        } catch (PackageManagerException e4) {
                            e = e4;
                            i3 = 1;
                            th2 = throwable;
                            parseResult = parseResult2;
                            errorCode = e.error;
                            str = TAG;
                            stringBuilder = new StringBuilder();
                            stringBuilder.append("Failed to scan ");
                            stringBuilder.append(parseResult.scanFile);
                            stringBuilder.append(": ");
                            stringBuilder.append(e.getMessage());
                            Slog.w(str, stringBuilder.toString());
                            if ((scanFlags & 131072) == 0) {
                            }
                            fileCount3--;
                            z2 = z;
                        }
                    } else {
                        i3 = 1;
                        th2 = throwable;
                        parseResult = parseResult2;
                    }
                    errorCode = i3;
                } else {
                    i3 = 1;
                    th2 = throwable;
                    parseResult = parseResult2;
                    if (th2 instanceof PackageParserException) {
                        PackageParserException e5 = (PackageParserException) th2;
                        errorCode = e5.error;
                        str = TAG;
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("Failed to parse ");
                        stringBuilder.append(parseResult.scanFile);
                        stringBuilder.append(": ");
                        stringBuilder.append(e5.getMessage());
                        Slog.w(str, stringBuilder.toString());
                    } else {
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("Unexpected exception occurred while parsing ");
                        stringBuilder.append(parseResult.scanFile);
                        throw new IllegalStateException(stringBuilder.toString(), th2);
                    }
                }
                if ((scanFlags & 131072) == 0) {
                    z = true;
                    if (errorCode != 1) {
                        StringBuilder stringBuilder4 = new StringBuilder();
                        stringBuilder4.append("Deleting invalid package at ");
                        stringBuilder4.append(parseResult.scanFile);
                        PackageManagerServiceUtils.logCriticalInfo(5, stringBuilder4.toString());
                        removeCodePathLI(parseResult.scanFile);
                    }
                } else {
                    z = true;
                }
                fileCount3--;
                z2 = z;
            }
            $closeResource(null, parallelPackageParser);
        } catch (Throwable th4) {
            th = th4;
            i2 = parseFlags;
            th2 = null;
            $closeResource(th2, parallelPackageParser);
            throw th;
        }
    }

    private static /* synthetic */ void $closeResource(Throwable x0, AutoCloseable x1) {
        if (x0 != null) {
            try {
                x1.close();
                return;
            } catch (Throwable th) {
                x0.addSuppressed(th);
                return;
            }
        }
        x1.close();
    }

    public static void reportSettingsProblem(int priority, String msg) {
        PackageManagerServiceUtils.logCriticalInfo(priority, msg);
    }

    private void collectCertificatesLI(PackageSetting ps, Package pkg, boolean forceCollect, boolean skipVerify) throws PackageManagerException {
        long lastModifiedTime = this.mIsPreNMR1Upgrade ? new File(pkg.codePath).lastModified() : PackageManagerServiceUtils.getLastModifiedTime(pkg);
        String str;
        StringBuilder stringBuilder;
        if (ps == null || forceCollect || !ps.codePathString.equals(pkg.codePath) || ps.timeStamp != lastModifiedTime || isCompatSignatureUpdateNeeded(pkg) || isRecoverSignatureUpdateNeeded(pkg)) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append(pkg.codePath);
            stringBuilder.append(" changed; collecting certs");
            stringBuilder.append(forceCollect ? " (forced)" : BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS);
            Slog.i(str, stringBuilder.toString());
        } else if (ps.signatures.mSigningDetails.signatures == null || ps.signatures.mSigningDetails.signatures.length == 0 || ps.signatures.mSigningDetails.signatureSchemeVersion == 0) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("PackageSetting for ");
            stringBuilder.append(ps.name);
            stringBuilder.append(" is missing signatures.  Collecting certs again to recover them.,skipVerify=");
            stringBuilder.append(skipVerify);
            Slog.w(str, stringBuilder.toString());
        } else {
            pkg.mSigningDetails = new SigningDetails(ps.signatures.mSigningDetails);
            return;
        }
        try {
            Trace.traceBegin(262144, "collectCertificates");
            PackageParser.collectCertificates(pkg, skipVerify);
            Trace.traceEnd(262144);
        } catch (PackageParserException e) {
            throw PackageManagerException.from(e);
        } catch (Throwable th) {
            Trace.traceEnd(262144);
        }
    }

    /* JADX WARNING: Missing block: B:10:0x0043, code skipped:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void maybeClearProfilesForUpgradesLI(PackageSetting originalPkgSetting, Package currentPkg) {
        if (originalPkgSetting != null && isUpgrade() && originalPkgSetting.versionCode != ((long) currentPkg.mVersionCode)) {
            clearAppProfilesLIF(currentPkg, -1);
            if (DEBUG_INSTALL) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(originalPkgSetting.name);
                stringBuilder.append(" clear profile due to version change ");
                stringBuilder.append(originalPkgSetting.versionCode);
                stringBuilder.append(" != ");
                stringBuilder.append(currentPkg.mVersionCode);
                Slog.d(str, stringBuilder.toString());
            }
        }
    }

    private Package scanPackageTracedLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return scanPackageTracedLI(scanFile, parseFlags, scanFlags, currentTime, user, 0);
    }

    private Package scanPackageTracedLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("scanPackage [");
        stringBuilder.append(scanFile.toString());
        stringBuilder.append("]");
        Trace.traceBegin(262144, stringBuilder.toString());
        try {
            Package scanPackageLI = scanPackageLI(scanFile, parseFlags, scanFlags, currentTime, user, hwFlags);
            return scanPackageLI;
        } finally {
            Trace.traceEnd(262144);
        }
    }

    protected Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return scanPackageLI(scanFile, parseFlags, scanFlags, currentTime, user, 0);
    }

    protected Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        File file = scanFile;
        int hwFlags2 = hwFlags;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(scanFile.getPath());
        stringBuilder.append(".apk");
        if (isUninstallApk(stringBuilder.toString())) {
            return null;
        }
        String str;
        StringBuilder stringBuilder2;
        if (DEBUG_INSTALL) {
            str = TAG;
            stringBuilder2 = new StringBuilder();
            stringBuilder2.append("Parsing: ");
            stringBuilder2.append(file);
            Slog.d(str, stringBuilder2.toString());
        }
        PackageParser pp = new PackageParser();
        pp.setSeparateProcesses(this.mSeparateProcesses);
        pp.setOnlyCoreApps(this.mOnlyCore);
        pp.setDisplayMetrics(this.mMetrics);
        pp.setCallback(this.mPackageParserCallback);
        pp.setCacheDir(this.mCacheDir);
        if ((134217728 & hwFlags2) == 0 || isCustApkRecorded(scanFile)) {
            Trace.traceBegin(262144, "parsePackage");
            int i = parseFlags;
            try {
                Package pkg = pp.parsePackage(file, i, true, hwFlags2);
                int currHwFlags = pkg.applicationInfo.hwFlags;
                if (isPreRemovableApp(pkg.codePath) && (currHwFlags & DumpState.DUMP_HANDLE) == 0) {
                    hwFlags2 |= DumpState.DUMP_HANDLE;
                    pkg.applicationInfo.hwFlags = currHwFlags | DumpState.DUMP_HANDLE;
                }
                int hwFlags3 = hwFlags2;
                Trace.traceEnd(262144);
                if (pkg.applicationInfo.isStaticSharedLibrary()) {
                    renameStaticSharedLibraryPackage(pkg);
                }
                hwFlags2 = scanFlags;
                if (!pkg.codePath.startsWith(SYSTEM_ROOT_DIR)) {
                    if (locationIsProduct(pkg.codePath)) {
                        hwFlags2 |= 2097152;
                    } else if (locationIsVendor(pkg.codePath)) {
                        hwFlags2 |= 1048576;
                    }
                }
                return scanPackageChildLI(pkg, i, hwFlags2, currentTime, user, hwFlags3);
            } catch (PackageParserException e) {
                throw PackageManagerException.from(e);
            } catch (Throwable th) {
                Trace.traceEnd(262144);
            }
        } else {
            if (DEBUG_PACKAGE_SCANNING) {
                str = TAG;
                stringBuilder2 = new StringBuilder();
                stringBuilder2.append("Ignore illegal APK: ");
                stringBuilder2.append(scanFile.getAbsolutePath());
                Slog.w(str, stringBuilder2.toString());
            }
            return null;
        }
    }

    private Package scanPackageChildLI(Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return scanPackageChildLI(pkg, parseFlags, scanFlags, currentTime, user, 0);
    }

    private Package scanPackageChildLI(Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        Package packageR = pkg;
        int scanFlags2 = scanFlags;
        int i = hwFlags;
        if (packageR != null && isInMultiWinWhiteList(packageR.packageName)) {
            pkg.forceResizeableAllActivity();
        }
        if ((scanFlags2 & 1024) != 0) {
            scanFlags2 &= -1025;
        } else if (packageR.childPackages != null && packageR.childPackages.size() > 0) {
            scanFlags2 |= 1024;
        }
        int scanFlags3 = scanFlags2;
        int i2 = 0;
        boolean z = ((1073741824 & i) == 0 || this.mPackages.containsKey(packageR.packageName)) ? false : true;
        boolean isNewInstall = z;
        Package scannedPkg = addForInitLI(packageR, parseFlags, scanFlags3, currentTime, user, i);
        int childCount = packageR.childPackages != null ? packageR.childPackages.size() : 0;
        while (i2 < childCount) {
            addForInitLI((Package) packageR.childPackages.get(i2), parseFlags, scanFlags3, currentTime, user, i);
            i2++;
        }
        if ((scanFlags3 & 1024) != 0) {
            return scanPackageChildLI(packageR, parseFlags, scanFlags3, currentTime, user, i);
        }
        if (this.mCotaFlag && this.mTempPkgList != null) {
            this.mTempPkgList.add(packageR);
        }
        doPostScanInstall(packageR, user, isNewInstall, i);
        return scannedPkg;
    }

    private boolean canSkipFullPackageVerification(Package pkg) {
        if (!canSkipFullApkVerification(pkg.baseCodePath)) {
            return false;
        }
        if (!ArrayUtils.isEmpty(pkg.splitCodePaths)) {
            for (String canSkipFullApkVerification : pkg.splitCodePaths) {
                if (!canSkipFullApkVerification(canSkipFullApkVerification)) {
                    return false;
                }
            }
        }
        return true;
    }

    private boolean canSkipFullApkVerification(String apkPath) {
        try {
            byte[] rootHashObserved = VerityUtils.generateFsverityRootHash(apkPath);
            if (rootHashObserved == null) {
                return false;
            }
            synchronized (this.mInstallLock) {
                this.mInstaller.assertFsverityRootHashMatches(apkPath, rootHashObserved);
            }
            return true;
        } catch (InstallerException | IOException | DigestException | NoSuchAlgorithmException e) {
            Slog.w(TAG, "Error in fsverity check. Fallback to full apk verification.", e);
            return false;
        }
    }

    private Package addForInitLI(Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return addForInitLI(pkg, parseFlags, scanFlags, currentTime, user, 0);
    }

    /* JADX WARNING: Removed duplicated region for block: B:245:0x0508  */
    /* JADX WARNING: Missing block: B:42:0x00c9, code skipped:
            r9.setApplicationVolumeUuid(r9.volumeUuid);
            r9.setApplicationInfoCodePath(r9.codePath);
            r9.setApplicationInfoBaseCodePath(r9.baseCodePath);
            r9.setApplicationInfoSplitCodePaths(r9.splitCodePaths);
            r9.setApplicationInfoResourcePath(r9.codePath);
            r9.setApplicationInfoBaseResourcePath(r9.baseCodePath);
            r9.setApplicationInfoSplitResourcePaths(r9.splitCodePaths);
            r4 = r5.mPackages;
     */
    /* JADX WARNING: Missing block: B:43:0x00ee, code skipped:
            monitor-enter(r4);
     */
    /* JADX WARNING: Missing block: B:45:?, code skipped:
            r0 = r5.mSettings.getRenamedPackageLPr(r9.mRealPackage);
            r3 = getRealPackageName(r9, r0);
     */
    /* JADX WARNING: Missing block: B:46:0x00fb, code skipped:
            if (r3 == null) goto L_0x0100;
     */
    /* JADX WARNING: Missing block: B:47:0x00fd, code skipped:
            ensurePackageRenamed(r9, r0);
     */
    /* JADX WARNING: Missing block: B:48:0x0100, code skipped:
            r24 = getOriginalPackageLocked(r9, r0);
            r25 = r5.mSettings.getPackageLPr(r9.packageName);
     */
    /* JADX WARNING: Missing block: B:49:0x0110, code skipped:
            if (r24 != null) goto L_0x0115;
     */
    /* JADX WARNING: Missing block: B:50:0x0112, code skipped:
            r11 = r25;
     */
    /* JADX WARNING: Missing block: B:51:0x0115, code skipped:
            r11 = r24;
     */
    /* JADX WARNING: Missing block: B:52:0x0117, code skipped:
            r15 = r11;
     */
    /* JADX WARNING: Missing block: B:53:0x0118, code skipped:
            if (r15 == null) goto L_0x011c;
     */
    /* JADX WARNING: Missing block: B:54:0x011a, code skipped:
            r11 = true;
     */
    /* JADX WARNING: Missing block: B:55:0x011c, code skipped:
            r11 = false;
     */
    /* JADX WARNING: Missing block: B:56:0x011d, code skipped:
            r26 = r11;
     */
    /* JADX WARNING: Missing block: B:57:0x011f, code skipped:
            if (r26 == false) goto L_0x0124;
     */
    /* JADX WARNING: Missing block: B:58:0x0121, code skipped:
            r11 = r15.name;
     */
    /* JADX WARNING: Missing block: B:59:0x0124, code skipped:
            r11 = r9.packageName;
     */
    /* JADX WARNING: Missing block: B:60:0x0126, code skipped:
            r14 = r11;
            r13 = r5.mSettings.getDisabledSystemPkgLPr(r14);
     */
    /* JADX WARNING: Missing block: B:61:0x012e, code skipped:
            if (r13 == null) goto L_0x0132;
     */
    /* JADX WARNING: Missing block: B:62:0x0130, code skipped:
            r11 = true;
     */
    /* JADX WARNING: Missing block: B:63:0x0132, code skipped:
            r11 = false;
     */
    /* JADX WARNING: Missing block: B:64:0x0133, code skipped:
            r27 = r11;
     */
    /* JADX WARNING: Missing block: B:65:0x0137, code skipped:
            if (DEBUG_INSTALL == false) goto L_0x0152;
     */
    /* JADX WARNING: Missing block: B:66:0x0139, code skipped:
            if (r27 == false) goto L_0x0152;
     */
    /* JADX WARNING: Missing block: B:67:0x013b, code skipped:
            r11 = TAG;
            r12 = new java.lang.StringBuilder();
            r12.append("updatedPkg = ");
            r12.append(r13);
            android.util.Slog.d(r11, r12.toString());
     */
    /* JADX WARNING: Missing block: B:69:0x0154, code skipped:
            if (r9.mSharedUserId == null) goto L_0x015f;
     */
    /* JADX WARNING: Missing block: B:70:0x0156, code skipped:
            r5 = r5.mSettings.getSharedUserLPw(r9.mSharedUserId, 0, 0, true);
     */
    /* JADX WARNING: Missing block: B:71:0x015f, code skipped:
            r5 = null;
     */
    /* JADX WARNING: Missing block: B:73:0x0162, code skipped:
            if (DEBUG_PACKAGE_SCANNING == false) goto L_0x0197;
     */
    /* JADX WARNING: Missing block: B:75:0x0167, code skipped:
            if ((Integer.MIN_VALUE & r8) == 0) goto L_0x0197;
     */
    /* JADX WARNING: Missing block: B:76:0x0169, code skipped:
            if (r5 == null) goto L_0x0197;
     */
    /* JADX WARNING: Missing block: B:77:0x016b, code skipped:
            r11 = TAG;
            r12 = new java.lang.StringBuilder();
            r12.append("Shared UserID ");
            r12.append(r9.mSharedUserId);
            r12.append(" (uid=");
            r12.append(r5.userId);
            r12.append("): packages=");
            r12.append(r5.packages);
            android.util.Log.d(r11, r12.toString());
     */
    /* JADX WARNING: Missing block: B:78:0x0197, code skipped:
            if (r23 == false) goto L_0x023b;
     */
    /* JADX WARNING: Missing block: B:79:0x0199, code skipped:
            if (r27 == false) goto L_0x023b;
     */
    /* JADX WARNING: Missing block: B:81:0x019d, code skipped:
            if (r9.childPackages == null) goto L_0x01a6;
     */
    /* JADX WARNING: Missing block: B:82:0x019f, code skipped:
            r2 = r9.childPackages.size();
     */
    /* JADX WARNING: Missing block: B:83:0x01a6, code skipped:
            r2 = 0;
     */
    /* JADX WARNING: Missing block: B:85:0x01a9, code skipped:
            if (r13.childPackageNames == null) goto L_0x01b2;
     */
    /* JADX WARNING: Missing block: B:86:0x01ab, code skipped:
            r11 = r13.childPackageNames.size();
     */
    /* JADX WARNING: Missing block: B:87:0x01b2, code skipped:
            r11 = 0;
     */
    /* JADX WARNING: Missing block: B:88:0x01b3, code skipped:
            r12 = r11;
            r11 = 0;
     */
    /* JADX WARNING: Missing block: B:89:0x01b5, code skipped:
            if (r11 >= r12) goto L_0x0200;
     */
    /* JADX WARNING: Missing block: B:90:0x01b7, code skipped:
            r6 = (java.lang.String) r13.childPackageNames.get(r11);
            r16 = false;
            r17 = 0;
     */
    /* JADX WARNING: Missing block: B:91:0x01c3, code skipped:
            r31 = r3;
            r3 = r17;
     */
    /* JADX WARNING: Missing block: B:92:0x01c9, code skipped:
            if (r3 >= r2) goto L_0x01eb;
     */
    /* JADX WARNING: Missing block: B:93:0x01cb, code skipped:
            r32 = r2;
            r33 = r12;
     */
    /* JADX WARNING: Missing block: B:94:0x01dd, code skipped:
            if (((android.content.pm.PackageParser.Package) r9.childPackages.get(r3)).packageName.equals(r6) == false) goto L_0x01e2;
     */
    /* JADX WARNING: Missing block: B:95:0x01df, code skipped:
            r16 = true;
     */
    /* JADX WARNING: Missing block: B:96:0x01e2, code skipped:
            r17 = r3 + 1;
            r3 = r31;
            r2 = r32;
            r12 = r33;
     */
    /* JADX WARNING: Missing block: B:97:0x01eb, code skipped:
            r32 = r2;
            r33 = r12;
     */
    /* JADX WARNING: Missing block: B:98:0x01ef, code skipped:
            if (r16 != false) goto L_0x01f6;
     */
    /* JADX WARNING: Missing block: B:99:0x01f1, code skipped:
            r5.mSettings.removeDisabledSystemPackageLPw(r6);
     */
    /* JADX WARNING: Missing block: B:100:0x01f6, code skipped:
            r11 = r11 + 1;
            r3 = r31;
            r2 = r32;
            r12 = r33;
     */
    /* JADX WARNING: Missing block: B:101:0x0200, code skipped:
            r32 = r2;
            r31 = r3;
            r33 = r12;
     */
    /* JADX WARNING: Missing block: B:102:0x0211, code skipped:
            if (r9 != r5.mPlatformPackage) goto L_0x0216;
     */
    /* JADX WARNING: Missing block: B:103:0x0213, code skipped:
            r21 = true;
     */
    /* JADX WARNING: Missing block: B:104:0x0216, code skipped:
            r21 = false;
     */
    /* JADX WARNING: Missing block: B:105:0x0218, code skipped:
            r6 = r33;
            r30 = r13;
            r33 = r14;
            r3 = r15;
            r11 = new com.android.server.pm.PackageManagerService.ScanRequest(r9, r5, null, r30, null, null, null, r8, r7, r21, r42);
            applyPolicy(r9, r8, r7, r5.mPlatformPackage, r1);
            scanPackageOnlyLI(r11, r5.mFactoryTest, -1);
     */
    /* JADX WARNING: Missing block: B:106:0x023b, code skipped:
            r30 = r13;
            r3 = r15;
     */
    /* JADX WARNING: Missing block: B:107:0x023e, code skipped:
            monitor-exit(r4);
     */
    /* JADX WARNING: Missing block: B:108:0x023f, code skipped:
            r11 = r0;
            r12 = r30;
            r13 = r27;
            r14 = r26;
            r6 = r3;
     */
    /* JADX WARNING: Missing block: B:109:0x0247, code skipped:
            if (r14 == false) goto L_0x0255;
     */
    /* JADX WARNING: Missing block: B:111:0x0251, code skipped:
            if (r6.codePathString.equals(r9.codePath) != false) goto L_0x0255;
     */
    /* JADX WARNING: Missing block: B:112:0x0253, code skipped:
            r0 = true;
     */
    /* JADX WARNING: Missing block: B:113:0x0255, code skipped:
            r0 = false;
     */
    /* JADX WARNING: Missing block: B:114:0x0256, code skipped:
            r16 = r0;
     */
    /* JADX WARNING: Missing block: B:115:0x0258, code skipped:
            if (r14 == false) goto L_0x0266;
     */
    /* JADX WARNING: Missing block: B:117:0x0262, code skipped:
            if (r37.getLongVersionCode() <= r6.versionCode) goto L_0x0266;
     */
    /* JADX WARNING: Missing block: B:118:0x0264, code skipped:
            r0 = true;
     */
    /* JADX WARNING: Missing block: B:119:0x0266, code skipped:
            r0 = false;
     */
    /* JADX WARNING: Missing block: B:120:0x0267, code skipped:
            r17 = r0;
     */
    /* JADX WARNING: Missing block: B:121:0x0269, code skipped:
            if (r23 == false) goto L_0x0273;
     */
    /* JADX WARNING: Missing block: B:122:0x026b, code skipped:
            if (r13 == false) goto L_0x0273;
     */
    /* JADX WARNING: Missing block: B:123:0x026d, code skipped:
            if (r16 == false) goto L_0x0273;
     */
    /* JADX WARNING: Missing block: B:124:0x026f, code skipped:
            if (r17 == false) goto L_0x0273;
     */
    /* JADX WARNING: Missing block: B:125:0x0271, code skipped:
            r0 = true;
     */
    /* JADX WARNING: Missing block: B:126:0x0273, code skipped:
            r0 = false;
     */
    /* JADX WARNING: Missing block: B:127:0x0274, code skipped:
            r18 = r0;
            r0 = 5;
     */
    /* JADX WARNING: Missing block: B:128:0x0277, code skipped:
            if (r18 == false) goto L_0x02ef;
     */
    /* JADX WARNING: Missing block: B:129:0x0279, code skipped:
            r2 = r5.mPackages;
     */
    /* JADX WARNING: Missing block: B:130:0x027b, code skipped:
            monitor-enter(r2);
     */
    /* JADX WARNING: Missing block: B:132:?, code skipped:
            r5.mPackages.remove(r6.name);
            removePackageAbiLPw(r6.name);
     */
    /* JADX WARNING: Missing block: B:133:0x0288, code skipped:
            monitor-exit(r2);
     */
    /* JADX WARNING: Missing block: B:134:0x0289, code skipped:
            r2 = new java.lang.StringBuilder();
            r2.append("System package updated; name: ");
            r2.append(r6.name);
            r2.append("; ");
            r2.append(r6.versionCode);
            r2.append(" --> ");
            r2.append(r37.getLongVersionCode());
            r2.append("; ");
            r2.append(r6.codePathString);
            r2.append(" --> ");
            r2.append(r9.codePath);
            com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(5, r2.toString());
            createInstallArgsForExisting(packageFlagsToInstallFlags(r6), r6.codePathString, r6.resourcePathString, com.android.server.pm.InstructionSets.getAppDexInstructionSets(r6)).cleanUpResourcesLI();
            r4 = r5.mPackages;
     */
    /* JADX WARNING: Missing block: B:135:0x02df, code skipped:
            monitor-enter(r4);
     */
    /* JADX WARNING: Missing block: B:137:?, code skipped:
            r5.mSettings.enableSystemPackageLPw(r6.name);
     */
    /* JADX WARNING: Missing block: B:138:0x02e7, code skipped:
            monitor-exit(r4);
     */
    /* JADX WARNING: Missing block: B:147:0x02ef, code skipped:
            if (r23 == false) goto L_0x034d;
     */
    /* JADX WARNING: Missing block: B:148:0x02f1, code skipped:
            if (r13 == false) goto L_0x034d;
     */
    /* JADX WARNING: Missing block: B:149:0x02f3, code skipped:
            if (r18 != false) goto L_0x034d;
     */
    /* JADX WARNING: Missing block: B:150:0x02f5, code skipped:
            addUpdatedRemoveableAppFlag(r9.codePath, r9.packageName);
            r2 = r5.mPackages;
     */
    /* JADX WARNING: Missing block: B:151:0x02fe, code skipped:
            monitor-enter(r2);
     */
    /* JADX WARNING: Missing block: B:154:0x0307, code skipped:
            if (r5.mPackages.containsKey(r9.packageName) != false) goto L_0x0310;
     */
    /* JADX WARNING: Missing block: B:155:0x0309, code skipped:
            r5.mPackages.put(r9.packageName, r9);
     */
    /* JADX WARNING: Missing block: B:156:0x0310, code skipped:
            monitor-exit(r2);
     */
    /* JADX WARNING: Missing block: B:157:0x0311, code skipped:
            r3 = new java.lang.StringBuilder();
            r3.append("Package ");
            r3.append(r9.packageName);
            r3.append(" at ");
            r3.append(r9.codePath);
            r3.append(" ignored: updated version ");
            r3.append(r6.versionCode);
            r3.append(" better than this ");
            r3.append(r37.getLongVersionCode());
     */
    /* JADX WARNING: Missing block: B:158:0x0349, code skipped:
            throw new com.android.server.pm.PackageManagerException(5, r3.toString());
     */
    /* JADX WARNING: Missing block: B:163:0x034d, code skipped:
            if (r13 == false) goto L_0x035e;
     */
    /* JADX WARNING: Missing block: B:165:0x0355, code skipped:
            if (needAddUpdatedRemoveableAppFlag(r9.packageName) == false) goto L_0x035e;
     */
    /* JADX WARNING: Missing block: B:166:0x0357, code skipped:
            r1 = (r1 & -33554433) | 67108864;
     */
    /* JADX WARNING: Missing block: B:167:0x035e, code skipped:
            r6 = r1;
     */
    /* JADX WARNING: Missing block: B:168:0x0361, code skipped:
            if (r5.mIsUpgrade == false) goto L_0x03f6;
     */
    /* JADX WARNING: Missing block: B:169:0x0363, code skipped:
            if (r14 == false) goto L_0x03f6;
     */
    /* JADX WARNING: Missing block: B:171:0x0367, code skipped:
            if (r5.mCustPms == null) goto L_0x03f6;
     */
    /* JADX WARNING: Missing block: B:173:0x0372, code skipped:
            if (r5.mCustPms.isListedApp(r9.packageName) != -1) goto L_0x0377;
     */
    /* JADX WARNING: Missing block: B:174:0x0374, code skipped:
            r7 = r6;
     */
    /* JADX WARNING: Missing block: B:175:0x0377, code skipped:
            r5 = createInstallArgsForExisting(packageFlagsToInstallFlags(r6), r6.codePathString, r6.resourcePathString, com.android.server.pm.InstructionSets.getAppDexInstructionSets(r6));
            r1 = r5.mInstallLock;
     */
    /* JADX WARNING: Missing block: B:176:0x0389, code skipped:
            monitor-enter(r1);
     */
    /* JADX WARNING: Missing block: B:178:?, code skipped:
            r5.cleanUpResourcesLI();
     */
    /* JADX WARNING: Missing block: B:179:0x038d, code skipped:
            monitor-exit(r1);
     */
    /* JADX WARNING: Missing block: B:180:0x038e, code skipped:
            r4 = new com.android.server.pm.PackageManagerService.PackageRemovedInfo(r5);
            r19 = r5.mCustPms.isListedApp(r9.packageName);
     */
    /* JADX WARNING: Missing block: B:181:0x03ed, code skipped:
            throw r0;
     */
    /* JADX WARNING: Missing block: B:186:0x03f4, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:188:0x03f6, code skipped:
            r7 = r6;
     */
    /* JADX WARNING: Missing block: B:189:0x03f7, code skipped:
            r6 = com.android.server.pm.PackageManagerServiceUtils.isApkVerificationForced(r12);
     */
    /* JADX WARNING: Missing block: B:190:0x03fd, code skipped:
            if ((r8 & 16) != 0) goto L_0x0414;
     */
    /* JADX WARNING: Missing block: B:192:0x0402, code skipped:
            if ((com.android.server.pm.DumpState.DUMP_HANDLE & r7) != 0) goto L_0x0414;
     */
    /* JADX WARNING: Missing block: B:193:0x0404, code skipped:
            if (r6 == false) goto L_0x040c;
     */
    /* JADX WARNING: Missing block: B:195:0x040a, code skipped:
            if (canSkipFullPackageVerification(r37) != false) goto L_0x0414;
     */
    /* JADX WARNING: Missing block: B:197:0x040e, code skipped:
            if (r5.mIsPrePUpgrade == false) goto L_0x0411;
     */
    /* JADX WARNING: Missing block: B:198:0x0411, code skipped:
            r29 = false;
     */
    /* JADX WARNING: Missing block: B:199:0x0414, code skipped:
            r29 = true;
     */
    /* JADX WARNING: Missing block: B:200:0x0416, code skipped:
            r5 = r29;
            collectCertificatesLI(r6, r9, r6, r5);
     */
    /* JADX WARNING: Missing block: B:201:0x041f, code skipped:
            if (checkIllegalGmsCoreApk(r37) == false) goto L_0x0424;
     */
    /* JADX WARNING: Missing block: B:203:0x0423, code skipped:
            return null;
     */
    /* JADX WARNING: Missing block: B:204:0x0424, code skipped:
            checkIllegalSysApk(r9, r7);
     */
    /* JADX WARNING: Missing block: B:205:0x042a, code skipped:
            if (r6 == 0) goto L_0x0449;
     */
    /* JADX WARNING: Missing block: B:207:0x0434, code skipped:
            if (r6.codePathString.equals(r9.codePath) == false) goto L_0x0449;
     */
    /* JADX WARNING: Missing block: B:209:0x0445, code skipped:
            if (r6.timeStamp != new java.io.File(r9.codePath).lastModified()) goto L_0x0449;
     */
    /* JADX WARNING: Missing block: B:210:0x0447, code skipped:
            r0 = false;
     */
    /* JADX WARNING: Missing block: B:211:0x0449, code skipped:
            r0 = true;
     */
    /* JADX WARNING: Missing block: B:212:0x044a, code skipped:
            r4 = r0;
            r5.mHwPMSEx.checkHwCertification(r9, r4);
            replaceSignatureIfNeeded(r6, r9, true, r4);
            maybeClearProfilesForUpgradesLI(r6, r9);
            r20 = false;
     */
    /* JADX WARNING: Missing block: B:213:0x0459, code skipped:
            if (r23 == false) goto L_0x05c3;
     */
    /* JADX WARNING: Missing block: B:214:0x045b, code skipped:
            if (r13 != false) goto L_0x05c3;
     */
    /* JADX WARNING: Missing block: B:215:0x045d, code skipped:
            if (r14 == false) goto L_0x05c3;
     */
    /* JADX WARNING: Missing block: B:217:0x0463, code skipped:
            if (r6.isSystem() != false) goto L_0x05c3;
     */
    /* JADX WARNING: Missing block: B:219:0x0470, code skipped:
            if (r9.mSigningDetails.checkCapability(r6.signatures.mSigningDetails, 1) != false) goto L_0x050c;
     */
    /* JADX WARNING: Missing block: B:221:0x047e, code skipped:
            if (r6.signatures.mSigningDetails.checkCapability(r9.mSigningDetails, 8) != false) goto L_0x050c;
     */
    /* JADX WARNING: Missing block: B:222:0x0480, code skipped:
            r0 = new java.lang.StringBuilder();
            r0.append("System package signature mismatch; name: ");
            r0.append(r6.name);
            com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(5, r0.toString());
            r2 = freezePackage(r9.packageName, "scanPackageInternalLI");
     */
    /* JADX WARNING: Missing block: B:225:0x04a2, code skipped:
            r34 = r2;
            r0 = true;
            r21 = r4;
            r19 = r5;
            r22 = r6;
            r25 = r7;
            r24 = r39;
     */
    /* JADX WARNING: Missing block: B:227:?, code skipped:
            deletePackageLIF(r9.packageName, null, true, null, 0, null, false, null);
     */
    /* JADX WARNING: Missing block: B:228:0x04d0, code skipped:
            r1 = r34;
     */
    /* JADX WARNING: Missing block: B:229:0x04d2, code skipped:
            if (r1 == null) goto L_0x04d8;
     */
    /* JADX WARNING: Missing block: B:230:0x04d4, code skipped:
            $closeResource(null, r1);
     */
    /* JADX WARNING: Missing block: B:231:0x04d8, code skipped:
            r9 = r37;
     */
    /* JADX WARNING: Missing block: B:232:0x04dd, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:233:0x04de, code skipped:
            r1 = r34;
            r2 = null;
     */
    /* JADX WARNING: Missing block: B:234:0x04e2, code skipped:
            r0 = move-exception;
     */
    /* JADX WARNING: Missing block: B:235:0x04e3, code skipped:
            r1 = r34;
            r5 = r0;
     */
    /* JADX WARNING: Missing block: B:236:0x04e7, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:237:0x04e8, code skipped:
            r1 = r2;
            r21 = r4;
            r22 = r6;
            r25 = r7;
            r2 = null;
            r24 = r39;
            r19 = r5;
     */
    /* JADX WARNING: Missing block: B:238:0x04f6, code skipped:
            r0 = move-exception;
     */
    /* JADX WARNING: Missing block: B:239:0x04f7, code skipped:
            r1 = r2;
            r21 = r4;
            r19 = r5;
            r22 = r6;
            r25 = r7;
            r24 = r39;
            r5 = r0;
     */
    /* JADX WARNING: Missing block: B:241:?, code skipped:
            throw r5;
     */
    /* JADX WARNING: Missing block: B:242:0x0504, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:243:0x0505, code skipped:
            r2 = r5;
     */
    /* JADX WARNING: Missing block: B:244:0x0506, code skipped:
            if (r1 != null) goto L_0x0508;
     */
    /* JADX WARNING: Missing block: B:245:0x0508, code skipped:
            $closeResource(r2, r1);
     */
    /* JADX WARNING: Missing block: B:246:0x050b, code skipped:
            throw r0;
     */
    /* JADX WARNING: Missing block: B:247:0x050c, code skipped:
            r0 = true;
            r21 = r4;
            r19 = r5;
            r22 = r6;
            r25 = r7;
            r24 = r39;
     */
    /* JADX WARNING: Missing block: B:248:0x0517, code skipped:
            if (r17 == false) goto L_0x0578;
     */
    /* JADX WARNING: Missing block: B:249:0x0519, code skipped:
            r1 = new java.lang.StringBuilder();
            r1.append("System package enabled; name: ");
            r1.append(r6.name);
            r1.append("; ");
            r1.append(r6.versionCode);
            r1.append(" --> ");
            r1.append(r37.getLongVersionCode());
            r1.append("; ");
            r1.append(r6.codePathString);
            r1.append(" --> ");
            r9 = r37;
            r1.append(r9.codePath);
            com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(5, r1.toString());
            r1 = createInstallArgsForExisting(packageFlagsToInstallFlags(r6), r6.codePathString, r6.resourcePathString, com.android.server.pm.InstructionSets.getAppDexInstructionSets(r6));
            r2 = r5.mInstallLock;
     */
    /* JADX WARNING: Missing block: B:250:0x056f, code skipped:
            monitor-enter(r2);
     */
    /* JADX WARNING: Missing block: B:252:?, code skipped:
            r1.cleanUpResourcesLI();
     */
    /* JADX WARNING: Missing block: B:253:0x0573, code skipped:
            monitor-exit(r2);
     */
    /* JADX WARNING: Missing block: B:258:0x0578, code skipped:
            r9 = r37;
            r20 = true;
            addUpdatedRemoveableAppFlag(r9.codePath, r6.name);
            r2 = new java.lang.StringBuilder();
            r2.append("System package disabled; name: ");
            r2.append(r6.name);
            r2.append("; old: ");
            r2.append(r6.codePathString);
            r2.append(" @ ");
            r2.append(r6.versionCode);
            r2.append("; new: ");
            r2.append(r9.codePath);
            r2.append(" @ ");
            r2.append(r9.codePath);
            com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(4, r2.toString());
     */
    /* JADX WARNING: Missing block: B:259:0x05c3, code skipped:
            r21 = r4;
            r19 = r5;
            r22 = r6;
            r25 = r7;
            r0 = true;
            r24 = r39;
     */
    /* JADX WARNING: Missing block: B:260:0x05ce, code skipped:
            r1 = scanPackageNewLI(r9, r38, r24 | 2, r40, r42, r25);
     */
    /* JADX WARNING: Missing block: B:261:0x05de, code skipped:
            if (r20 == false) goto L_0x05ef;
     */
    /* JADX WARNING: Missing block: B:262:0x05e0, code skipped:
            r2 = r5.mPackages;
     */
    /* JADX WARNING: Missing block: B:263:0x05e2, code skipped:
            monitor-enter(r2);
     */
    /* JADX WARNING: Missing block: B:265:?, code skipped:
            r5.mSettings.disableSystemPackageLPw(r9.packageName, r0);
     */
    /* JADX WARNING: Missing block: B:266:0x05ea, code skipped:
            monitor-exit(r2);
     */
    /* JADX WARNING: Missing block: B:271:0x05ef, code skipped:
            addPreinstalledPkgToList(r1);
     */
    /* JADX WARNING: Missing block: B:272:0x05f2, code skipped:
            return r1;
     */
    /* JADX WARNING: Missing block: B:274:0x05f4, code skipped:
            r24 = r7;
     */
    /* JADX WARNING: Missing block: B:299:?, code skipped:
            r21 = r5;
            r7 = r6;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private Package addForInitLI(Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        Package packageR = pkg;
        int i = parseFlags;
        int i2 = scanFlags;
        int hwFlags2 = hwFlags;
        boolean scanSystemPartition = (i & 16) != 0;
        synchronized (this.mPackages) {
            if ((1073741824 & hwFlags2) == 0) {
                try {
                    PackageSetting psTemp = this.mSettings.getPackageLPr(packageR.packageName);
                    String str;
                    StringBuilder stringBuilder;
                    if (!needInstallRemovablePreApk(packageR, hwFlags2)) {
                        addUnisntallDataToCache(packageR.packageName, packageR.codePath);
                        if (psTemp == null || !psTemp.isAnyInstalled(sUserManager.getUserIds()) || (this.mSettings.getDisabledSystemPkgLPr(packageR.packageName) == null && psTemp.codePathString != null && psTemp.codePathString.startsWith("/data/app/"))) {
                            str = TAG;
                            stringBuilder = new StringBuilder();
                            stringBuilder.append("scan return here for package:");
                            stringBuilder.append(packageR.packageName);
                            Slog.d(str, stringBuilder.toString());
                            return null;
                        }
                    } else if (!(psTemp == null || psTemp.codePath == null || psTemp.codePathString.equals(packageR.codePath) || psTemp.codePathString == null || !psTemp.codePathString.startsWith("/data/app/") || scanSystemPartition || ((long) packageR.mVersionCode) > psTemp.versionCode)) {
                        str = TAG;
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("scan return here for ota nosys package:");
                        stringBuilder.append(packageR.packageName);
                        Slog.d(str, stringBuilder.toString());
                        recordUninstalledDelapp(packageR.packageName, packageR.codePath.toString());
                        return null;
                    }
                } catch (Throwable th) {
                    int i3 = i2;
                    while (true) {
                    }
                }
            }
        }
    }

    private static void renameStaticSharedLibraryPackage(Package pkg) {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(pkg.packageName);
        stringBuilder.append(STATIC_SHARED_LIB_DELIMITER);
        stringBuilder.append(pkg.staticSharedLibVersion);
        pkg.setPackageName(stringBuilder.toString());
    }

    private static String fixProcessName(String defProcessName, String processName) {
        if (processName == null) {
            return defProcessName;
        }
        return processName;
    }

    /* JADX WARNING: Missing block: B:25:0x0066, code skipped:
            return;
     */
    /* JADX WARNING: Missing block: B:26:0x0067, code skipped:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void verifyValidVerifierInstall(String installerPackageName, String pkgName, int userId, int appId) throws PackageManagerException {
        String checkInstallPackage = "com.android.vending";
        if (pkgName.equals(checkInstallPackage) && ((TextUtils.isEmpty(installerPackageName) || (!installerPackageName.equals("com.android.packageinstaller") && !installerPackageName.equals("com.huawei.appmarket"))) && pkgName.equals(checkInstallPackage) && ((TextUtils.isEmpty(installerPackageName) || !installerPackageName.equals(checkInstallPackage)) && checkPermission("android.permission.INSTALL_PACKAGES", installerPackageName, userId) != -1 && appId != 0 && appId != 2000 && appId != 1000))) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Invalid installer for ");
            stringBuilder.append(checkInstallPackage);
            stringBuilder.append("!");
            throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, stringBuilder.toString());
        }
    }

    private static final void enforceSystemOrRoot(String message) {
        int uid = Binder.getCallingUid();
        if (uid != 1000 && uid != 0) {
            throw new SecurityException(message);
        }
    }

    public void performFstrimIfNeeded() {
        enforceSystemOrRoot("Only the system can request fstrim");
        HwThemeManager.applyDefaultHwTheme(false, this.mContext, 0);
        HwThemeManager.linkDataSkinDirAsUser(0);
        try {
            IStorageManager sm = PackageHelper.getStorageManager();
            if (sm != null) {
                boolean doTrim = false;
                long interval = Global.getLong(this.mContext.getContentResolver(), "fstrim_mandatory_interval", DEFAULT_MANDATORY_FSTRIM_INTERVAL);
                if (interval > 0) {
                    long timeSinceLast = System.currentTimeMillis() - sm.lastMaintenance();
                    if (timeSinceLast > interval) {
                        doTrim = true;
                        String str = TAG;
                        StringBuilder stringBuilder = new StringBuilder();
                        stringBuilder.append("No disk maintenance in ");
                        stringBuilder.append(timeSinceLast);
                        stringBuilder.append("; running immediately");
                        Slog.w(str, stringBuilder.toString());
                    }
                }
                if (doTrim) {
                    synchronized (this.mPackages) {
                        boolean dexOptDialogShown = this.mDexOptDialogShown;
                    }
                    if (!isFirstBoot() && dexOptDialogShown) {
                        try {
                            ActivityManager.getService().showBootMessage(this.mContext.getResources().getString(17039583), true);
                        } catch (RemoteException e) {
                        }
                    }
                }
                return;
            }
            Slog.e(TAG, "storageManager service unavailable!");
        } catch (RemoteException e2) {
        }
    }

    public void updatePackagesIfNeeded() {
        enforceSystemOrRoot("Only the system can request package update");
        boolean causeUpgrade = isUpgrade();
        boolean causeFirstBoot = isFirstBoot() || this.mIsPreNUpgrade;
        boolean causePrunedCache = VMRuntime.didPruneDalvikCache();
        if (causeUpgrade || causeFirstBoot || causePrunedCache) {
            List<Package> pkgs;
            synchronized (this.mPackages) {
                pkgs = PackageManagerServiceUtils.getPackagesForDexopt(this.mPackages.values(), this);
            }
            boolean showDialog = this.mIsPreNUpgrade;
            if (SystemProperties.getBoolean("ro.config.show_dex2oatDialog", true)) {
                showDialog = this.mIsUpgrade;
            }
            long startTime = System.nanoTime();
            int[] stats = performDexOptUpgrade(pkgs, showDialog, causeFirstBoot ? null : 1, false);
            int elapsedTimeSeconds = (int) TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - startTime);
            MetricsLogger.histogram(this.mContext, "opt_dialog_num_dexopted", stats[0]);
            MetricsLogger.histogram(this.mContext, "opt_dialog_num_skipped", stats[1]);
            MetricsLogger.histogram(this.mContext, "opt_dialog_num_failed", stats[2]);
            MetricsLogger.histogram(this.mContext, "opt_dialog_num_total", getOptimizablePackages().size());
            MetricsLogger.histogram(this.mContext, "opt_dialog_time_s", elapsedTimeSeconds);
        }
    }

    private static String getPrebuildProfilePath(Package pkg) {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(pkg.baseCodePath);
        stringBuilder.append(".prof");
        return stringBuilder.toString();
    }

    /* JADX WARNING: Removed duplicated region for block: B:44:0x011c A:{SKIP} */
    /* JADX WARNING: Removed duplicated region for block: B:43:0x0114  */
    /* JADX WARNING: Removed duplicated region for block: B:43:0x0114  */
    /* JADX WARNING: Removed duplicated region for block: B:44:0x011c A:{SKIP} */
    /* JADX WARNING: Removed duplicated region for block: B:44:0x011c A:{SKIP} */
    /* JADX WARNING: Removed duplicated region for block: B:43:0x0114  */
    /* JADX WARNING: Removed duplicated region for block: B:43:0x0114  */
    /* JADX WARNING: Removed duplicated region for block: B:44:0x011c A:{SKIP} */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private int[] performDexOptUpgrade(List<Package> pkgs, boolean showDialog, int compilationReason, boolean bootComplete) {
        Exception e;
        PackageSetting packageSetting;
        String str;
        StringBuilder stringBuilder;
        int numberOfPackagesVisited = 0;
        int numberOfPackagesOptimized = 0;
        int numberOfPackagesSkipped = 0;
        int numberOfPackagesFailed = 0;
        int numberOfPackagesToDexopt = pkgs.size();
        boolean isChina = "CN".equalsIgnoreCase(SystemProperties.get("ro.product.locale.region", BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS));
        connectBootAnimation();
        Iterator it = pkgs.iterator();
        while (it.hasNext()) {
            Iterator it2;
            Package pkg = (Package) it.next();
            int numberOfPackagesVisited2 = numberOfPackagesVisited + 1;
            boolean useProfileForDexopt = false;
            if ((isFirstBoot() || isUpgrade()) && isSystemApp(pkg)) {
                File profileFile = new File(getPrebuildProfilePath(pkg));
                if (profileFile.exists()) {
                    try {
                        if (!this.mInstaller.copySystemProfile(profileFile.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName(null))) {
                            Log.e(TAG, "Installer failed to copy system profile!");
                        }
                    } catch (Exception e2) {
                        String str2 = TAG;
                        StringBuilder stringBuilder2 = new StringBuilder();
                        stringBuilder2.append("Failed to copy profile ");
                        stringBuilder2.append(profileFile.getAbsolutePath());
                        stringBuilder2.append(" ");
                        Log.e(str2, stringBuilder2.toString(), e2);
                    }
                } else {
                    PackageSetting disabledPs = this.mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                    if (disabledPs != null && disabledPs.pkg.isStub) {
                        profileFile = new File(getPrebuildProfilePath(disabledPs.pkg).replace(STUB_SUFFIX, BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS));
                        if (profileFile.exists()) {
                            try {
                                it2 = it;
                                try {
                                } catch (Exception e3) {
                                    e2 = e3;
                                    packageSetting = disabledPs;
                                    str = TAG;
                                    stringBuilder = new StringBuilder();
                                    stringBuilder.append("Failed to copy profile ");
                                    stringBuilder.append(profileFile.getAbsolutePath());
                                    stringBuilder.append(" ");
                                    Log.e(str, stringBuilder.toString(), e2);
                                    if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                                    }
                                }
                                try {
                                    if (this.mInstaller.copySystemProfile(profileFile.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName(null))) {
                                        useProfileForDexopt = true;
                                    } else {
                                        Log.e(TAG, "Failed to copy system profile for stub package!");
                                    }
                                } catch (Exception e4) {
                                    e2 = e4;
                                    str = TAG;
                                    stringBuilder = new StringBuilder();
                                    stringBuilder.append("Failed to copy profile ");
                                    stringBuilder.append(profileFile.getAbsolutePath());
                                    stringBuilder.append(" ");
                                    Log.e(str, stringBuilder.toString(), e2);
                                    if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                                    }
                                }
                            } catch (Exception e5) {
                                e2 = e5;
                                it2 = it;
                                packageSetting = disabledPs;
                                str = TAG;
                                stringBuilder = new StringBuilder();
                                stringBuilder.append("Failed to copy profile ");
                                stringBuilder.append(profileFile.getAbsolutePath());
                                stringBuilder.append(" ");
                                Log.e(str, stringBuilder.toString(), e2);
                                if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                                }
                            }
                            if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                                numberOfPackagesSkipped++;
                                numberOfPackagesVisited = numberOfPackagesVisited2;
                                it = it2;
                            } else {
                                int data;
                                int numberOfPackagesToDexopt2;
                                if (showDialog && this.mIBootAnmation != null) {
                                    numberOfPackagesVisited = 0;
                                    if (numberOfPackagesVisited2 != 1) {
                                        numberOfPackagesVisited = 0 | DumpState.DUMP_HANDLE;
                                    }
                                    data = (100 * numberOfPackagesVisited2) / numberOfPackagesToDexopt;
                                    try {
                                        this.mIBootAnmation.notifyProcessing((isChina ? 0 : 256) | (numberOfPackagesVisited | ((data == 0 ? 1 : data) << 16)));
                                    } catch (RemoteException e6) {
                                        String str3 = TAG;
                                        StringBuilder stringBuilder3 = new StringBuilder();
                                        stringBuilder3.append("show boot dexoat process error,");
                                        stringBuilder3.append(e6.getMessage());
                                        Slog.w(str3, stringBuilder3.toString());
                                    }
                                }
                                numberOfPackagesVisited = compilationReason;
                                if (useProfileForDexopt) {
                                    numberOfPackagesVisited = 3;
                                }
                                data = bootComplete ? 4 : 0;
                                if (compilationReason == 0) {
                                    data |= 1024;
                                }
                                int primaryDexOptStaus = performDexOptTraced(new DexoptOptions(pkg.packageName, numberOfPackagesVisited, data));
                                switch (primaryDexOptStaus) {
                                    case -1:
                                        numberOfPackagesFailed++;
                                        break;
                                    case 0:
                                        numberOfPackagesSkipped++;
                                        break;
                                    case 1:
                                        numberOfPackagesOptimized++;
                                        break;
                                    default:
                                        String str4 = TAG;
                                        StringBuilder stringBuilder4 = new StringBuilder();
                                        numberOfPackagesToDexopt2 = numberOfPackagesToDexopt;
                                        stringBuilder4.append("Unexpected dexopt return code ");
                                        stringBuilder4.append(primaryDexOptStaus);
                                        Log.e(str4, stringBuilder4.toString());
                                        break;
                                }
                                numberOfPackagesToDexopt2 = numberOfPackagesToDexopt;
                                numberOfPackagesVisited = numberOfPackagesVisited2;
                                it = it2;
                                numberOfPackagesToDexopt = numberOfPackagesToDexopt2;
                            }
                        }
                    }
                }
            }
            it2 = it;
            if (PackageDexOptimizer.canOptimizePackage(pkg)) {
            }
        }
        this.mHandler.postDelayed(new Runnable() {
            public void run() {
                if (PackageManagerService.this.mIBootAnmation != null) {
                    try {
                        PackageManagerService.this.mIBootAnmation.notifyProcessing(DumpState.DUMP_SERVICE_PERMISSIONS);
                    } catch (RemoteException e) {
                        String str = PackageManagerService.TAG;
                        StringBuilder stringBuilder = new StringBuilder();
                        stringBuilder.append("finish boot dexoat process error,");
                        stringBuilder.append(e.getMessage());
                        Slog.w(str, stringBuilder.toString());
                    }
                }
                PackageManagerService.this.mIBootAnmation = null;
            }
        }, 1000);
        return new int[]{numberOfPackagesOptimized, numberOfPackagesSkipped, numberOfPackagesFailed};
    }

    public void notifyPackageUse(String packageName, int reason) {
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            if (getInstantAppPackageName(callingUid) != null) {
                if (!isCallerSameApp(packageName, callingUid)) {
                    return;
                }
            } else if (isInstantApp(packageName, callingUserId)) {
                return;
            }
            notifyPackageUseLocked(packageName, reason);
        }
    }

    @GuardedBy("mPackages")
    private void notifyPackageUseLocked(String packageName, int reason) {
        Package p = (Package) this.mPackages.get(packageName);
        if (p != null) {
            p.mLastPackageUsageTimeInMills[reason] = System.currentTimeMillis();
        }
    }

    public void notifyDexLoad(String loadingPackageName, List<String> classLoaderNames, List<String> classPaths, String loaderIsa) {
        int userId = UserHandle.getCallingUserId();
        ApplicationInfo ai = getApplicationInfo(loadingPackageName, 0, userId);
        if (ai == null) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Loading a package that does not exist for the calling user. package=");
            stringBuilder.append(loadingPackageName);
            stringBuilder.append(", user=");
            stringBuilder.append(userId);
            Slog.w(str, stringBuilder.toString());
            return;
        }
        this.mDexManager.notifyDexLoad(ai, classLoaderNames, classPaths, loaderIsa, userId);
    }

    public void registerDexModule(String packageName, String dexModulePath, boolean isSharedModule, IDexModuleRegisterCallback callback) {
        RegisterDexModuleResult result;
        int userId = UserHandle.getCallingUserId();
        ApplicationInfo ai = getApplicationInfo(packageName, 0, userId);
        if (ai == null) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Registering a dex module for a package that does not exist for the calling user. package=");
            stringBuilder.append(packageName);
            stringBuilder.append(", user=");
            stringBuilder.append(userId);
            Slog.w(str, stringBuilder.toString());
            result = new RegisterDexModuleResult(false, "Package not installed");
        } else {
            result = this.mDexManager.registerDexModule(ai, dexModulePath, isSharedModule, userId);
        }
        if (callback != null) {
            this.mHandler.post(new -$$Lambda$PackageManagerService$opO5L-t6aW9gAx6B5CGlW6sAaX8(callback, dexModulePath, result));
        }
    }

    static /* synthetic */ void lambda$registerDexModule$3(IDexModuleRegisterCallback callback, String dexModulePath, RegisterDexModuleResult result) {
        try {
            callback.onDexModuleRegistered(dexModulePath, result.success, result.message);
        } catch (RemoteException e) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Failed to callback after module registration ");
            stringBuilder.append(dexModulePath);
            Slog.w(str, stringBuilder.toString(), e);
        }
    }

    public boolean performDexOptMode(String packageName, boolean checkProfiles, String targetCompilerFilter, boolean force, boolean bootComplete, String splitName) {
        if (this.mHwPMSEx.isApkDexOpt(targetCompilerFilter)) {
            return this.mHwPMSEx.hwPerformDexOptMode(packageName, checkProfiles, targetCompilerFilter, force, bootComplete, splitName);
        }
        int flags = 0;
        int i = (force ? 2 : 0) | checkProfiles;
        if (bootComplete) {
            flags = 4;
        }
        return performDexOpt(new DexoptOptions(packageName, -1, targetCompilerFilter, splitName, flags | i));
    }

    public boolean performDexOptSecondary(String packageName, String compilerFilter, boolean force) {
        return performDexOpt(new DexoptOptions(packageName, compilerFilter, (force ? 2 : 0) | 13));
    }

    boolean performDexOpt(DexoptOptions options) {
        boolean z = false;
        if (getInstantAppPackageName(Binder.getCallingUid()) != null || isInstantApp(options.getPackageName(), UserHandle.getCallingUserId())) {
            return false;
        }
        if (options.isDexoptOnlySecondaryDex()) {
            return this.mDexManager.dexoptSecondaryDex(options);
        }
        if (performDexOptWithStatus(options) != -1) {
            z = true;
        }
        return z;
    }

    int performDexOptWithStatus(DexoptOptions options) {
        return performDexOptTraced(options);
    }

    private int performDexOptTraced(DexoptOptions options) {
        Trace.traceBegin(262144, "dexopt");
        try {
            int performDexOptInternal = performDexOptInternal(options);
            return performDexOptInternal;
        } finally {
            Trace.traceEnd(262144);
        }
    }

    private int performDexOptInternal(DexoptOptions options) {
        synchronized (this.mPackages) {
            Package p = (Package) this.mPackages.get(options.getPackageName());
            if (p == null) {
                return -1;
            }
            this.mPackageUsage.maybeWriteAsync(this.mPackages);
            this.mCompilerStats.maybeWriteAsync();
            long callingId = Binder.clearCallingIdentity();
            try {
                int performDexOptInternalWithDependenciesLI;
                synchronized (this.mInstallLock) {
                    performDexOptInternalWithDependenciesLI = performDexOptInternalWithDependenciesLI(p, options);
                }
                Binder.restoreCallingIdentity(callingId);
                return performDexOptInternalWithDependenciesLI;
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(callingId);
            }
        }
    }

    public ArraySet<String> getOptimizablePackages() {
        ArraySet<String> pkgs = new ArraySet();
        synchronized (this.mPackages) {
            for (Package p : this.mPackages.values()) {
                if (PackageDexOptimizer.canOptimizePackage(p)) {
                    pkgs.add(p.packageName);
                }
            }
        }
        return pkgs;
    }

    private int performDexOptInternalWithDependenciesLI(Package p, DexoptOptions options) {
        PackageDexOptimizer forcedUpdatePackageDexOptimizer;
        if (options.isForce()) {
            forcedUpdatePackageDexOptimizer = new ForcedUpdatePackageDexOptimizer(this.mPackageDexOptimizer);
        } else {
            forcedUpdatePackageDexOptimizer = this.mPackageDexOptimizer;
        }
        PackageDexOptimizer pdo = forcedUpdatePackageDexOptimizer;
        Collection<Package> deps = findSharedNonSystemLibraries(p);
        String[] instructionSets = InstructionSets.getAppDexInstructionSets(p.applicationInfo);
        if (!deps.isEmpty()) {
            DexoptOptions libraryOptions = new DexoptOptions(options.getPackageName(), options.getCompilationReason(), options.getCompilerFilter(), options.getSplitName(), options.getFlags() | 64);
            for (Package depPackage : deps) {
                pdo.performDexOpt(depPackage, null, instructionSets, getOrCreateCompilerPackageStats(depPackage), this.mDexManager.getPackageUseInfoOrDefault(depPackage.packageName), libraryOptions);
            }
        }
        return pdo.performDexOpt(p, p.usesLibraryFiles, instructionSets, getOrCreateCompilerPackageStats(p), this.mDexManager.getPackageUseInfoOrDefault(p.packageName), options);
    }

    public void reconcileSecondaryDexFiles(String packageName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && !isInstantApp(packageName, UserHandle.getCallingUserId())) {
            this.mDexManager.reconcileSecondaryDexFiles(packageName);
        }
    }

    DexManager getDexManager() {
        return this.mDexManager;
    }

    public boolean runBackgroundDexoptJob(List<String> packageNames) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return false;
        }
        return BackgroundDexOptService.runIdleOptimizationsNow(this, this.mContext, packageNames);
    }

    List<Package> findSharedNonSystemLibraries(Package p) {
        if (p.usesLibraries == null && p.usesOptionalLibraries == null && p.usesStaticLibraries == null) {
            return Collections.emptyList();
        }
        ArrayList<Package> retValue = new ArrayList();
        findSharedNonSystemLibrariesRecursive(p, retValue, new HashSet());
        retValue.remove(p);
        return retValue;
    }

    private void findSharedNonSystemLibrariesRecursive(Package p, ArrayList<Package> collected, Set<String> collectedNames) {
        if (!collectedNames.contains(p.packageName)) {
            collectedNames.add(p.packageName);
            collected.add(p);
            if (p.usesLibraries != null) {
                findSharedNonSystemLibrariesRecursive(p.usesLibraries, null, collected, collectedNames);
            }
            if (p.usesOptionalLibraries != null) {
                findSharedNonSystemLibrariesRecursive(p.usesOptionalLibraries, null, collected, collectedNames);
            }
            if (p.usesStaticLibraries != null) {
                findSharedNonSystemLibrariesRecursive(p.usesStaticLibraries, p.usesStaticLibrariesVersions, collected, collectedNames);
            }
        }
    }

    private void findSharedNonSystemLibrariesRecursive(ArrayList<String> libs, long[] versions, ArrayList<Package> collected, Set<String> collectedNames) {
        int libNameCount = libs.size();
        int i = 0;
        while (i < libNameCount) {
            String libName = (String) libs.get(i);
            long version = (versions == null || versions.length != libNameCount) ? -1 : versions[i];
            Package libPkg = findSharedNonSystemLibrary(libName, version);
            if (libPkg != null) {
                findSharedNonSystemLibrariesRecursive(libPkg, collected, collectedNames);
            }
            i++;
        }
    }

    private Package findSharedNonSystemLibrary(String name, long version) {
        synchronized (this.mPackages) {
            SharedLibraryEntry libEntry = getSharedLibraryEntryLPr(name, version);
            if (libEntry != null) {
                Package packageR = (Package) this.mPackages.get(libEntry.apk);
                return packageR;
            }
            return null;
        }
    }

    private SharedLibraryEntry getSharedLibraryEntryLPr(String name, long version) {
        LongSparseArray<SharedLibraryEntry> versionedLib = (LongSparseArray) this.mSharedLibraries.get(name);
        if (versionedLib == null) {
            return null;
        }
        return (SharedLibraryEntry) versionedLib.get(version);
    }

    private SharedLibraryEntry getLatestSharedLibraVersionLPr(Package pkg) {
        LongSparseArray<SharedLibraryEntry> versionedLib = (LongSparseArray) this.mSharedLibraries.get(pkg.staticSharedLibName);
        if (versionedLib == null) {
            return null;
        }
        long previousLibVersion = -1;
        int versionCount = versionedLib.size();
        for (int i = 0; i < versionCount; i++) {
            long libVersion = versionedLib.keyAt(i);
            if (libVersion < pkg.staticSharedLibVersion) {
                previousLibVersion = Math.max(previousLibVersion, libVersion);
            }
        }
        if (previousLibVersion >= 0) {
            return (SharedLibraryEntry) versionedLib.get(previousLibVersion);
        }
        return null;
    }

    public void shutdown() {
        this.mPackageUsage.writeNow(this.mPackages);
        this.mCompilerStats.writeNow();
        this.mDexManager.writePackageDexUsageNow();
        synchronized (this.mPackages) {
            if (this.mHandler.hasMessages(14)) {
                this.mHandler.removeMessages(14);
                Iterator it = this.mDirtyUsers.iterator();
                while (it.hasNext()) {
                    this.mSettings.writePackageRestrictionsLPr(((Integer) it.next()).intValue());
                }
                this.mDirtyUsers.clear();
            }
        }
    }

    public void dumpProfiles(String packageName) {
        Package pkg;
        synchronized (this.mPackages) {
            pkg = (Package) this.mPackages.get(packageName);
            if (pkg != null) {
            } else {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Unknown package: ");
                stringBuilder.append(packageName);
                throw new IllegalArgumentException(stringBuilder.toString());
            }
        }
        int callingUid = Binder.getCallingUid();
        if (callingUid == 2000 || callingUid == 0 || callingUid == pkg.applicationInfo.uid) {
            synchronized (this.mInstallLock) {
                Trace.traceBegin(262144, "dump profiles");
                this.mArtManagerService.dumpProfiles(pkg);
                Trace.traceEnd(262144);
            }
            return;
        }
        throw new SecurityException("dumpProfiles");
    }

    public void forceDexOpt(String packageName) {
        Package pkg;
        enforceSystemOrRoot("forceDexOpt");
        synchronized (this.mPackages) {
            pkg = (Package) this.mPackages.get(packageName);
            if (pkg != null) {
            } else {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Unknown package: ");
                stringBuilder.append(packageName);
                throw new IllegalArgumentException(stringBuilder.toString());
            }
        }
        synchronized (this.mInstallLock) {
            Trace.traceBegin(262144, "dexopt");
            int res = performDexOptInternalWithDependenciesLI(pkg, new DexoptOptions(packageName, PackageManagerServiceCompilerMapping.getDefaultCompilerFilter(), 6));
            Trace.traceEnd(262144);
            if (res == 1) {
            } else {
                StringBuilder stringBuilder2 = new StringBuilder();
                stringBuilder2.append("Failed to dexopt: ");
                stringBuilder2.append(res);
                throw new IllegalStateException(stringBuilder2.toString());
            }
        }
    }

    private boolean verifyPackageUpdateLPr(PackageSetting oldPkg, Package newPkg) {
        String str;
        StringBuilder stringBuilder;
        if ((oldPkg.pkgFlags & 1) == 0) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("Unable to update from ");
            stringBuilder.append(oldPkg.name);
            stringBuilder.append(" to ");
            stringBuilder.append(newPkg.packageName);
            stringBuilder.append(": old package not in system partition");
            Slog.w(str, stringBuilder.toString());
            return false;
        } else if (this.mPackages.get(oldPkg.name) == null) {
            return true;
        } else {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("Unable to update from ");
            stringBuilder.append(oldPkg.name);
            stringBuilder.append(" to ");
            stringBuilder.append(newPkg.packageName);
            stringBuilder.append(": old package still exists");
            Slog.w(str, stringBuilder.toString());
            return false;
        }
    }

    void removeCodePathLI(File codePath) {
        if (codePath.isDirectory()) {
            try {
                this.mInstaller.rmPackageDir(codePath.getAbsolutePath());
                return;
            } catch (InstallerException e) {
                Slog.w(TAG, "Failed to remove code path", e);
                return;
            }
        }
        codePath.delete();
    }

    private int[] resolveUserIds(int userId) {
        if (userId == -1) {
            return sUserManager.getUserIds();
        }
        return new int[]{userId};
    }

    private void clearAppDataLIF(Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        clearAppDataLeafLIF(pkg, userId, flags);
        int i = 0;
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        while (i < childCount) {
            clearAppDataLeafLIF((Package) pkg.childPackages.get(i), userId, flags);
            i++;
        }
        clearAppProfilesLIF(pkg, -1);
    }

    private void clearAppDataLeafLIF(Package pkg, int userId, int flags) {
        PackageSetting ps;
        synchronized (this.mPackages) {
            ps = (PackageSetting) this.mSettings.mPackages.get(pkg.packageName);
        }
        for (int realUserId : resolveUserIds(userId)) {
            try {
                this.mInstaller.clearAppData(pkg.volumeUuid, pkg.packageName, realUserId, flags, ps != null ? ps.getCeDataInode(realUserId) : 0);
            } catch (InstallerException e) {
                Slog.w(TAG, String.valueOf(e));
            }
        }
    }

    private void destroyAppDataLIF(Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        destroyAppDataLeafLIF(pkg, userId, flags);
        int i = 0;
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        while (i < childCount) {
            destroyAppDataLeafLIF((Package) pkg.childPackages.get(i), userId, flags);
            i++;
        }
    }

    private void destroyAppDataLeafLIF(Package pkg, int userId, int flags) {
        PackageSetting ps;
        synchronized (this.mPackages) {
            ps = (PackageSetting) this.mSettings.mPackages.get(pkg.packageName);
        }
        for (int realUserId : resolveUserIds(userId)) {
            try {
                this.mInstaller.destroyAppData(pkg.volumeUuid, pkg.packageName, realUserId, flags, ps != null ? ps.getCeDataInode(realUserId) : 0);
            } catch (InstallerException e) {
                Slog.w(TAG, String.valueOf(e));
            }
            this.mDexManager.notifyPackageDataDestroyed(pkg.packageName, userId);
        }
    }

    private void destroyAppProfilesLIF(Package pkg, int userId) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        destroyAppProfilesLeafLIF(pkg);
        int i = 0;
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        while (i < childCount) {
            destroyAppProfilesLeafLIF((Package) pkg.childPackages.get(i));
            i++;
        }
    }

    private void destroyAppProfilesLeafLIF(Package pkg) {
        try {
            this.mInstaller.destroyAppProfiles(pkg.packageName);
        } catch (InstallerException e) {
            Slog.w(TAG, String.valueOf(e));
        }
    }

    private void clearAppProfilesLIF(Package pkg, int userId) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        this.mArtManagerService.clearAppProfiles(pkg);
        int i = 0;
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        while (i < childCount) {
            this.mArtManagerService.clearAppProfiles((Package) pkg.childPackages.get(i));
            i++;
        }
    }

    private void setInstallAndUpdateTime(Package pkg, long firstInstallTime, long lastUpdateTime) {
        PackageSetting ps = pkg.mExtras;
        if (ps != null) {
            ps.firstInstallTime = firstInstallTime;
            ps.lastUpdateTime = lastUpdateTime;
        }
        int i = 0;
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        while (i < childCount) {
            ps = ((Package) pkg.childPackages.get(i)).mExtras;
            if (ps != null) {
                ps.firstInstallTime = firstInstallTime;
                ps.lastUpdateTime = lastUpdateTime;
            }
            i++;
        }
    }

    private void addSharedLibraryLPr(Set<String> usesLibraryFiles, SharedLibraryEntry file, Package changingLib) {
        if (file.path != null) {
            usesLibraryFiles.add(file.path);
            return;
        }
        Package p = (Package) this.mPackages.get(file.apk);
        if (changingLib != null && changingLib.packageName.equals(file.apk) && (p == null || p.packageName.equals(changingLib.packageName))) {
            p = changingLib;
        }
        if (p != null) {
            usesLibraryFiles.addAll(p.getAllCodePaths());
            if (p.usesLibraryFiles != null) {
                Collections.addAll(usesLibraryFiles, p.usesLibraryFiles);
            }
        }
    }

    private void updateSharedLibrariesLPr(Package pkg, Package changingLib) throws PackageManagerException {
        if (pkg != null) {
            Set<String> usesLibraryFiles = null;
            if (pkg.usesLibraries != null) {
                usesLibraryFiles = addSharedLibrariesLPw(pkg.usesLibraries, null, null, pkg.packageName, changingLib, true, pkg.applicationInfo.targetSdkVersion, null);
            }
            if (pkg.usesStaticLibraries != null) {
                usesLibraryFiles = addSharedLibrariesLPw(pkg.usesStaticLibraries, pkg.usesStaticLibrariesVersions, pkg.usesStaticLibrariesCertDigests, pkg.packageName, changingLib, true, pkg.applicationInfo.targetSdkVersion, usesLibraryFiles);
            }
            if (pkg.usesOptionalLibraries != null) {
                usesLibraryFiles = addSharedLibrariesLPw(pkg.usesOptionalLibraries, null, null, pkg.packageName, changingLib, false, pkg.applicationInfo.targetSdkVersion, usesLibraryFiles);
            }
            if (ArrayUtils.isEmpty(usesLibraryFiles)) {
                pkg.usesLibraryFiles = null;
            } else {
                pkg.usesLibraryFiles = (String[]) usesLibraryFiles.toArray(new String[usesLibraryFiles.size()]);
            }
        }
    }

    private Set<String> addSharedLibrariesLPw(List<String> requestedLibraries, long[] requiredVersions, String[][] requiredCertDigests, String packageName, Package changingLib, boolean required, int targetSdk, Set<String> outUsedLibraries) throws PackageManagerException {
        int libCount;
        Package packageR;
        String str = packageName;
        int libCount2 = requestedLibraries.size();
        Set<String> outUsedLibraries2 = outUsedLibraries;
        int i = 0;
        while (i < libCount2) {
            long libVersion;
            String libName = (String) requestedLibraries.get(i);
            if (requiredVersions != null) {
                libVersion = requiredVersions[i];
            } else {
                libVersion = -1;
            }
            SharedLibraryEntry libEntry = getSharedLibraryEntryLPr(libName, libVersion);
            StringBuilder stringBuilder;
            if (libEntry != null) {
                StringBuilder stringBuilder2;
                if (requiredVersions == null || requiredCertDigests == null) {
                    libCount = libCount2;
                } else if (libEntry.info.getLongVersion() == requiredVersions[i]) {
                    Package libPkg = (Package) this.mPackages.get(libEntry.apk);
                    if (libPkg != null) {
                        String[] expectedCertDigests = requiredCertDigests[i];
                        if (expectedCertDigests.length > 1) {
                            String[] computeSignaturesSha256Digests;
                            if (targetSdk >= 27) {
                                computeSignaturesSha256Digests = PackageUtils.computeSignaturesSha256Digests(libPkg.mSigningDetails.signatures);
                            } else {
                                computeSignaturesSha256Digests = PackageUtils.computeSignaturesSha256Digests(new Signature[]{libPkg.mSigningDetails.signatures[0]});
                            }
                            String[] libCertDigests = computeSignaturesSha256Digests;
                            String[] libCertDigests2;
                            if (expectedCertDigests.length == libCertDigests.length) {
                                Arrays.sort(libCertDigests);
                                Arrays.sort(expectedCertDigests);
                                int certCount = libCertDigests.length;
                                int j = 0;
                                while (j < certCount) {
                                    int certCount2 = certCount;
                                    libCertDigests2 = libCertDigests;
                                    if (libCertDigests[j].equalsIgnoreCase(expectedCertDigests[j])) {
                                        j++;
                                        certCount = certCount2;
                                        libCertDigests = libCertDigests2;
                                    } else {
                                        stringBuilder2 = new StringBuilder();
                                        stringBuilder2.append("Package ");
                                        stringBuilder2.append(str);
                                        stringBuilder2.append(" requires differently signed static shared library; failing!");
                                        throw new PackageManagerException(-9, stringBuilder2.toString());
                                    }
                                }
                                libCount = libCount2;
                            } else {
                                libCertDigests2 = libCertDigests;
                                libCount = libCount2;
                                stringBuilder2 = new StringBuilder();
                                stringBuilder2.append("Package ");
                                stringBuilder2.append(str);
                                stringBuilder2.append(" requires differently signed static shared library; failing!");
                                throw new PackageManagerException(-9, stringBuilder2.toString());
                            }
                        }
                        libCount = libCount2;
                        if (!libPkg.mSigningDetails.hasSha256Certificate(ByteStringUtils.fromHexToByteArray(expectedCertDigests[0]))) {
                            stringBuilder2 = new StringBuilder();
                            stringBuilder2.append("Package ");
                            stringBuilder2.append(str);
                            stringBuilder2.append(" requires differently signed static shared library; failing!");
                            throw new PackageManagerException(-9, stringBuilder2.toString());
                        }
                    }
                    stringBuilder2 = new StringBuilder();
                    stringBuilder2.append("Package ");
                    stringBuilder2.append(str);
                    stringBuilder2.append(" requires unavailable static shared library; failing!");
                    throw new PackageManagerException(-9, stringBuilder2.toString());
                } else {
                    stringBuilder2 = new StringBuilder();
                    stringBuilder2.append("Package ");
                    stringBuilder2.append(str);
                    stringBuilder2.append(" requires unavailable static shared library ");
                    stringBuilder2.append(libName);
                    stringBuilder2.append(" version ");
                    stringBuilder2.append(libEntry.info.getLongVersion());
                    stringBuilder2.append("; failing!");
                    throw new PackageManagerException(-9, stringBuilder2.toString());
                }
                if (outUsedLibraries2 == null) {
                    outUsedLibraries2 = new LinkedHashSet();
                }
                addSharedLibraryLPr(outUsedLibraries2, libEntry, changingLib);
            } else if (required) {
                stringBuilder = new StringBuilder();
                stringBuilder.append("Package ");
                stringBuilder.append(str);
                stringBuilder.append(" requires unavailable shared library ");
                stringBuilder.append(libName);
                stringBuilder.append("; failing!");
                throw new PackageManagerException(-9, stringBuilder.toString());
            } else {
                if (DEBUG_SHARED_LIBRARIES) {
                    String str2 = TAG;
                    stringBuilder = new StringBuilder();
                    stringBuilder.append("Package ");
                    stringBuilder.append(str);
                    stringBuilder.append(" desires unavailable shared library ");
                    stringBuilder.append(libName);
                    stringBuilder.append("; ignoring!");
                    Slog.i(str2, stringBuilder.toString());
                }
                packageR = changingLib;
                libCount = libCount2;
            }
            i++;
            libCount2 = libCount;
        }
        List<String> list = requestedLibraries;
        packageR = changingLib;
        libCount = libCount2;
        return outUsedLibraries2;
    }

    private static boolean hasString(List<String> list, List<String> which) {
        if (list == null) {
            return false;
        }
        for (int i = list.size() - 1; i >= 0; i--) {
            for (int j = which.size() - 1; j >= 0; j--) {
                if (((String) which.get(j)).equals(list.get(i))) {
                    return true;
                }
            }
        }
        return false;
    }

    protected ArrayList<Package> updateAllSharedLibrariesLPw(Package changingPkg) {
        ArrayList<Package> res = null;
        for (Package pkg : this.mPackages.values()) {
            if (changingPkg != null && !hasString(pkg.usesLibraries, changingPkg.libraryNames) && !hasString(pkg.usesOptionalLibraries, changingPkg.libraryNames) && !ArrayUtils.contains(pkg.usesStaticLibraries, changingPkg.staticSharedLibName)) {
                return null;
            }
            if (res == null) {
                res = new ArrayList();
            }
            res.add(pkg);
            try {
                updateSharedLibrariesLPr(pkg, changingPkg);
            } catch (PackageManagerException e) {
                if (!pkg.isSystem() || pkg.isUpdatedSystemApp()) {
                    deletePackageLIF(pkg.packageName, null, true, sUserManager.getUserIds(), pkg.isUpdatedSystemApp() ? 1 : 0, null, true, null);
                }
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("updateAllSharedLibrariesLPw failed: ");
                stringBuilder.append(e.getMessage());
                Slog.e(str, stringBuilder.toString());
            }
        }
        return res;
    }

    private Package scanPackageTracedLI(Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        Package packageR = pkg;
        int scanFlags2 = scanFlags;
        Trace.traceBegin(262144, "scanPackage");
        if ((scanFlags2 & 1024) != 0) {
            scanFlags2 &= -1025;
        } else if (packageR.childPackages != null && packageR.childPackages.size() > 0) {
            scanFlags2 |= 1024;
        }
        int scanFlags3 = scanFlags2;
        try {
            Package scannedPkg = scanPackageNewLI(packageR, parseFlags, scanFlags3, currentTime, user);
            int i = 0;
            int childCount = packageR.childPackages != null ? packageR.childPackages.size() : 0;
            while (true) {
                int i2 = i;
                if (i2 >= childCount) {
                    break;
                }
                scanPackageNewLI((Package) packageR.childPackages.get(i2), parseFlags, scanFlags3, currentTime, user);
                i = i2 + 1;
            }
            if ((scanFlags3 & 1024) != 0) {
                return scanPackageTracedLI(packageR, parseFlags, scanFlags3, currentTime, user);
            }
            return scannedPkg;
        } finally {
            Trace.traceEnd(262144);
        }
    }

    private int adjustScanFlags(int scanFlags, PackageSetting pkgSetting, PackageSetting disabledPkgSetting, UserHandle user, Package pkg) {
        if (disabledPkgSetting != null) {
            scanFlags |= 131072;
            if ((disabledPkgSetting.pkgPrivateFlags & 8) != 0) {
                scanFlags |= 262144;
            }
            if ((131072 & disabledPkgSetting.pkgPrivateFlags) != 0) {
                scanFlags |= 524288;
            }
            if ((disabledPkgSetting.pkgPrivateFlags & 262144) != 0) {
                scanFlags |= 1048576;
            }
            if ((disabledPkgSetting.pkgPrivateFlags & 524288) != 0) {
                scanFlags |= 2097152;
            }
        }
        if (pkgSetting != null) {
            int userId = user == null ? 0 : user.getIdentifier();
            if (pkgSetting.getInstantApp(userId)) {
                scanFlags |= 16384;
            }
            if (pkgSetting.getVirtulalPreload(userId)) {
                scanFlags |= 65536;
            }
        }
        boolean skipVendorPrivilegeScan = (1048576 & scanFlags) != 0 && SystemProperties.getInt("ro.vndk.version", 28) < 28;
        if (!((scanFlags & 262144) != 0 || pkg.isPrivileged() || pkg.mSharedUserId == null || skipVendorPrivilegeScan)) {
            SharedUserSetting sharedUserSetting = null;
            try {
                sharedUserSetting = this.mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, false);
            } catch (PackageManagerException e) {
            }
            if (sharedUserSetting != null && sharedUserSetting.isPrivileged()) {
                synchronized (this.mPackages) {
                    if (PackageManagerServiceUtils.compareSignatures(((PackageSetting) this.mSettings.mPackages.get(PLATFORM_PACKAGE_NAME)).signatures.mSigningDetails.signatures, pkg.mSigningDetails.signatures) != 0) {
                        scanFlags |= 262144;
                    }
                }
            }
        }
        return scanFlags;
    }

    @GuardedBy("mInstallLock")
    private Package scanPackageNewLI(Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return scanPackageNewLI(pkg, parseFlags, scanFlags, currentTime, user, 0);
    }

    /* JADX WARNING: Missing block: B:89:0x01e5, code skipped:
            return r3;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    @GuardedBy("mInstallLock")
    private Package scanPackageNewLI(Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        String str;
        StringBuilder stringBuilder;
        Throwable th;
        PackageSetting packageSetting;
        Package packageR;
        boolean scanSucceeded;
        long j;
        SharedUserSetting sharedUserSetting;
        String str2;
        PackageSetting packageSetting2;
        Package packageR2 = pkg;
        int i = parseFlags;
        int i2 = hwFlags;
        PackageSetting disabledPkgSettingCheck = this.mSettings.getDisabledSystemPkgLPr(packageR2.packageName);
        if (!(disabledPkgSettingCheck == null || disabledPkgSettingCheck.codePath == null || disabledPkgSettingCheck.codePath.exists())) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("sysPackagesPath ");
            stringBuilder.append(disabledPkgSettingCheck.codePathString);
            stringBuilder.append(", has removed, remove its FLAG_SYSTEM & removeDisabledSystemPackageLPw");
            Slog.i(str, stringBuilder.toString());
            ApplicationInfo applicationInfo = packageR2.applicationInfo;
            applicationInfo.flags &= -2;
            applicationInfo = packageR2.applicationInfo;
            applicationInfo.flags &= -129;
            this.mSettings.removeDisabledSystemPackageLPw(packageR2.packageName);
        }
        String renamedPkgName = this.mSettings.getRenamedPackageLPr(packageR2.mRealPackage);
        String realPkgName = getRealPackageName(packageR2, renamedPkgName);
        if (realPkgName != null) {
            ensurePackageRenamed(packageR2, renamedPkgName);
        }
        PackageSetting originalPkgSetting = getOriginalPackageLocked(packageR2, renamedPkgName);
        PackageSetting pkgSetting = this.mSettings.getPackageLPr(packageR2.packageName);
        PackageSetting disabledPkgSetting = this.mSettings.getDisabledSystemPkgLPr(packageR2.packageName);
        if (this.mTransferedPackages.contains(packageR2.packageName)) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("Package ");
            stringBuilder.append(packageR2.packageName);
            stringBuilder.append(" was transferred to another, but its .apk remains");
            Slog.w(str, stringBuilder.toString());
        }
        int scanFlags2 = adjustScanFlags(scanFlags, pkgSetting, disabledPkgSetting, user, packageR2);
        if (disabledPkgSetting != null) {
            this.mHwPMSEx.resolvePersistentFlagForPackage(disabledPkgSetting.pkgFlags, packageR2);
        }
        synchronized (this.mPackages) {
            int i3;
            PackageSetting packageSetting3;
            try {
                applyPolicy(packageR2, i, scanFlags2, this.mPlatformPackage, i2);
                assertPackageIsValid(packageR2, i, scanFlags2);
                SharedUserSetting sharedUserSetting2 = null;
                if (packageR2.mSharedUserId != null) {
                    try {
                        sharedUserSetting2 = this.mSettings.getSharedUserLPw(packageR2.mSharedUserId, 0, 0, true);
                        if (DEBUG_PACKAGE_SCANNING && (Integer.MIN_VALUE & i) != 0) {
                            String str3 = TAG;
                            StringBuilder stringBuilder2 = new StringBuilder();
                            stringBuilder2.append("Shared UserID ");
                            stringBuilder2.append(packageR2.mSharedUserId);
                            stringBuilder2.append(" (uid=");
                            stringBuilder2.append(sharedUserSetting2.userId);
                            stringBuilder2.append("): packages=");
                            stringBuilder2.append(sharedUserSetting2.packages);
                            Log.d(str3, stringBuilder2.toString());
                        }
                    } catch (Throwable th2) {
                        th = th2;
                        packageSetting = disabledPkgSetting;
                        i3 = i2;
                        packageR = packageR2;
                        disabledPkgSetting = currentTime;
                        throw th;
                    }
                }
                SharedUserSetting sharedUserSetting3 = sharedUserSetting2;
                boolean scanSucceeded2 = false;
                try {
                    ScanRequest scanRequest;
                    SharedUserSetting sharedUserSetting4;
                    Package packageR3;
                    if (!isSystemApp(pkg)) {
                        try {
                            if (HwDeviceManager.disallowOp(7, packageR2.packageName)) {
                                UiThread.getHandler().post(new Runnable() {
                                    public void run() {
                                        if (PackageManagerService.this.mContext != null) {
                                            Toast toast = Toast.makeText(PackageManagerService.this.mContext, PackageManagerService.this.mContext.getString(33686100), 0);
                                            LayoutParams windowParams = toast.getWindowParams();
                                            windowParams.privateFlags |= 16;
                                            toast.show();
                                        }
                                    }
                                });
                                throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "app is not in the installpackage_whitelist");
                            }
                        } catch (Throwable th3) {
                            th = th3;
                            scanSucceeded = scanSucceeded2;
                            scanSucceeded2 = disabledPkgSetting;
                            i3 = i2;
                            packageR = packageR2;
                            j = currentTime;
                            destroyAppDataLIF(packageR, -1, 3);
                            destroyAppProfilesLIF(packageR, -1);
                            throw th;
                        }
                    }
                    if (isSystemApp(pkg)) {
                        scanSucceeded = scanSucceeded2;
                    } else {
                        try {
                            if (HwDeviceManager.disallowOp(19, packageR2.packageName)) {
                                str = getCallingAppName(this.mContext, packageR2);
                                scanSucceeded = scanSucceeded2;
                                try {
                                    new Handler().postDelayed(new Runnable() {
                                        public void run() {
                                            Toast.makeText(PackageManagerService.this.mContext, PackageManagerService.this.mContext.getResources().getString(33685933, new Object[]{str}), 0).show();
                                        }
                                    }, 500);
                                    throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "app is in the installpackage_blacklist");
                                } catch (Throwable th4) {
                                    th = th4;
                                    sharedUserSetting = sharedUserSetting3;
                                    scanSucceeded2 = disabledPkgSetting;
                                    i3 = i2;
                                    packageR = packageR2;
                                    j = currentTime;
                                    destroyAppDataLIF(packageR, -1, 3);
                                    destroyAppProfilesLIF(packageR, -1);
                                    throw th;
                                }
                            }
                            scanSucceeded = scanSucceeded2;
                        } catch (Throwable th5) {
                            th = th5;
                            scanSucceeded = scanSucceeded2;
                            sharedUserSetting = sharedUserSetting3;
                            scanSucceeded2 = disabledPkgSetting;
                            packageSetting3 = pkgSetting;
                            str2 = renamedPkgName;
                            packageSetting2 = disabledPkgSettingCheck;
                            i3 = i2;
                            packageR = packageR2;
                            disabledPkgSetting = currentTime;
                            if (!(scanSucceeded || (scanFlags2 & 64) == 0)) {
                                destroyAppDataLIF(packageR, -1, 3);
                                destroyAppProfilesLIF(packageR, -1);
                            }
                            throw th;
                        }
                    }
                    try {
                        Package packageR4 = pkgSetting == null ? null : pkgSetting.pkg;
                        scanRequest = scanRequest;
                        packageSetting3 = pkgSetting;
                        sharedUserSetting4 = sharedUserSetting3;
                        str2 = renamedPkgName;
                        packageR3 = packageR4;
                        packageSetting2 = disabledPkgSettingCheck;
                        i3 = i2;
                        sharedUserSetting = sharedUserSetting3;
                        packageR = packageR2;
                    } catch (Throwable th6) {
                        th = th6;
                        sharedUserSetting = sharedUserSetting3;
                        scanSucceeded2 = disabledPkgSetting;
                        packageSetting3 = pkgSetting;
                        str2 = renamedPkgName;
                        packageSetting2 = disabledPkgSettingCheck;
                        i3 = i2;
                        packageR = packageR2;
                        disabledPkgSetting = currentTime;
                        destroyAppDataLIF(packageR, -1, 3);
                        destroyAppProfilesLIF(packageR, -1);
                        throw th;
                    }
                    try {
                        scanRequest = new ScanRequest(packageR2, sharedUserSetting4, packageR3, packageSetting3, disabledPkgSetting, originalPkgSetting, realPkgName, parseFlags, scanFlags2, packageR2 == this.mPlatformPackage, user);
                        try {
                            ScanResult result = scanPackageOnlyLI(scanRequest, this.mFactoryTest, currentTime, i3);
                            if (result.success) {
                                commitScanResultsLocked(scanRequest, result, i3);
                            }
                            if (!(true || (scanFlags2 & 64) == 0)) {
                                destroyAppDataLIF(packageR, -1, 3);
                                destroyAppProfilesLIF(packageR, -1);
                            }
                        } catch (Throwable th7) {
                            th = th7;
                            throw th;
                        }
                    } catch (Throwable th8) {
                        th = th8;
                        j = currentTime;
                        destroyAppDataLIF(packageR, -1, 3);
                        destroyAppProfilesLIF(packageR, -1);
                        throw th;
                    }
                } catch (Throwable th9) {
                    th = th9;
                    sharedUserSetting = sharedUserSetting3;
                    scanSucceeded = scanSucceeded2;
                    packageSetting3 = pkgSetting;
                    str2 = renamedPkgName;
                    packageSetting2 = disabledPkgSettingCheck;
                    i3 = i2;
                    packageR = packageR2;
                    disabledPkgSetting = currentTime;
                    destroyAppDataLIF(packageR, -1, 3);
                    destroyAppProfilesLIF(packageR, -1);
                    throw th;
                }
            } catch (Throwable th10) {
                th = th10;
                packageSetting = disabledPkgSetting;
                packageSetting3 = pkgSetting;
                str2 = renamedPkgName;
                packageSetting2 = disabledPkgSettingCheck;
                i3 = i2;
                packageR = packageR2;
                disabledPkgSetting = currentTime;
                throw th;
            }
        }
    }

    @GuardedBy("mPackages")
    private void commitScanResultsLocked(ScanRequest request, ScanResult result) throws PackageManagerException {
        commitScanResultsLocked(request, result, 0);
    }

    /* JADX WARNING: Removed duplicated region for block: B:40:0x00e1  */
    /* JADX WARNING: Removed duplicated region for block: B:54:0x0152 A:{SYNTHETIC, Splitter:B:54:0x0152} */
    /* JADX WARNING: Removed duplicated region for block: B:45:0x00fa  */
    /* JADX WARNING: Removed duplicated region for block: B:109:0x026f  */
    /* JADX WARNING: Removed duplicated region for block: B:155:0x02e4 A:{SYNTHETIC, EDGE_INSN: B:155:0x02e4->B:128:0x02e4 ?: BREAK  , EDGE_INSN: B:155:0x02e4->B:128:0x02e4 ?: BREAK  } */
    /* JADX WARNING: Removed duplicated region for block: B:123:0x02cb  */
    /* JADX WARNING: Removed duplicated region for block: B:141:0x030a  */
    /* JADX WARNING: Removed duplicated region for block: B:130:0x02e8  */
    /* JADX WARNING: Removed duplicated region for block: B:40:0x00e1  */
    /* JADX WARNING: Removed duplicated region for block: B:45:0x00fa  */
    /* JADX WARNING: Removed duplicated region for block: B:54:0x0152 A:{SYNTHETIC, Splitter:B:54:0x0152} */
    /* JADX WARNING: Removed duplicated region for block: B:109:0x026f  */
    /* JADX WARNING: Removed duplicated region for block: B:123:0x02cb  */
    /* JADX WARNING: Removed duplicated region for block: B:155:0x02e4 A:{SYNTHETIC, EDGE_INSN: B:155:0x02e4->B:128:0x02e4 ?: BREAK  , EDGE_INSN: B:155:0x02e4->B:128:0x02e4 ?: BREAK  , EDGE_INSN: B:155:0x02e4->B:128:0x02e4 ?: BREAK  } */
    /* JADX WARNING: Removed duplicated region for block: B:130:0x02e8  */
    /* JADX WARNING: Removed duplicated region for block: B:141:0x030a  */
    /* JADX WARNING: Removed duplicated region for block: B:40:0x00e1  */
    /* JADX WARNING: Removed duplicated region for block: B:54:0x0152 A:{SYNTHETIC, Splitter:B:54:0x0152} */
    /* JADX WARNING: Removed duplicated region for block: B:45:0x00fa  */
    /* JADX WARNING: Removed duplicated region for block: B:109:0x026f  */
    /* JADX WARNING: Removed duplicated region for block: B:155:0x02e4 A:{SYNTHETIC, EDGE_INSN: B:155:0x02e4->B:128:0x02e4 ?: BREAK  , EDGE_INSN: B:155:0x02e4->B:128:0x02e4 ?: BREAK  , EDGE_INSN: B:155:0x02e4->B:128:0x02e4 ?: BREAK  , EDGE_INSN: B:155:0x02e4->B:128:0x02e4 ?: BREAK  } */
    /* JADX WARNING: Removed duplicated region for block: B:123:0x02cb  */
    /* JADX WARNING: Removed duplicated region for block: B:141:0x030a  */
    /* JADX WARNING: Removed duplicated region for block: B:130:0x02e8  */
    /* JADX WARNING: Removed duplicated region for block: B:109:0x026f  */
    /* JADX WARNING: Removed duplicated region for block: B:123:0x02cb  */
    /* JADX WARNING: Removed duplicated region for block: B:155:0x02e4 A:{SYNTHETIC, EDGE_INSN: B:155:0x02e4->B:128:0x02e4 ?: BREAK  , EDGE_INSN: B:155:0x02e4->B:128:0x02e4 ?: BREAK  , EDGE_INSN: B:155:0x02e4->B:128:0x02e4 ?: BREAK  , EDGE_INSN: B:155:0x02e4->B:128:0x02e4 ?: BREAK  , EDGE_INSN: B:155:0x02e4->B:128:0x02e4 ?: BREAK  } */
    /* JADX WARNING: Removed duplicated region for block: B:130:0x02e8  */
    /* JADX WARNING: Removed duplicated region for block: B:141:0x030a  */
    /* JADX WARNING: Removed duplicated region for block: B:150:0x0343  */
    /* JADX WARNING: Removed duplicated region for block: B:88:0x01c0  */
    /* JADX WARNING: Removed duplicated region for block: B:81:0x01ac A:{ExcHandler: IllegalArgumentException (e java.lang.IllegalArgumentException), Splitter:B:54:0x0152} */
    /* JADX WARNING: Failed to process nested try/catch */
    /* JADX WARNING: Missing block: B:82:0x01ad, code skipped:
            r25 = r4;
     */
    /* JADX WARNING: Missing block: B:83:0x01b8, code skipped:
            throw new com.android.server.pm.PackageManagerException(-104, "Signing certificates comparison made on incomparable signing details but somehow passed verifySignatures!");
     */
    /* JADX WARNING: Missing block: B:84:0x01b9, code skipped:
            r0 = e;
     */
    /* JADX WARNING: Missing block: B:85:0x01ba, code skipped:
            r25 = r4;
     */
    /* JADX WARNING: Missing block: B:88:0x01c0, code skipped:
            r1 = isSystemSignatureUpdated(r3.signatures.mSigningDetails.signatures, r11.mSigningDetails.signatures);
     */
    /* JADX WARNING: Missing block: B:89:0x01ce, code skipped:
            if (r1 != false) goto L_0x01d0;
     */
    /* JADX WARNING: Missing block: B:90:0x01d0, code skipped:
            r4 = TAG;
            r9 = new java.lang.StringBuilder();
            r26 = r6;
            r9.append("CertCompat: ");
            r9.append(r11.packageName);
            r9.append(" system signature update; retaining data.");
            android.util.Slog.i(r4, r9.toString());
     */
    /* JADX WARNING: Missing block: B:91:0x01f0, code skipped:
            r26 = r6;
     */
    /* JADX WARNING: Missing block: B:92:0x01f2, code skipped:
            r3.signatures.mSigningDetails = r11.mSigningDetails;
     */
    /* JADX WARNING: Missing block: B:93:0x01fa, code skipped:
            if (r7.sharedUser != null) goto L_0x01fc;
     */
    /* JADX WARNING: Missing block: B:94:0x01fc, code skipped:
            if (r1 != false) goto L_0x0232;
     */
    /* JADX WARNING: Missing block: B:99:0x0217, code skipped:
            r6 = new java.lang.StringBuilder();
            r6.append("Signature mismatch for shared user: ");
            r6.append(r3.sharedUser);
     */
    /* JADX WARNING: Missing block: B:100:0x0231, code skipped:
            throw new com.android.server.pm.PackageManagerException(-104, r6.toString());
     */
    /* JADX WARNING: Missing block: B:101:0x0232, code skipped:
            r7.sharedUser.signatures.mSigningDetails = r11.mSigningDetails;
            r7.sharedUser.signaturesChanged = java.lang.Boolean.TRUE;
     */
    /* JADX WARNING: Missing block: B:102:0x0240, code skipped:
            r4 = new java.lang.StringBuilder();
            r4.append("System package ");
            r4.append(r11.packageName);
            r4.append(" signature changed; retaining data.");
            reportSettingsProblem(5, r4.toString());
     */
    /* JADX WARNING: Missing block: B:150:0x0343, code skipped:
            r28 = r2;
            r9 = r3;
            r21 = r5;
            r22 = r6;
            r23 = r7;
            r17 = r19;
            r19 = r25;
     */
    /* JADX WARNING: Missing block: B:151:0x0350, code skipped:
            throw r0;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    @GuardedBy("mPackages")
    private void commitScanResultsLocked(ScanRequest request, ScanResult result, int hwFlags) throws PackageManagerException {
        PackageSetting signatureCheckPs;
        KeySetManagerService ksms;
        KeySetManagerService ksms2;
        PackageSetting disabledPkgSetting;
        int i;
        PackageSetting pkgSetting;
        int i2;
        ScanRequest scanRequest = request;
        ScanResult scanResult = result;
        Package pkg = scanRequest.pkg;
        Package oldPkg = scanRequest.oldPkg;
        int parseFlags = scanRequest.parseFlags;
        int scanFlags = scanRequest.scanFlags;
        PackageSetting oldPkgSetting = scanRequest.oldPkgSetting;
        PackageSetting originalPkgSetting = scanRequest.originalPkgSetting;
        PackageSetting disabledPkgSetting2 = scanRequest.disabledPkgSetting;
        UserHandle user = scanRequest.user;
        String realPkgName = scanRequest.realPkgName;
        PackageSetting pkgSetting2 = scanResult.pkgSetting;
        List<String> changedAbiCodePath = scanResult.changedAbiCodePath;
        PackageSetting packageSetting = null;
        if (scanResult.pkgSetting != scanRequest.pkgSetting) {
            if (originalPkgSetting != null) {
                this.mSettings.addRenamedPackageLPw(pkg.packageName, originalPkgSetting.name);
            }
            this.mSettings.addUserToSettingLPw(pkgSetting2);
            if (originalPkgSetting != null && (scanFlags & 1024) == 0) {
                this.mTransferedPackages.add(originalPkgSetting.name);
            }
        }
        pkg.applicationInfo.uid = pkgSetting2.appId;
        this.mSettings.writeUserRestrictionsLPw(pkgSetting2, oldPkgSetting);
        if ((scanFlags & 1024) == 0 && realPkgName != null) {
            this.mTransferedPackages.add(pkg.packageName);
        }
        String realPkgName2;
        PackageSetting packageSetting2;
        if ((hwFlags & 1073741824) != 0) {
            realPkgName2 = realPkgName;
            packageSetting2 = originalPkgSetting;
        } else if ((scanFlags & 16) == 0 && (parseFlags & 16) == 0) {
            realPkgName2 = realPkgName;
            packageSetting2 = originalPkgSetting;
        } else {
            String deletedSysAppName = this.mSettings.getDisabledSystemPackageName(pkg.codePath);
            String origName;
            if (deletedSysAppName == null || deletedSysAppName.equals(pkg.packageName)) {
                PackageManagerException e;
                realPkgName2 = realPkgName;
                packageSetting2 = originalPkgSetting;
                signatureCheckPs = pkgSetting2;
                if (pkg.applicationInfo.isStaticSharedLibrary()) {
                    SharedLibraryEntry libraryEntry = getLatestSharedLibraVersionLPr(pkg);
                    if (libraryEntry != null) {
                        signatureCheckPs = this.mSettings.getPackageLPr(libraryEntry.apk);
                    }
                }
                originalPkgSetting = signatureCheckPs;
                ksms = this.mSettings.mKeySetManagerService;
                if (ksms.shouldCheckUpgradeKeySetLocked(originalPkgSetting, scanFlags)) {
                    try {
                        boolean compareCompat = isCompatSignatureUpdateNeeded(pkg);
                        boolean compareRecover = isRecoverSignatureUpdateNeeded(pkg);
                        if (PackageManagerServiceUtils.verifySignatures(originalPkgSetting, disabledPkgSetting2, pkg.mSigningDetails, compareCompat, compareRecover)) {
                            synchronized (this.mPackages) {
                                ksms.removeAppKeySetDataLPw(pkg.packageName);
                            }
                        }
                        pkgSetting2.signatures.mSigningDetails = pkg.mSigningDetails;
                        if (originalPkgSetting.sharedUser != null) {
                            if (pkg.mSigningDetails.hasAncestor(originalPkgSetting.sharedUser.signatures.mSigningDetails)) {
                                originalPkgSetting.sharedUser.signatures.mSigningDetails = pkg.mSigningDetails;
                            }
                            if (originalPkgSetting.sharedUser.signaturesChanged == null) {
                                originalPkgSetting.sharedUser.signaturesChanged = Boolean.FALSE;
                            }
                        }
                    } catch (PackageManagerException e2) {
                        e = e2;
                        ksms2 = ksms;
                        if ((parseFlags & 16) == 0) {
                        }
                    } catch (IllegalArgumentException e3) {
                    }
                } else if (ksms.checkUpgradeKeySetLocked(originalPkgSetting, pkg)) {
                    pkgSetting2.signatures.mSigningDetails = pkg.mSigningDetails;
                } else if ((parseFlags & 16) != 0) {
                    pkgSetting2.signatures.mSigningDetails = pkg.mSigningDetails;
                    deletedSysAppName = new StringBuilder();
                    deletedSysAppName.append("System package ");
                    deletedSysAppName.append(pkg.packageName);
                    deletedSysAppName.append(" signature changed; retaining data.");
                    reportSettingsProblem(5, deletedSysAppName.toString());
                } else {
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("Package ");
                    stringBuilder.append(pkg.packageName);
                    stringBuilder.append(" upgrade keys do not match the previously installed version");
                    throw new PackageManagerException(-7, stringBuilder.toString());
                }
                ksms2 = ksms;
                disabledPkgSetting = disabledPkgSetting2;
                if ((scanFlags & 1024) == 0 && pkg.mAdoptPermissions != null) {
                    i = pkg.mAdoptPermissions.size() - 1;
                    while (i >= 0) {
                        origName = (String) pkg.mAdoptPermissions.get(i);
                        PackageSetting orig = this.mSettings.getPackageLPr(origName);
                        if (orig == null || !verifyPackageUpdateLPr(orig, pkg)) {
                            pkgSetting = pkgSetting2;
                        } else {
                            String str = TAG;
                            StringBuilder stringBuilder2 = new StringBuilder();
                            pkgSetting = pkgSetting2;
                            stringBuilder2.append("Adopting permissions from ");
                            stringBuilder2.append(origName);
                            stringBuilder2.append(" to ");
                            stringBuilder2.append(pkg.packageName);
                            Slog.i(str, stringBuilder2.toString());
                            this.mSettings.mPermissions.transferPermissions(origName, pkg.packageName);
                        }
                        i--;
                        pkgSetting2 = pkgSetting;
                    }
                }
                pkgSetting = pkgSetting2;
                if (changedAbiCodePath != null && changedAbiCodePath.size() > 0) {
                    i = changedAbiCodePath.size() - 1;
                    while (true) {
                        i2 = i;
                        if (i2 < 0) {
                            break;
                        }
                        try {
                            this.mInstaller.rmdex((String) changedAbiCodePath.get(i2), InstructionSets.getDexCodeInstructionSet(InstructionSets.getPreferredInstructionSet()));
                        } catch (InstallerException e4) {
                        }
                        i = i2 - 1;
                    }
                }
                KeySetManagerService realPkgName3;
                PackageSetting packageSetting3;
                if ((scanFlags & 1024) != 0) {
                    if (oldPkgSetting != null) {
                        synchronized (this.mPackages) {
                            this.mSettings.mPackages.put(oldPkgSetting.name, oldPkgSetting);
                        }
                    }
                    List<String> list = changedAbiCodePath;
                    UserHandle userHandle = user;
                    PackageSetting packageSetting4 = originalPkgSetting;
                    String str2 = realPkgName2;
                    realPkgName3 = ksms2;
                    PackageSetting packageSetting5 = disabledPkgSetting;
                    packageSetting3 = pkgSetting;
                    return;
                }
                e = user == null ? null : user.getIdentifier();
                if ((Integer.MIN_VALUE & parseFlags) != 0) {
                    packageSetting = 1;
                }
                disabledPkgSetting2 = pkgSetting;
                realPkgName3 = ksms2;
                packageSetting3 = disabledPkgSetting2;
                commitPackageSettings(pkg, oldPkg, disabledPkgSetting2, user, scanFlags, packageSetting);
                if (packageSetting3.getInstantApp(e)) {
                    this.mInstantAppRegistry.addInstantAppLPw(e, packageSetting3.appId);
                    return;
                }
                return;
            }
            if (this.mCustPms != null) {
                realPkgName2 = realPkgName;
                if (this.mCustPms.isListedApp(deletedSysAppName) != -1) {
                    packageSetting2 = originalPkgSetting;
                    signatureCheckPs = pkgSetting2;
                    if (pkg.applicationInfo.isStaticSharedLibrary()) {
                    }
                    originalPkgSetting = signatureCheckPs;
                    ksms = this.mSettings.mKeySetManagerService;
                    if (ksms.shouldCheckUpgradeKeySetLocked(originalPkgSetting, scanFlags)) {
                    }
                    ksms2 = ksms;
                    disabledPkgSetting = disabledPkgSetting2;
                    i = pkg.mAdoptPermissions.size() - 1;
                    while (i >= 0) {
                    }
                    pkgSetting = pkgSetting2;
                    i = changedAbiCodePath.size() - 1;
                    while (true) {
                        i2 = i;
                        if (i2 < 0) {
                        }
                        i = i2 - 1;
                    }
                    if ((scanFlags & 1024) != 0) {
                    }
                }
            } else {
                realPkgName2 = realPkgName;
            }
            origName = TAG;
            StringBuilder stringBuilder3 = new StringBuilder();
            stringBuilder3.append("deletedSysAppName ");
            stringBuilder3.append(deletedSysAppName);
            stringBuilder3.append(", IN ");
            stringBuilder3.append(pkg.codePath);
            stringBuilder3.append(", REMOVED");
            Log.i(origName, stringBuilder3.toString());
            this.mSettings.removeDisabledSystemPackageLPw(deletedSysAppName);
            signatureCheckPs = pkgSetting2;
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
            }
            originalPkgSetting = signatureCheckPs;
            ksms = this.mSettings.mKeySetManagerService;
            if (ksms.shouldCheckUpgradeKeySetLocked(originalPkgSetting, scanFlags)) {
            }
            ksms2 = ksms;
            disabledPkgSetting = disabledPkgSetting2;
            i = pkg.mAdoptPermissions.size() - 1;
            while (i >= 0) {
            }
            pkgSetting = pkgSetting2;
            i = changedAbiCodePath.size() - 1;
            while (true) {
                i2 = i;
                if (i2 < 0) {
                }
                i = i2 - 1;
            }
            if ((scanFlags & 1024) != 0) {
            }
        }
        updateSharedLibrariesLPr(pkg, null);
        signatureCheckPs = pkgSetting2;
        if (pkg.applicationInfo.isStaticSharedLibrary()) {
        }
        originalPkgSetting = signatureCheckPs;
        ksms = this.mSettings.mKeySetManagerService;
        if (ksms.shouldCheckUpgradeKeySetLocked(originalPkgSetting, scanFlags)) {
        }
        ksms2 = ksms;
        disabledPkgSetting = disabledPkgSetting2;
        i = pkg.mAdoptPermissions.size() - 1;
        while (i >= 0) {
        }
        pkgSetting = pkgSetting2;
        i = changedAbiCodePath.size() - 1;
        while (true) {
            i2 = i;
            if (i2 < 0) {
            }
            i = i2 - 1;
        }
        if ((scanFlags & 1024) != 0) {
        }
    }

    private static String getRealPackageName(Package pkg, String renamedPkgName) {
        if (isPackageRenamed(pkg, renamedPkgName)) {
            return pkg.mRealPackage;
        }
        return null;
    }

    private static boolean isPackageRenamed(Package pkg, String renamedPkgName) {
        return pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(renamedPkgName);
    }

    @GuardedBy("mPackages")
    private PackageSetting getOriginalPackageLocked(Package pkg, String renamedPkgName) {
        if (!isPackageRenamed(pkg, renamedPkgName)) {
            return null;
        }
        for (int i = pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
            PackageSetting originalPs = this.mSettings.getPackageLPr((String) pkg.mOriginalPackages.get(i));
            if (originalPs != null && verifyPackageUpdateLPr(originalPs, pkg)) {
                if (originalPs.sharedUser != null) {
                    if (!originalPs.sharedUser.name.equals(pkg.mSharedUserId)) {
                        String str = TAG;
                        StringBuilder stringBuilder = new StringBuilder();
                        stringBuilder.append("Unable to migrate data from ");
                        stringBuilder.append(originalPs.name);
                        stringBuilder.append(" to ");
                        stringBuilder.append(pkg.packageName);
                        stringBuilder.append(": old uid ");
                        stringBuilder.append(originalPs.sharedUser.name);
                        stringBuilder.append(" differs from ");
                        stringBuilder.append(pkg.mSharedUserId);
                        Slog.w(str, stringBuilder.toString());
                    }
                } else if (DEBUG_UPGRADE) {
                    String str2 = TAG;
                    StringBuilder stringBuilder2 = new StringBuilder();
                    stringBuilder2.append("Renaming new package ");
                    stringBuilder2.append(pkg.packageName);
                    stringBuilder2.append(" to old name ");
                    stringBuilder2.append(originalPs.name);
                    Log.v(str2, stringBuilder2.toString());
                }
                return originalPs;
            }
        }
        return null;
    }

    private static void ensurePackageRenamed(Package pkg, String renamedPackageName) {
        if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(renamedPackageName) && !pkg.packageName.equals(renamedPackageName)) {
            pkg.setPackageName(renamedPackageName);
        }
    }

    private static ScanResult scanPackageOnlyLI(ScanRequest request, boolean isUnderFactoryTest, long currentTime) throws PackageManagerException {
        return scanPackageOnlyLI(request, isUnderFactoryTest, currentTime, 0);
    }

    @GuardedBy("mInstallLock")
    private static ScanResult scanPackageOnlyLI(ScanRequest request, boolean isUnderFactoryTest, long currentTime, int hwFlags) throws PackageManagerException {
        boolean needToDeriveAbi;
        String secondaryCpuAbiFromSettings;
        String primaryCpuAbiFromSettings;
        boolean createNewPackage;
        String primaryCpuAbiFromSettings2;
        String secondaryCpuAbiFromSettings2;
        boolean isPlatformPackage;
        UserHandle user;
        SharedUserSetting sharedUserSetting;
        int scanFlags;
        int parseFlags;
        PackageSetting originalPkgSetting;
        PackageSetting disabledPkgSetting;
        PackageSetting originalPkgSetting2;
        String msg;
        int scanFlags2;
        ScanRequest scanRequest = request;
        long j = currentTime;
        Package pkg = scanRequest.pkg;
        PackageSetting pkgSetting = scanRequest.pkgSetting;
        PackageSetting disabledPkgSetting2 = scanRequest.disabledPkgSetting;
        PackageSetting originalPkgSetting3 = scanRequest.originalPkgSetting;
        int parseFlags2 = scanRequest.parseFlags;
        int scanFlags3 = scanRequest.scanFlags;
        String realPkgName = scanRequest.realPkgName;
        SharedUserSetting sharedUserSetting2 = scanRequest.sharedUserSetting;
        UserHandle user2 = scanRequest.user;
        boolean isPlatformPackage2 = scanRequest.isPlatformPackage;
        List<String> changedAbiCodePath = null;
        if (DEBUG_PACKAGE_SCANNING && (Integer.MIN_VALUE & parseFlags2) != 0) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Scanning package ");
            stringBuilder.append(pkg.packageName);
            Log.d(str, stringBuilder.toString());
        }
        DexManager.maybeLogUnexpectedPackageDetails(pkg);
        File scanFile = new File(pkg.codePath);
        File destCodeFile = new File(pkg.applicationInfo.getCodePath());
        File destResourceFile = new File(pkg.applicationInfo.getResourcePath());
        String primaryCpuAbiFromSettings3 = null;
        boolean bInstalled = false;
        boolean needToDeriveAbi2 = (scanFlags3 & 8192) != 0;
        if (needToDeriveAbi2) {
            needToDeriveAbi = needToDeriveAbi2;
            secondaryCpuAbiFromSettings = null;
            primaryCpuAbiFromSettings = primaryCpuAbiFromSettings3;
        } else if (pkgSetting != null) {
            primaryCpuAbiFromSettings = pkgSetting.primaryCpuAbiString;
            needToDeriveAbi = needToDeriveAbi2;
            secondaryCpuAbiFromSettings = pkgSetting.secondaryCpuAbiString;
        } else {
            needToDeriveAbi = true;
            secondaryCpuAbiFromSettings = null;
            primaryCpuAbiFromSettings = primaryCpuAbiFromSettings3;
        }
        if (!(pkgSetting == null || pkgSetting.sharedUser == sharedUserSetting2)) {
            StringBuilder stringBuilder2 = new StringBuilder();
            stringBuilder2.append("Package ");
            stringBuilder2.append(pkg.packageName);
            stringBuilder2.append(" shared user changed from ");
            stringBuilder2.append(pkgSetting.sharedUser != null ? pkgSetting.sharedUser.name : "<nothing>");
            stringBuilder2.append(" to ");
            stringBuilder2.append(sharedUserSetting2 != null ? sharedUserSetting2.name : "<nothing>");
            stringBuilder2.append("; replacing with new");
            reportSettingsProblem(5, stringBuilder2.toString());
            pkgSetting = null;
        }
        String[] usesStaticLibraries = null;
        if (pkg.usesStaticLibraries != null) {
            usesStaticLibraries = new String[pkg.usesStaticLibraries.size()];
            pkg.usesStaticLibraries.toArray(usesStaticLibraries);
        }
        boolean createNewPackage2 = pkgSetting == null;
        if (createNewPackage2) {
            createNewPackage = createNewPackage2;
            primaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings;
            secondaryCpuAbiFromSettings2 = secondaryCpuAbiFromSettings;
            isPlatformPackage = isPlatformPackage2;
            user = user2;
            sharedUserSetting = sharedUserSetting2;
            scanFlags = scanFlags3;
            parseFlags = parseFlags2;
            originalPkgSetting = originalPkgSetting3;
            disabledPkgSetting = disabledPkgSetting2;
            pkgSetting = Settings.createNewSetting(pkg.packageName, originalPkgSetting3, disabledPkgSetting2, realPkgName, sharedUserSetting, destCodeFile, destResourceFile, pkg.applicationInfo.nativeLibraryRootDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, (long) pkg.mVersionCode, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, user, true, (scanFlags3 & 16384) != 0, (65536 & scanFlags3) != 0, pkg.parentPackage ? pkg.parentPackage.packageName : null, pkg.getChildPackageNames(), UserManagerService.getInstance(), usesStaticLibraries, pkg.usesStaticLibrariesVersions);
        } else {
            secondaryCpuAbiFromSettings2 = secondaryCpuAbiFromSettings;
            createNewPackage = createNewPackage2;
            primaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings;
            isPlatformPackage = isPlatformPackage2;
            user = user2;
            sharedUserSetting = sharedUserSetting2;
            String str2 = realPkgName;
            scanFlags = scanFlags3;
            parseFlags = parseFlags2;
            originalPkgSetting = originalPkgSetting3;
            disabledPkgSetting = disabledPkgSetting2;
            Settings.updatePackageSetting(pkgSetting, disabledPkgSetting, sharedUserSetting, destCodeFile, destResourceFile, pkg.applicationInfo.nativeLibraryDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, pkg.getChildPackageNames(), UserManagerService.getInstance(), usesStaticLibraries, pkg.usesStaticLibrariesVersions);
        }
        if (createNewPackage) {
            originalPkgSetting2 = originalPkgSetting;
            if (originalPkgSetting2 != null) {
                pkg.setPackageName(originalPkgSetting2.name);
                msg = new StringBuilder();
                msg.append("New package ");
                msg.append(pkgSetting.realName);
                msg.append(" renamed to replace old package ");
                msg.append(pkgSetting.name);
                reportSettingsProblem(5, msg.toString());
            }
        } else {
            originalPkgSetting2 = originalPkgSetting;
        }
        UserHandle user3 = user;
        int userId = user3 == null ? 0 : user3.getIdentifier();
        if (createNewPackage) {
            scanFlags2 = scanFlags;
        } else {
            scanFlags2 = scanFlags;
            setInstantAppForUser(pkgSetting, userId, (scanFlags2 & 16384) != 0, (32768 & scanFlags2) != 0);
        }
        if (disabledPkgSetting != null) {
            ApplicationInfo applicationInfo = pkg.applicationInfo;
            applicationInfo.flags |= 128;
            HwPackageManagerServiceUtils.updateFlagsForMarketSystemApp(pkg);
        }
        SharedUserSetting sharedUserSetting3 = sharedUserSetting;
        int targetSdkVersion = (sharedUserSetting3 == null || sharedUserSetting3.packages.size() == 0) ? pkg.applicationInfo.targetSdkVersion : sharedUserSetting3.seInfoTargetSdkVersion;
        boolean isPrivileged = sharedUserSetting3 != null ? sharedUserSetting3.isPrivileged() | pkg.isPrivileged() : pkg.isPrivileged();
        pkg.applicationInfo.seInfo = SELinuxMMAC.getSeInfo(pkg, isPrivileged, pkg.applicationInfo.targetSandboxVersion, targetSdkVersion);
        pkg.applicationInfo.seInfoUser = SELinuxUtil.assignSeinfoUser(pkgSetting.readUserState(userId == -1 ? 0 : userId));
        pkg.mExtras = pkgSetting;
        pkg.applicationInfo.processName = fixProcessName(pkg.applicationInfo.packageName, pkg.applicationInfo.processName);
        if (!isPlatformPackage) {
            pkg.applicationInfo.initForUser(0);
        }
        String cpuAbiOverride = PackageManagerServiceUtils.deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting);
        PackageSetting packageSetting;
        if ((scanFlags2 & 4) != 0) {
            String str3 = secondaryCpuAbiFromSettings2;
            if ((scanFlags2 & 256) != 0) {
                pkg.applicationInfo.primaryCpuAbi = pkgSetting.primaryCpuAbiString;
                pkg.applicationInfo.secondaryCpuAbi = pkgSetting.secondaryCpuAbiString;
            }
            setNativeLibraryPaths(pkg, sAppLib32InstallDir);
        } else if (needToDeriveAbi) {
            Trace.traceBegin(262144, "derivePackageAbi");
            boolean z = (pkg.isLibrary() ^ 1) && !HwPackageManagerServiceUtils.isNoSystemPreApp(pkg.codePath);
            derivePackageAbi(pkg, cpuAbiOverride, z);
            Trace.traceEnd(262144);
            if (isSystemApp(pkg) && !pkg.isUpdatedSystemApp() && pkg.applicationInfo.primaryCpuAbi == null) {
                setBundledAppAbisAndRoots(pkg, pkgSetting);
                setNativeLibraryPaths(pkg, sAppLib32InstallDir);
            }
            packageSetting = originalPkgSetting2;
            String str4 = primaryCpuAbiFromSettings2;
        } else {
            if (primaryCpuAbiFromSettings2 != null || ((!isSystemApp(pkg) || pkg.isUpdatedSystemApp()) && !HwPackageManagerServiceUtils.isNoSystemPreApp(pkg.codePath))) {
                pkg.applicationInfo.primaryCpuAbi = primaryCpuAbiFromSettings2;
                pkg.applicationInfo.secondaryCpuAbi = secondaryCpuAbiFromSettings2;
            } else {
                boolean z2 = (pkg.isLibrary() || HwPackageManagerServiceUtils.isNoSystemPreApp(pkg.codePath)) ? false : true;
                derivePackageAbi(pkg, cpuAbiOverride, z2);
                if (pkg.applicationInfo.primaryCpuAbi == null) {
                    setBundledAppAbisAndRoots(pkg, pkgSetting);
                }
            }
            setNativeLibraryPaths(pkg, sAppLib32InstallDir);
            packageSetting = originalPkgSetting2;
        }
        if (isPlatformPackage) {
            pkg.applicationInfo.primaryCpuAbi = VMRuntime.getRuntime().is64Bit() ? Build.SUPPORTED_64_BIT_ABIS[0] : Build.SUPPORTED_32_BIT_ABIS[0];
        }
        if ((scanFlags2 & 1) != 0 || (scanFlags2 & 4) == 0 || cpuAbiOverride != null || pkg.packageName == null) {
        } else {
            secondaryCpuAbiFromSettings = TAG;
            StringBuilder stringBuilder3 = new StringBuilder();
            stringBuilder3.append("Ignoring persisted ABI override ");
            stringBuilder3.append(cpuAbiOverride);
            stringBuilder3.append(" for package ");
            stringBuilder3.append(pkg.packageName);
            Slog.w(secondaryCpuAbiFromSettings, stringBuilder3.toString());
        }
        pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;
        pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;
        pkgSetting.cpuAbiOverrideString = cpuAbiOverride;
        pkg.cpuAbiOverride = cpuAbiOverride;
        pkgSetting.legacyNativeLibraryPathString = pkg.applicationInfo.nativeLibraryRootDir;
        if ((scanFlags2 & 16) == 0 && pkgSetting.sharedUser != null) {
            changedAbiCodePath = adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages, pkg);
        }
        List<String> changedAbiCodePath2 = changedAbiCodePath;
        if (isUnderFactoryTest && pkg.requestedPermissions.contains("android.permission.FACTORY_TEST")) {
            ApplicationInfo applicationInfo2 = pkg.applicationInfo;
            applicationInfo2.flags |= 16;
        }
        if (isSystemApp(pkg)) {
            pkgSetting.isOrphaned = true;
        }
        j = PackageManagerServiceUtils.getLastModifiedTime(pkg);
        long j2 = currentTime;
        if (j2 != 0) {
            if (!pkgSetting.firstInstallTime) {
                pkgSetting.lastUpdateTime = j2;
                pkgSetting.firstInstallTime = j2;
            } else if ((scanFlags2 & 8) != 0) {
                pkgSetting.lastUpdateTime = j2;
            }
        } else {
            String str5 = cpuAbiOverride;
            if (pkgSetting.firstInstallTime == 0) {
                pkgSetting.lastUpdateTime = j;
                pkgSetting.firstInstallTime = j;
            } else if (!((parseFlags & 16) == 0 || j == pkgSetting.timeStamp)) {
                pkgSetting.lastUpdateTime = j;
            }
        }
        pkgSetting.setTimeStamp(j);
        pkgSetting.pkg = pkg;
        pkgSetting.pkgFlags = pkg.applicationInfo.flags;
        if (pkg.getLongVersionCode() != pkgSetting.versionCode) {
            pkgSetting.versionCode = pkg.getLongVersionCode();
        }
        String volumeUuid = pkg.applicationInfo.volumeUuid;
        if (!Objects.equals(volumeUuid, pkgSetting.volumeUuid)) {
            msg = TAG;
            StringBuilder stringBuilder4 = new StringBuilder();
            stringBuilder4.append("Update");
            stringBuilder4.append(pkgSetting.isSystem() ? " system" : BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS);
            stringBuilder4.append(" package ");
            stringBuilder4.append(pkg.packageName);
            stringBuilder4.append(" volume from ");
            stringBuilder4.append(pkgSetting.volumeUuid);
            stringBuilder4.append(" to ");
            stringBuilder4.append(volumeUuid);
            Slog.i(msg, stringBuilder4.toString());
            pkgSetting.volumeUuid = volumeUuid;
        }
        return new ScanResult(true, pkgSetting, changedAbiCodePath2);
    }

    private static boolean apkHasCode(String fileName) {
        StrictJarFile jarFile = null;
        boolean z = false;
        try {
            jarFile = new StrictJarFile(fileName, false, false);
            if (jarFile.findEntry("classes.dex") != null) {
                z = true;
            }
            try {
                jarFile.close();
            } catch (IOException e) {
            }
            return z;
        } catch (IOException e2) {
            if (jarFile != null) {
                try {
                    jarFile.close();
                } catch (IOException e3) {
                }
            }
            return false;
        } catch (Throwable th) {
            if (jarFile != null) {
                try {
                    jarFile.close();
                } catch (IOException e4) {
                }
            }
        }
    }

    private static void assertCodePolicy(Package pkg) throws PackageManagerException {
        StringBuilder stringBuilder;
        if (((pkg.applicationInfo.flags & 4) != 0) && !apkHasCode(pkg.baseCodePath)) {
            stringBuilder = new StringBuilder();
            stringBuilder.append("Package ");
            stringBuilder.append(pkg.baseCodePath);
            stringBuilder.append(" code is missing");
            throw new PackageManagerException(-2, stringBuilder.toString());
        } else if (!ArrayUtils.isEmpty(pkg.splitCodePaths)) {
            int i = 0;
            while (i < pkg.splitCodePaths.length) {
                if (!((pkg.splitFlags[i] & 4) != 0) || apkHasCode(pkg.splitCodePaths[i])) {
                    i++;
                } else {
                    stringBuilder = new StringBuilder();
                    stringBuilder.append("Package ");
                    stringBuilder.append(pkg.splitCodePaths[i]);
                    stringBuilder.append(" code is missing");
                    throw new PackageManagerException(-2, stringBuilder.toString());
                }
            }
        }
    }

    private static void applyPolicy(Package pkg, int parseFlags, int scanFlags, Package platformPkg, int hwFlags) {
        ApplicationInfo applicationInfo;
        Provider p;
        ApplicationInfo applicationInfo2;
        if ((scanFlags & 131072) != 0) {
            applicationInfo = pkg.applicationInfo;
            applicationInfo.flags |= 1;
            if (pkg.applicationInfo.isDirectBootAware()) {
                Activity a;
                ActivityInfo activityInfo;
                Iterator it = pkg.services.iterator();
                while (it.hasNext()) {
                    Service s = (Service) it.next();
                    ServiceInfo serviceInfo = s.info;
                    s.info.directBootAware = true;
                    serviceInfo.encryptionAware = true;
                }
                it = pkg.providers.iterator();
                while (it.hasNext()) {
                    p = (Provider) it.next();
                    ProviderInfo providerInfo = p.info;
                    p.info.directBootAware = true;
                    providerInfo.encryptionAware = true;
                }
                it = pkg.activities.iterator();
                while (it.hasNext()) {
                    a = (Activity) it.next();
                    activityInfo = a.info;
                    a.info.directBootAware = true;
                    activityInfo.encryptionAware = true;
                }
                it = pkg.receivers.iterator();
                while (it.hasNext()) {
                    a = (Activity) it.next();
                    activityInfo = a.info;
                    a.info.directBootAware = true;
                    activityInfo.encryptionAware = true;
                }
            }
            if (PackageManagerServiceUtils.compressedFileExists(pkg.codePath)) {
                pkg.isStub = true;
            }
        } else {
            pkg.coreApp = false;
            applicationInfo = pkg.applicationInfo;
            applicationInfo.flags &= -9;
            applicationInfo = pkg.applicationInfo;
            applicationInfo.privateFlags &= -33;
            applicationInfo = pkg.applicationInfo;
            applicationInfo.privateFlags &= -65;
            if (pkg.permissionGroups != null && pkg.permissionGroups.size() > 0) {
                for (int i = pkg.permissionGroups.size() - 1; i >= 0; i--) {
                    ((PermissionGroup) pkg.permissionGroups.get(i)).info.priority = 0;
                }
            }
        }
        if ((scanFlags & 262144) == 0) {
            int i2;
            pkg.protectedBroadcasts = null;
            if (pkg.receivers != null) {
                for (i2 = pkg.receivers.size() - 1; i2 >= 0; i2--) {
                    Activity receiver = (Activity) pkg.receivers.get(i2);
                    if ((receiver.info.flags & 1073741824) != 0) {
                        receiver.info.exported = false;
                    }
                }
            }
            if (pkg.services != null) {
                for (i2 = pkg.services.size() - 1; i2 >= 0; i2--) {
                    Service service = (Service) pkg.services.get(i2);
                    if ((service.info.flags & 1073741824) != 0) {
                        service.info.exported = false;
                    }
                }
            }
            if (pkg.providers != null) {
                i2 = pkg.providers.size() - 1;
                while (true) {
                    int i3 = i2;
                    if (i3 < 0) {
                        break;
                    }
                    p = (Provider) pkg.providers.get(i3);
                    if ((p.info.flags & 1073741824) != 0) {
                        p.info.exported = false;
                    }
                    i2 = i3 - 1;
                }
            }
        }
        if ((scanFlags & 262144) != 0) {
            ApplicationInfo applicationInfo3 = pkg.applicationInfo;
            applicationInfo3.privateFlags |= 8;
        }
        HwPackageManagerServiceUtils.addFlagsForRemovablePreApk(pkg, hwFlags);
        HwPackageManagerServiceUtils.addFlagsForUpdatedRemovablePreApk(pkg, hwFlags);
        if ((scanFlags & 524288) != 0) {
            applicationInfo2 = pkg.applicationInfo;
            applicationInfo2.privateFlags = 131072 | applicationInfo2.privateFlags;
        }
        if ((scanFlags & 1048576) != 0) {
            applicationInfo2 = pkg.applicationInfo;
            applicationInfo2.privateFlags = 262144 | applicationInfo2.privateFlags;
        }
        if ((2097152 & scanFlags) != 0) {
            applicationInfo = pkg.applicationInfo;
            applicationInfo.privateFlags = 524288 | applicationInfo.privateFlags;
        }
        if (PLATFORM_PACKAGE_NAME.equals(pkg.packageName) || (platformPkg != null && PackageManagerServiceUtils.compareSignatures(platformPkg.mSigningDetails.signatures, pkg.mSigningDetails.signatures) == 0)) {
            applicationInfo = pkg.applicationInfo;
            applicationInfo.privateFlags = 1048576 | applicationInfo.privateFlags;
        }
        if (!isSystemApp(pkg)) {
            pkg.mOriginalPackages = null;
            pkg.mRealPackage = null;
            pkg.mAdoptPermissions = null;
        }
    }

    private static <T> T assertNotNull(T object, String message) throws PackageManagerException {
        if (object != null) {
            return object;
        }
        throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, message);
    }

    private void assertPackageIsValid(Package pkg, int parseFlags, int scanFlags) throws PackageManagerException {
        assertPackageIsValid(pkg, parseFlags, scanFlags, 0);
    }

    private void assertPackageIsValid(Package pkg, int parseFlags, int scanFlags, int hwFlags) throws PackageManagerException {
        Package packageR = pkg;
        int i = scanFlags;
        if ((parseFlags & 64) != 0) {
            assertCodePolicy(pkg);
        }
        if (packageR.applicationInfo.getCodePath() == null || packageR.applicationInfo.getResourcePath() == null) {
            throw new PackageManagerException(-2, "Code and resource paths haven't been set correctly");
        }
        this.mSettings.mKeySetManagerService.assertScannedPackageValid(packageR);
        synchronized (this.mPackages) {
            StringBuilder stringBuilder;
            StringBuilder stringBuilder2;
            int childCount;
            int i2;
            StringBuilder stringBuilder3;
            StringBuilder stringBuilder4;
            PackageSetting known;
            if (packageR.packageName.equals(PLATFORM_PACKAGE_NAME)) {
                if (this.mAndroidApplication != null) {
                    Slog.w(TAG, "*************************************************");
                    Slog.w(TAG, "Core android package being redefined.  Skipping.");
                    String str = TAG;
                    stringBuilder = new StringBuilder();
                    stringBuilder.append(" codePath=");
                    stringBuilder.append(packageR.codePath);
                    Slog.w(str, stringBuilder.toString());
                    Slog.w(TAG, "*************************************************");
                    throw new PackageManagerException(-5, "Core android package being redefined.  Skipping.");
                }
            }
            if ((hwFlags & 1073741824) == 0) {
                if (this.mPackages.containsKey(packageR.packageName)) {
                    stringBuilder2 = new StringBuilder();
                    stringBuilder2.append("Application package ");
                    stringBuilder2.append(packageR.packageName);
                    stringBuilder2.append(" already installed.  Skipping duplicate.");
                    throw new PackageManagerException(-5, stringBuilder2.toString());
                }
            }
            if (packageR.applicationInfo.isStaticSharedLibrary()) {
                if (this.mPackages.containsKey(packageR.manifestPackageName)) {
                    throw new PackageManagerException("Duplicate static shared lib provider package");
                } else if (packageR.applicationInfo.targetSdkVersion < 26) {
                    throw new PackageManagerException("Packages declaring static-shared libs must target O SDK or higher");
                } else if ((i & 16384) != 0) {
                    throw new PackageManagerException("Packages declaring static-shared libs cannot be instant apps");
                } else if (!ArrayUtils.isEmpty(packageR.mOriginalPackages)) {
                    throw new PackageManagerException("Packages declaring static-shared libs cannot be renamed");
                } else if (!ArrayUtils.isEmpty(packageR.childPackages)) {
                    throw new PackageManagerException("Packages declaring static-shared libs cannot have child packages");
                } else if (!ArrayUtils.isEmpty(packageR.libraryNames)) {
                    throw new PackageManagerException("Packages declaring static-shared libs cannot declare dynamic libs");
                } else if (packageR.mSharedUserId != null) {
                    throw new PackageManagerException("Packages declaring static-shared libs cannot declare shared users");
                } else if (!packageR.activities.isEmpty()) {
                    throw new PackageManagerException("Static shared libs cannot declare activities");
                } else if (!packageR.services.isEmpty()) {
                    throw new PackageManagerException("Static shared libs cannot declare services");
                } else if (!packageR.providers.isEmpty()) {
                    throw new PackageManagerException("Static shared libs cannot declare content providers");
                } else if (!packageR.receivers.isEmpty()) {
                    throw new PackageManagerException("Static shared libs cannot declare broadcast receivers");
                } else if (!packageR.permissionGroups.isEmpty()) {
                    throw new PackageManagerException("Static shared libs cannot declare permission groups");
                } else if (!packageR.permissions.isEmpty()) {
                    throw new PackageManagerException("Static shared libs cannot declare permissions");
                } else if (packageR.protectedBroadcasts != null) {
                    throw new PackageManagerException("Static shared libs cannot declare protected broadcasts");
                } else if (packageR.mOverlayTarget == null) {
                    long minVersionCode = Long.MIN_VALUE;
                    long maxVersionCode = JobStatus.NO_LATEST_RUNTIME;
                    LongSparseArray<SharedLibraryEntry> versionedLib = (LongSparseArray) this.mSharedLibraries.get(packageR.staticSharedLibName);
                    if (versionedLib != null) {
                        int versionCount = versionedLib.size();
                        long maxVersionCode2 = JobStatus.NO_LATEST_RUNTIME;
                        long minVersionCode2 = Long.MIN_VALUE;
                        for (int i3 = 0; i3 < versionCount; i3++) {
                            SharedLibraryInfo libInfo = ((SharedLibraryEntry) versionedLib.valueAt(i3)).info;
                            long libVersionCode = libInfo.getDeclaringPackage().getLongVersionCode();
                            if (libInfo.getLongVersion() >= packageR.staticSharedLibVersion) {
                                long minVersionCode3 = minVersionCode2;
                                if (libInfo.getLongVersion() <= packageR.staticSharedLibVersion) {
                                    minVersionCode = libVersionCode;
                                    maxVersionCode = libVersionCode;
                                    break;
                                }
                                maxVersionCode2 = Math.min(maxVersionCode2, libVersionCode - 1);
                                minVersionCode2 = minVersionCode3;
                            } else {
                                minVersionCode2 = Math.max(minVersionCode2, libVersionCode + 1);
                            }
                        }
                        maxVersionCode = maxVersionCode2;
                        minVersionCode = minVersionCode2;
                    }
                    if (pkg.getLongVersionCode() < minVersionCode || pkg.getLongVersionCode() > maxVersionCode) {
                        throw new PackageManagerException("Static shared lib version codes must be ordered as lib versions");
                    }
                } else {
                    throw new PackageManagerException("Static shared libs cannot be overlay targets");
                }
            }
            if (!(packageR.childPackages == null || packageR.childPackages.isEmpty())) {
                if ((262144 & i) != 0) {
                    childCount = packageR.childPackages.size();
                    for (i2 = 0; i2 < childCount; i2++) {
                        if (this.mSettings.hasOtherDisabledSystemPkgWithChildLPr(packageR.packageName, ((Package) packageR.childPackages.get(i2)).packageName)) {
                            stringBuilder3 = new StringBuilder();
                            stringBuilder3.append("Can't override child of another disabled app. Ignoring package ");
                            stringBuilder3.append(packageR.packageName);
                            throw new PackageManagerException(stringBuilder3.toString());
                        }
                    }
                } else {
                    stringBuilder4 = new StringBuilder();
                    stringBuilder4.append("Only privileged apps can add child packages. Ignoring package ");
                    stringBuilder4.append(packageR.packageName);
                    throw new PackageManagerException(stringBuilder4.toString());
                }
            }
            if ((i & 128) != 0) {
                if (this.mExpectingBetter.containsKey(packageR.packageName)) {
                    stringBuilder4 = new StringBuilder();
                    stringBuilder4.append("Relax SCAN_REQUIRE_KNOWN requirement for package ");
                    stringBuilder4.append(packageR.packageName);
                    PackageManagerServiceUtils.logCriticalInfo(5, stringBuilder4.toString());
                } else {
                    known = this.mSettings.getPackageLPr(packageR.packageName);
                    if (known != null) {
                        if (DEBUG_PACKAGE_SCANNING) {
                            String str2 = TAG;
                            stringBuilder = new StringBuilder();
                            stringBuilder.append("Examining ");
                            stringBuilder.append(packageR.codePath);
                            stringBuilder.append(" and requiring known paths ");
                            stringBuilder.append(known.codePathString);
                            stringBuilder.append(" & ");
                            stringBuilder.append(known.resourcePathString);
                            Log.d(str2, stringBuilder.toString());
                        }
                        if (!packageR.applicationInfo.getCodePath().equals(known.codePathString) || !packageR.applicationInfo.getResourcePath().equals(known.resourcePathString)) {
                            stringBuilder2 = new StringBuilder();
                            stringBuilder2.append("Application package ");
                            stringBuilder2.append(packageR.packageName);
                            stringBuilder2.append(" found at ");
                            stringBuilder2.append(packageR.applicationInfo.getCodePath());
                            stringBuilder2.append(" but expected at ");
                            stringBuilder2.append(known.codePathString);
                            stringBuilder2.append("; ignoring.");
                            throw new PackageManagerException(-23, stringBuilder2.toString());
                        }
                    } else {
                        stringBuilder2 = new StringBuilder();
                        stringBuilder2.append("Application package ");
                        stringBuilder2.append(packageR.packageName);
                        stringBuilder2.append(" not found; ignoring.");
                        throw new PackageManagerException(-19, stringBuilder2.toString());
                    }
                }
            }
            if ((i & 4) != 0) {
                childCount = packageR.providers.size();
                for (i2 = 0; i2 < childCount; i2++) {
                    Provider p = (Provider) packageR.providers.get(i2);
                    if (p.info.authority != null) {
                        String[] names = p.info.authority.split(";");
                        for (int j = 0; j < names.length; j++) {
                            if (this.mProvidersByAuthority.containsKey(names[j])) {
                                Provider other = (Provider) this.mProvidersByAuthority.get(names[j]);
                                String otherPackageName = (other == null || other.getComponentName() == null) ? "?" : other.getComponentName().getPackageName();
                                StringBuilder stringBuilder5 = new StringBuilder();
                                stringBuilder5.append("Can't install because provider name ");
                                stringBuilder5.append(names[j]);
                                stringBuilder5.append(" (in package ");
                                stringBuilder5.append(packageR.applicationInfo.packageName);
                                stringBuilder5.append(") is already used by ");
                                stringBuilder5.append(otherPackageName);
                                throw new PackageManagerException(-13, stringBuilder5.toString());
                            }
                        }
                        continue;
                    }
                }
            }
            if (!(pkg.isPrivileged() || packageR.mSharedUserId == null)) {
                SharedUserSetting sharedUserSetting = null;
                try {
                    sharedUserSetting = this.mSettings.getSharedUserLPw(packageR.mSharedUserId, 0, 0, false);
                } catch (PackageManagerException e) {
                }
                if (sharedUserSetting != null) {
                    if (sharedUserSetting.isPrivileged()) {
                        known = (PackageSetting) this.mSettings.mPackages.get(PLATFORM_PACKAGE_NAME);
                        if (known.signatures.mSigningDetails != SigningDetails.UNKNOWN) {
                            if (PackageManagerServiceUtils.compareSignatures(known.signatures.mSigningDetails.signatures, packageR.mSigningDetails.signatures) != 0) {
                                stringBuilder2 = new StringBuilder();
                                stringBuilder2.append("Apps that share a user with a privileged app must themselves be marked as privileged. ");
                                stringBuilder2.append(packageR.packageName);
                                stringBuilder2.append(" shares privileged user ");
                                stringBuilder2.append(packageR.mSharedUserId);
                                stringBuilder2.append(".");
                                throw new PackageManagerException(stringBuilder2.toString());
                            }
                        }
                    }
                }
            }
            if (packageR.mOverlayTarget != null) {
                if ((131072 & i) != 0) {
                    if ((parseFlags & 16) == 0) {
                        PackageSetting previousPkg = (PackageSetting) assertNotNull(this.mSettings.getPackageLPr(packageR.packageName), "previous package state not present");
                        Package ppkg = previousPkg.pkg;
                        if (ppkg == null) {
                            try {
                                ppkg = new PackageParser().parsePackage(previousPkg.codePath, parseFlags | 16);
                            } catch (PackageParserException e2) {
                                String str3 = TAG;
                                stringBuilder3 = new StringBuilder();
                                stringBuilder3.append("failed to parse ");
                                stringBuilder3.append(previousPkg.codePath);
                                Slog.w(str3, stringBuilder3.toString(), e2);
                            }
                        }
                        if (ppkg != null) {
                            if (ppkg.mOverlayIsStatic) {
                                stringBuilder2 = new StringBuilder();
                                stringBuilder2.append("Overlay ");
                                stringBuilder2.append(packageR.packageName);
                                stringBuilder2.append(" is static and cannot be upgraded.");
                                throw new PackageManagerException(stringBuilder2.toString());
                            }
                        }
                        if (packageR.mOverlayIsStatic) {
                            stringBuilder2 = new StringBuilder();
                            stringBuilder2.append("Overlay ");
                            stringBuilder2.append(packageR.packageName);
                            stringBuilder2.append(" cannot be upgraded into a static overlay.");
                            throw new PackageManagerException(stringBuilder2.toString());
                        }
                    }
                } else if (packageR.mOverlayIsStatic) {
                    stringBuilder4 = new StringBuilder();
                    stringBuilder4.append("Overlay ");
                    stringBuilder4.append(packageR.packageName);
                    stringBuilder4.append(" is static but not pre-installed.");
                    throw new PackageManagerException(stringBuilder4.toString());
                } else {
                    known = this.mSettings.getPackageLPr(PLATFORM_PACKAGE_NAME);
                    if (known.signatures.mSigningDetails != SigningDetails.UNKNOWN) {
                        if (PackageManagerServiceUtils.compareSignatures(known.signatures.mSigningDetails.signatures, packageR.mSigningDetails.signatures) != 0) {
                            stringBuilder = new StringBuilder();
                            stringBuilder.append("Overlay ");
                            stringBuilder.append(packageR.packageName);
                            stringBuilder.append(" must be signed with the platform certificate.");
                            throw new PackageManagerException(stringBuilder.toString());
                        }
                    }
                }
            }
        }
    }

    private boolean addSharedLibraryLPw(String path, String apk, String name, long version, int type, String declaringPackageName, long declaringVersionCode) {
        int i;
        String str;
        String str2 = name;
        long j = version;
        LongSparseArray<SharedLibraryEntry> versionedLib = (LongSparseArray) this.mSharedLibraries.get(str2);
        if (versionedLib == null) {
            versionedLib = new LongSparseArray();
            this.mSharedLibraries.put(str2, versionedLib);
            i = type;
            if (i == 2) {
                str = declaringPackageName;
                this.mStaticLibsByDeclaringPackage.put(str, versionedLib);
            } else {
                str = declaringPackageName;
            }
        } else {
            i = type;
            str = declaringPackageName;
            if (versionedLib.indexOfKey(j) >= 0) {
                return false;
            }
        }
        versionedLib.put(j, new SharedLibraryEntry(path, apk, str2, j, i, str, declaringVersionCode));
        return true;
    }

    private boolean removeSharedLibraryLPw(String name, long version) {
        LongSparseArray<SharedLibraryEntry> versionedLib = (LongSparseArray) this.mSharedLibraries.get(name);
        if (versionedLib == null) {
            return false;
        }
        int libIdx = versionedLib.indexOfKey(version);
        if (libIdx < 0) {
            return false;
        }
        SharedLibraryEntry libEntry = (SharedLibraryEntry) versionedLib.valueAt(libIdx);
        versionedLib.remove(version);
        if (versionedLib.size() <= 0) {
            this.mSharedLibraries.remove(name);
            if (libEntry.info.getType() == 2) {
                this.mStaticLibsByDeclaringPackage.remove(libEntry.info.getDeclaringPackage().getPackageName());
            }
        }
        return true;
    }

    /* JADX WARNING: Removed duplicated region for block: B:295:0x03e7 A:{SYNTHETIC} */
    /* JADX WARNING: Removed duplicated region for block: B:119:0x02d9  */
    /* JADX WARNING: Removed duplicated region for block: B:153:0x0381 A:{Catch:{ all -> 0x06ac, all -> 0x036e, all -> 0x0455 }} */
    /* JADX WARNING: Removed duplicated region for block: B:132:0x02f7 A:{Catch:{ all -> 0x03de }} */
    /* JADX WARNING: Removed duplicated region for block: B:295:0x03e7 A:{SYNTHETIC} */
    /* JADX WARNING: Removed duplicated region for block: B:119:0x02d9  */
    /* JADX WARNING: Removed duplicated region for block: B:170:0x0415 A:{Catch:{ all -> 0x06ac, all -> 0x036e, all -> 0x0455 }} */
    /* JADX WARNING: Removed duplicated region for block: B:166:0x03fb A:{Catch:{ all -> 0x06ac, all -> 0x036e, all -> 0x0455 }} */
    /* JADX WARNING: Removed duplicated region for block: B:90:0x0226  */
    /* JADX WARNING: Removed duplicated region for block: B:96:0x0250 A:{SYNTHETIC, Splitter:B:96:0x0250} */
    /* JADX WARNING: Missing block: B:256:0x06ba, code skipped:
            if ("com.huawei.remoteassistant".equals(r12.packageName) == false) goto L_0x06e7;
     */
    /* JADX WARNING: Missing block: B:258:0x06c4, code skipped:
            if (checkSignatures(PLATFORM_PACKAGE_NAME, "com.huawei.remoteassistant") != 0) goto L_0x06e7;
     */
    /* JADX WARNING: Missing block: B:259:0x06c6, code skipped:
            r0 = TAG;
            r7 = new java.lang.StringBuilder();
            r7.append("ddMarketFlagsForApp when scanning for ");
            r7.append(r12.packageName);
            android.util.Slog.i(r0, r7.toString());
            r0 = r12.applicationInfo;
            r0.hwFlags |= 536870912;
     */
    /* JADX WARNING: Missing block: B:260:0x06e7, code skipped:
            r1 = r31;
     */
    /* JADX WARNING: Missing block: B:261:0x06e9, code skipped:
            if (r1 == null) goto L_0x06fe;
     */
    /* JADX WARNING: Missing block: B:263:?, code skipped:
            android.os.AsyncTask.execute(new com.android.server.pm.-$$Lambda$PackageManagerService$mOTJOturHO9FjzNA-qffT913E0M(r11, r12, r1, new java.util.ArrayList(r11.mPackages.keySet())));
     */
    /* JADX WARNING: Missing block: B:265:0x06ff, code skipped:
            android.os.Trace.traceEnd(262144);
     */
    /* JADX WARNING: Missing block: B:266:0x0705, code skipped:
            return;
     */
    /* JADX WARNING: Missing block: B:273:0x070f, code skipped:
            r0 = th;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void commitPackageSettings(Package pkg, Package oldPkg, PackageSetting pkgSetting, UserHandle user, int scanFlags, boolean chatty) {
        Throwable th;
        Package packageR;
        Package packageR2 = pkg;
        String pkgName = oldPkg;
        PackageSetting packageSetting = pkgSetting;
        int i = scanFlags;
        boolean z = chatty;
        String pkgName2 = packageR2.packageName;
        if (this.mCustomResolverComponentName != null && this.mCustomResolverComponentName.getPackageName().equals(packageR2.packageName)) {
            setUpCustomResolverActivity(pkg);
        }
        if (packageR2.packageName.equals(PLATFORM_PACKAGE_NAME)) {
            synchronized (this.mPackages) {
                if ((i & 1024) == 0) {
                    try {
                        this.mPlatformPackage = packageR2;
                        packageR2.mVersionCode = this.mSdkVersion;
                        packageR2.mVersionCodeMajor = 0;
                        this.mAndroidApplication = packageR2.applicationInfo;
                        if (!this.mResolverReplaced) {
                            this.mResolveActivity.applicationInfo = this.mAndroidApplication;
                            this.mResolveActivity.name = ResolverActivity.class.getName();
                            this.mResolveActivity.packageName = this.mAndroidApplication.packageName;
                            this.mResolveActivity.processName = "system:ui";
                            this.mResolveActivity.launchMode = 0;
                            this.mResolveActivity.documentLaunchMode = 3;
                            this.mResolveActivity.flags = 32;
                            this.mResolveActivity.theme = 16974374;
                            this.mResolveActivity.exported = true;
                            this.mResolveActivity.enabled = true;
                            this.mResolveActivity.resizeMode = 2;
                            this.mResolveActivity.configChanges = 3504;
                            this.mResolveInfo.activityInfo = this.mResolveActivity;
                            this.mResolveInfo.priority = 0;
                            this.mResolveInfo.preferredOrder = 0;
                            this.mResolveInfo.match = 0;
                            this.mResolveComponentName = new ComponentName(this.mAndroidApplication.packageName, this.mResolveActivity.name);
                        }
                    } finally {
                    }
                }
            }
        }
        setGMSPackage(pkg);
        ArrayMap arrayMap = this.mPackages;
        synchronized (arrayMap) {
            boolean hasStaticSharedLibs = false;
            ArrayMap arrayMap2;
            String str;
            String str2;
            try {
                StringBuilder stringBuilder;
                ArrayList<Package> clientLibPkgs;
                long j;
                ArrayList<Package> clientLibPkgs2;
                if (packageR2.staticSharedLibName != null) {
                    try {
                        ArrayMap arrayMap3 = arrayMap;
                        try {
                            arrayMap2 = arrayMap3;
                            pkgName = pkgName2;
                            if (addSharedLibraryLPw(null, packageR2.packageName, packageR2.staticSharedLibName, packageR2.staticSharedLibVersion, 2, packageR2.manifestPackageName, pkg.getLongVersionCode())) {
                                hasStaticSharedLibs = true;
                            } else {
                                str = TAG;
                                stringBuilder = new StringBuilder();
                                stringBuilder.append("Package ");
                                stringBuilder.append(packageR2.packageName);
                                stringBuilder.append(" library ");
                                stringBuilder.append(packageR2.staticSharedLibName);
                                stringBuilder.append(" already exists; skipping");
                                Slog.w(str, stringBuilder.toString());
                            }
                        } catch (Throwable th2) {
                            th = th2;
                            str2 = pkgName;
                            packageR = oldPkg;
                            while (true) {
                                break;
                            }
                            throw th;
                        }
                    } catch (Throwable th3) {
                        th = th3;
                        arrayMap2 = arrayMap;
                        packageR = oldPkg;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                }
                arrayMap2 = arrayMap;
                pkgName = pkgName2;
                if (!hasStaticSharedLibs) {
                    z = true;
                    if ((packageR2.applicationInfo.flags & 1) == 0 || packageR2.libraryNames == null) {
                        int i2 = 1;
                    } else {
                        String name;
                        boolean allowed;
                        int j2;
                        String name2;
                        int i3 = 0;
                        while (true) {
                            int i4 = i3;
                            if (i4 >= packageR2.libraryNames.size()) {
                                break;
                            }
                            boolean hasStaticSharedLibs2;
                            int i5;
                            name = (String) packageR2.libraryNames.get(i4);
                            allowed = false;
                            if (pkg.isUpdatedSystemApp()) {
                                PackageSetting sysPs = this.mSettings.getDisabledSystemPkgLPr(packageR2.packageName);
                                if (sysPs.pkg != null && sysPs.pkg.libraryNames != null) {
                                    for (j2 = 0; j2 < sysPs.pkg.libraryNames.size(); j2++) {
                                        if (name.equals(sysPs.pkg.libraryNames.get(j2))) {
                                            allowed = true;
                                            break;
                                        }
                                    }
                                }
                            } else {
                                allowed = true;
                            }
                            if (allowed) {
                                String name3 = name;
                                hasStaticSharedLibs2 = hasStaticSharedLibs;
                                hasStaticSharedLibs = z;
                                i5 = i4;
                                if (!addSharedLibraryLPw(null, packageR2.packageName, name, -1, 1, packageR2.packageName, pkg.getLongVersionCode())) {
                                    str = TAG;
                                    stringBuilder = new StringBuilder();
                                    stringBuilder.append("Package ");
                                    stringBuilder.append(packageR2.packageName);
                                    stringBuilder.append(" library ");
                                    stringBuilder.append(name3);
                                    stringBuilder.append(" already exists; skipping");
                                    Slog.w(str, stringBuilder.toString());
                                }
                            } else {
                                hasStaticSharedLibs2 = hasStaticSharedLibs;
                                name2 = name;
                                hasStaticSharedLibs = z;
                                i5 = i4;
                                str = TAG;
                                stringBuilder = new StringBuilder();
                                stringBuilder.append("Package ");
                                stringBuilder.append(packageR2.packageName);
                                stringBuilder.append(" declares lib ");
                                stringBuilder.append(name2);
                                stringBuilder.append(" that is not declared on system image; skipping");
                                Slog.w(str, stringBuilder.toString());
                            }
                            i3 = i5 + 1;
                            z = hasStaticSharedLibs;
                            hasStaticSharedLibs = hasStaticSharedLibs2;
                        }
                        hasStaticSharedLibs = z;
                        if ((i & 16) == 0) {
                            clientLibPkgs = updateAllSharedLibrariesLPw(pkg);
                            if ((i & 16) == 0 && (i & 2048) == 0 && (i & 4096) == 0) {
                                checkPackageFrozen(pkgName);
                            }
                            if (clientLibPkgs != null) {
                                for (int i6 = 0; i6 < clientLibPkgs.size(); i6++) {
                                    Package clientPkg = (Package) clientLibPkgs.get(i6);
                                    killApplication(clientPkg.applicationInfo.packageName, clientPkg.applicationInfo.uid, "update lib");
                                }
                            }
                            j = 262144;
                            Trace.traceBegin(262144, "updateSettings");
                            synchronized (this.mPackages) {
                                try {
                                    this.mSettings.insertPackageSettingLPw(packageSetting, packageR2);
                                    updateCertCompatPackage(packageR2, packageSetting);
                                    this.mPackages.put(packageR2.applicationInfo.packageName, packageR2);
                                    Iterator<PackageCleanItem> iter = this.mSettings.mPackagesToBeCleaned.iterator();
                                    while (iter.hasNext()) {
                                        try {
                                            if (pkgName.equals(((PackageCleanItem) iter.next()).packageName)) {
                                                iter.remove();
                                            }
                                        } catch (Throwable th4) {
                                            th = th4;
                                            packageR = oldPkg;
                                            throw th;
                                        }
                                    }
                                    this.mSettings.mKeySetManagerService.addScannedPackageLPw(packageR2);
                                    int N = packageR2.providers.size();
                                    StringBuilder r = null;
                                    int i7 = 0;
                                    loop16:
                                    while (true) {
                                        Iterator<PackageCleanItem> iter2;
                                        Provider p;
                                        String[] names;
                                        Provider p2;
                                        if (i7 >= N) {
                                            StringBuilder stringBuilder2;
                                            int i8;
                                            String str3;
                                            StringBuilder stringBuilder3;
                                            Activity a;
                                            clientLibPkgs2 = clientLibPkgs;
                                            iter2 = iter;
                                            str2 = pkgName;
                                            allowed = chatty;
                                            if (r != null && DEBUG_PACKAGE_SCANNING) {
                                                name2 = TAG;
                                                stringBuilder2 = new StringBuilder();
                                                stringBuilder2.append("  Providers: ");
                                                stringBuilder2.append(r);
                                                Log.d(name2, stringBuilder2.toString());
                                            }
                                            j2 = packageR2.services.size();
                                            stringBuilder2 = null;
                                            for (i8 = 0; i8 < j2; i8++) {
                                                Service s = (Service) packageR2.services.get(i8);
                                                ServiceInfo serviceInfo = s.info;
                                                r = fixProcessName(packageR2.applicationInfo.processName, s.info.processName);
                                                serviceInfo.processName = r;
                                                i7 = this.mServices;
                                                i7.addService(s);
                                                if (allowed) {
                                                    if (stringBuilder2 == null) {
                                                        r = 256;
                                                        stringBuilder2 = new StringBuilder(256);
                                                    } else {
                                                        stringBuilder2.append(' ');
                                                    }
                                                    i7 = s.info.name;
                                                    stringBuilder2.append(i7);
                                                }
                                            }
                                            if (stringBuilder2 != null && DEBUG_PACKAGE_SCANNING) {
                                                str3 = TAG;
                                                stringBuilder3 = new StringBuilder();
                                                r = "  Services: ";
                                                stringBuilder3.append(r);
                                                stringBuilder3.append(stringBuilder2);
                                                i7 = stringBuilder3.toString();
                                                Log.d(str3, i7);
                                            }
                                            j2 = packageR2.receivers.size();
                                            stringBuilder2 = null;
                                            for (i8 = 0; i8 < j2; i8++) {
                                                a = (Activity) packageR2.receivers.get(i8);
                                                a.info.processName = fixProcessName(packageR2.applicationInfo.processName, a.info.processName);
                                                i7 = this.mReceivers;
                                                r = HwBroadcastRadarUtil.KEY_RECEIVER;
                                                i7.addActivity(a, r);
                                                if (allowed) {
                                                    if (stringBuilder2 == null) {
                                                        r = 256;
                                                        stringBuilder2 = new StringBuilder(256);
                                                    } else {
                                                        stringBuilder2.append(' ');
                                                    }
                                                    i7 = a.info.name;
                                                    stringBuilder2.append(i7);
                                                }
                                            }
                                            if (stringBuilder2 != null && DEBUG_PACKAGE_SCANNING) {
                                                str3 = TAG;
                                                stringBuilder3 = new StringBuilder();
                                                r = "  Receivers: ";
                                                stringBuilder3.append(r);
                                                stringBuilder3.append(stringBuilder2);
                                                i7 = stringBuilder3.toString();
                                                Log.d(str3, i7);
                                            }
                                            j2 = packageR2.activities.size();
                                            stringBuilder2 = null;
                                            for (i8 = 0; i8 < j2; i8++) {
                                                a = (Activity) packageR2.activities.get(i8);
                                                a.info.processName = fixProcessName(packageR2.applicationInfo.processName, a.info.processName);
                                                i7 = this.mActivities;
                                                r = "activity";
                                                i7.addActivity(a, r);
                                                if (allowed) {
                                                    if (stringBuilder2 == null) {
                                                        r = 256;
                                                        stringBuilder2 = new StringBuilder(256);
                                                    } else {
                                                        stringBuilder2.append(' ');
                                                    }
                                                    i7 = a.info.name;
                                                    stringBuilder2.append(i7);
                                                }
                                            }
                                            if (stringBuilder2 != null && DEBUG_PACKAGE_SCANNING) {
                                                str3 = TAG;
                                                stringBuilder3 = new StringBuilder();
                                                r = "  Activities: ";
                                                stringBuilder3.append(r);
                                                stringBuilder3.append(stringBuilder2);
                                                i7 = stringBuilder3.toString();
                                                Log.d(str3, i7);
                                            }
                                            if ((i & 16384) != 0) {
                                                str3 = TAG;
                                                stringBuilder3 = new StringBuilder();
                                                stringBuilder3.append("Permission groups from package ");
                                                stringBuilder3.append(packageR2.packageName);
                                                r = " ignored: instant apps cannot define new permission groups.";
                                                stringBuilder3.append(r);
                                                i7 = stringBuilder3.toString();
                                                Slog.w(str3, i7);
                                            } else {
                                                this.mPermissionManager.addAllPermissionGroups(packageR2, allowed);
                                            }
                                            if ((i & 16384) != 0) {
                                                str3 = TAG;
                                                stringBuilder3 = new StringBuilder();
                                                stringBuilder3.append("Permissions from package ");
                                                stringBuilder3.append(packageR2.packageName);
                                                r = " ignored: instant apps cannot define new permissions.";
                                                stringBuilder3.append(r);
                                                i7 = stringBuilder3.toString();
                                                Slog.w(str3, i7);
                                            } else {
                                                this.mPermissionManager.addAllPermissions(packageR2, allowed);
                                            }
                                            j2 = packageR2.instrumentation.size();
                                            stringBuilder2 = null;
                                            for (i8 = 0; i8 < j2; i8++) {
                                                Instrumentation a2 = (Instrumentation) packageR2.instrumentation.get(i8);
                                                a2.info.packageName = packageR2.applicationInfo.packageName;
                                                a2.info.sourceDir = packageR2.applicationInfo.sourceDir;
                                                a2.info.publicSourceDir = packageR2.applicationInfo.publicSourceDir;
                                                a2.info.splitNames = packageR2.splitNames;
                                                a2.info.splitSourceDirs = packageR2.applicationInfo.splitSourceDirs;
                                                a2.info.splitPublicSourceDirs = packageR2.applicationInfo.splitPublicSourceDirs;
                                                a2.info.splitDependencies = packageR2.applicationInfo.splitDependencies;
                                                a2.info.dataDir = packageR2.applicationInfo.dataDir;
                                                a2.info.deviceProtectedDataDir = packageR2.applicationInfo.deviceProtectedDataDir;
                                                a2.info.credentialProtectedDataDir = packageR2.applicationInfo.credentialProtectedDataDir;
                                                a2.info.primaryCpuAbi = packageR2.applicationInfo.primaryCpuAbi;
                                                a2.info.secondaryCpuAbi = packageR2.applicationInfo.secondaryCpuAbi;
                                                a2.info.nativeLibraryDir = packageR2.applicationInfo.nativeLibraryDir;
                                                a2.info.secondaryNativeLibraryDir = packageR2.applicationInfo.secondaryNativeLibraryDir;
                                                i7 = this.mInstrumentation;
                                                i7.put(a2.getComponentName(), a2);
                                                if (allowed) {
                                                    if (stringBuilder2 == null) {
                                                        r = 256;
                                                        stringBuilder2 = new StringBuilder(256);
                                                    } else {
                                                        r = 256;
                                                        stringBuilder2.append(' ');
                                                    }
                                                    i7 = a2.info.name;
                                                    stringBuilder2.append(i7);
                                                } else {
                                                    r = 256;
                                                }
                                            }
                                            if (stringBuilder2 != null && DEBUG_PACKAGE_SCANNING) {
                                                String str4 = TAG;
                                                StringBuilder stringBuilder4 = new StringBuilder();
                                                i7 = "  Instrumentation: ";
                                                stringBuilder4.append(i7);
                                                stringBuilder4.append(stringBuilder2);
                                                Log.d(str4, stringBuilder4.toString());
                                            }
                                            if (packageR2.protectedBroadcasts == null) {
                                                break;
                                            }
                                            j = packageR2.protectedBroadcasts.size();
                                            N = this.mProtectedBroadcasts;
                                            synchronized (N) {
                                                for (i8 = 0; i8 < j; i8++) {
                                                    name = (String) packageR2.protectedBroadcasts.get(i8);
                                                    this.mProtectedBroadcasts.add(name);
                                                }
                                            }
                                            break loop16;
                                        }
                                        try {
                                            p = (Provider) packageR2.providers.get(i7);
                                            p.info.processName = fixProcessName(packageR2.applicationInfo.processName, p.info.processName);
                                            this.mProviders.addProvider(p);
                                            p.syncable = p.info.isSyncable;
                                            if (p.info.authority != null) {
                                                names = p.info.authority.split(";");
                                                p.info.authority = null;
                                                p2 = p;
                                                j2 = 0;
                                            } else {
                                                clientLibPkgs2 = clientLibPkgs;
                                                iter2 = iter;
                                                str2 = pkgName;
                                                clientLibPkgs = chatty;
                                                if (clientLibPkgs == null) {
                                                    if (r == null) {
                                                        r = new StringBuilder(256);
                                                    } else {
                                                        r.append(' ');
                                                    }
                                                    r.append(p.info.name);
                                                }
                                                i7++;
                                                clientLibPkgs = clientLibPkgs2;
                                                iter = iter2;
                                                pkgName = str2;
                                                j = 262144;
                                            }
                                        } catch (Throwable th5) {
                                            th = th5;
                                            clientLibPkgs2 = clientLibPkgs;
                                            str2 = pkgName;
                                            clientLibPkgs = chatty;
                                            packageR = oldPkg;
                                            throw th;
                                        }
                                        if (j2 < names.length) {
                                            Provider p3;
                                            try {
                                                if (this.mProvidersByAuthority.containsKey(names[j2])) {
                                                }
                                                j2++;
                                                clientLibPkgs = clientLibPkgs2;
                                                iter = iter2;
                                                pkgName = str2;
                                                p2 = p3;
                                                if (j2 < names.length) {
                                                }
                                            } catch (Throwable th6) {
                                                th = th6;
                                                str2 = pkgName;
                                                allowed = chatty;
                                                packageR = oldPkg;
                                            }
                                            if (j2 == 1) {
                                                if (p2.syncable) {
                                                    p2 = new Provider(p2);
                                                    p2.syncable = false;
                                                    clientLibPkgs2 = clientLibPkgs;
                                                    StringBuilder stringBuilder5;
                                                    if (this.mProvidersByAuthority.containsKey(names[j2])) {
                                                        this.mProvidersByAuthority.put(names[j2], p2);
                                                        if (p2.info.authority == null) {
                                                            try {
                                                                p2.info.authority = names[j2];
                                                                iter2 = iter;
                                                            } catch (Throwable th7) {
                                                                th = th7;
                                                                packageR = oldPkg;
                                                                throw th;
                                                            }
                                                        }
                                                        ProviderInfo providerInfo = p2.info;
                                                        StringBuilder stringBuilder6 = new StringBuilder();
                                                        iter2 = iter;
                                                        stringBuilder6.append(p2.info.authority);
                                                        stringBuilder6.append(";");
                                                        stringBuilder6.append(names[j2]);
                                                        providerInfo.authority = stringBuilder6.toString();
                                                        if (DEBUG_PACKAGE_SCANNING) {
                                                            String iter3 = pkgName;
                                                            if (chatty) {
                                                                try {
                                                                    pkgName2 = TAG;
                                                                    stringBuilder5 = new StringBuilder();
                                                                    str2 = iter3;
                                                                    stringBuilder5.append("Registered content provider: ");
                                                                    stringBuilder5.append(names[j2]);
                                                                    stringBuilder5.append(", className = ");
                                                                    stringBuilder5.append(p2.info.name);
                                                                    stringBuilder5.append(", isSyncable = ");
                                                                    stringBuilder5.append(p2.info.isSyncable);
                                                                    Log.d(pkgName2, stringBuilder5.toString());
                                                                    p3 = p2;
                                                                } catch (Throwable th8) {
                                                                    th = th8;
                                                                } finally {
                                                                }
                                                            }
                                                            str2 = iter3;
                                                            p3 = p2;
                                                        } else {
                                                            str2 = pkgName;
                                                            allowed = chatty;
                                                            p3 = p2;
                                                        }
                                                    } else {
                                                        iter2 = iter;
                                                        str2 = pkgName;
                                                        allowed = chatty;
                                                        Provider other = (Provider) this.mProvidersByAuthority.get(names[j2]);
                                                        pkgName2 = TAG;
                                                        stringBuilder5 = new StringBuilder();
                                                        p3 = p2;
                                                        stringBuilder5.append("Skipping provider name ");
                                                        stringBuilder5.append(names[j2]);
                                                        stringBuilder5.append(" (in package ");
                                                        stringBuilder5.append(packageR2.applicationInfo.packageName);
                                                        stringBuilder5.append("): name already used by ");
                                                        String packageName = (other == null || other.getComponentName() == null) ? "?" : other.getComponentName().getPackageName();
                                                        stringBuilder5.append(packageName);
                                                        Slog.w(pkgName2, stringBuilder5.toString());
                                                    }
                                                    j2++;
                                                    clientLibPkgs = clientLibPkgs2;
                                                    iter = iter2;
                                                    pkgName = str2;
                                                    p2 = p3;
                                                    if (j2 < names.length) {
                                                    }
                                                }
                                            }
                                            clientLibPkgs2 = clientLibPkgs;
                                        }
                                        clientLibPkgs2 = clientLibPkgs;
                                        iter2 = iter;
                                        str2 = pkgName;
                                        clientLibPkgs = chatty;
                                        p = p2;
                                        if (clientLibPkgs == null) {
                                        }
                                        i7++;
                                        clientLibPkgs = clientLibPkgs2;
                                        iter = iter2;
                                        pkgName = str2;
                                        j = 262144;
                                    }
                                    packageR = oldPkg;
                                    break;
                                } catch (Throwable th9) {
                                    th = th9;
                                    clientLibPkgs2 = clientLibPkgs;
                                    str2 = pkgName;
                                    packageR = oldPkg;
                                    throw th;
                                }
                                throw th;
                            }
                        }
                    }
                }
                clientLibPkgs = null;
                try {
                    checkPackageFrozen(pkgName);
                    if (clientLibPkgs != null) {
                    }
                    j = 262144;
                    Trace.traceBegin(262144, "updateSettings");
                    synchronized (this.mPackages) {
                    }
                } catch (Throwable th10) {
                    th = th10;
                    clientLibPkgs2 = clientLibPkgs;
                    str2 = pkgName;
                    packageR = oldPkg;
                    ArrayList<Package> arrayList = clientLibPkgs2;
                    while (true) {
                        break;
                    }
                    throw th;
                }
            } catch (Throwable th11) {
                th = th11;
                arrayMap2 = arrayMap;
                str2 = pkgName2;
                str = pkgName;
                while (true) {
                    break;
                }
                throw th;
            }
        }
    }

    private static void derivePackageAbi(Package pkg, String cpuAbiOverride, boolean extractLibs) throws PackageManagerException {
        setNativeLibraryPaths(pkg, sAppLib32InstallDir);
        if (pkg.isForwardLocked() || pkg.applicationInfo.isExternalAsec() || (isSystemApp(pkg) && !pkg.isUpdatedSystemApp())) {
            extractLibs = false;
        }
        String nativeLibraryRootStr = pkg.applicationInfo.nativeLibraryRootDir;
        boolean useIsaSpecificSubdirs = pkg.applicationInfo.nativeLibraryRootRequiresIsa;
        Handle handle = null;
        try {
            handle = Handle.create(pkg);
            File nativeLibraryRoot = new File(nativeLibraryRootStr);
            pkg.applicationInfo.primaryCpuAbi = null;
            pkg.applicationInfo.secondaryCpuAbi = null;
            StringBuilder stringBuilder;
            if (isMultiArch(pkg.applicationInfo)) {
                if (!(pkg.cpuAbiOverride == null || INSTALL_PACKAGE_SUFFIX.equals(pkg.cpuAbiOverride))) {
                    Slog.w(TAG, "Ignoring abiOverride for multi arch application.");
                }
                int abi32 = -114;
                int abi64 = -114;
                if (Build.SUPPORTED_32_BIT_ABIS.length > 0) {
                    if (extractLibs) {
                        Trace.traceBegin(262144, "copyNativeBinaries");
                        abi32 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, Build.SUPPORTED_32_BIT_ABIS, useIsaSpecificSubdirs);
                    } else {
                        Trace.traceBegin(262144, "findSupportedAbi");
                        abi32 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_32_BIT_ABIS);
                    }
                    Trace.traceEnd(262144);
                }
                if (abi32 >= 0 && pkg.isLibrary()) {
                    if (extractLibs) {
                        throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "Shared library native lib extraction not supported");
                    }
                }
                maybeThrowExceptionForMultiArchCopy("Error unpackaging 32 bit native libs for multiarch app.", abi32);
                if (Build.SUPPORTED_64_BIT_ABIS.length > 0) {
                    if (extractLibs) {
                        Trace.traceBegin(262144, "copyNativeBinaries");
                        abi64 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, Build.SUPPORTED_64_BIT_ABIS, useIsaSpecificSubdirs);
                    } else {
                        Trace.traceBegin(262144, "findSupportedAbi");
                        abi64 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_64_BIT_ABIS);
                    }
                    Trace.traceEnd(262144);
                }
                maybeThrowExceptionForMultiArchCopy("Error unpackaging 64 bit native libs for multiarch app.", abi64);
                if (abi64 >= 0) {
                    if (extractLibs) {
                        if (pkg.isLibrary()) {
                            throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "Shared library native lib extraction not supported");
                        }
                    }
                    pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[abi64];
                }
                if (abi32 >= 0) {
                    String abi = Build.SUPPORTED_32_BIT_ABIS[abi32];
                    if (abi64 < 0) {
                        pkg.applicationInfo.primaryCpuAbi = abi;
                    } else if (pkg.use32bitAbi) {
                        pkg.applicationInfo.secondaryCpuAbi = pkg.applicationInfo.primaryCpuAbi;
                        pkg.applicationInfo.primaryCpuAbi = abi;
                    } else {
                        pkg.applicationInfo.secondaryCpuAbi = abi;
                    }
                }
                stringBuilder = new StringBuilder();
                stringBuilder.append("derivePackageAbi for MultiArch : ");
                stringBuilder.append(pkg);
                stringBuilder.append(", path ");
                stringBuilder.append(nativeLibraryRootStr);
                stringBuilder.append(", need extractLibs ");
                stringBuilder.append(extractLibs);
                stringBuilder.append(", abi32 ");
                stringBuilder.append(abi32);
                stringBuilder.append(", abi64 ");
                stringBuilder.append(abi64);
                Flog.i(203, stringBuilder.toString());
            } else {
                int copyRet;
                String[] abiList = cpuAbiOverride != null ? new String[]{cpuAbiOverride} : Build.SUPPORTED_ABIS;
                boolean needsRenderScriptOverride = false;
                if (Build.SUPPORTED_64_BIT_ABIS.length > 0 && cpuAbiOverride == null && NativeLibraryHelper.hasRenderscriptBitcode(handle)) {
                    abiList = Build.SUPPORTED_32_BIT_ABIS;
                    needsRenderScriptOverride = true;
                }
                if (extractLibs) {
                    Trace.traceBegin(262144, "copyNativeBinaries");
                    copyRet = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, abiList, useIsaSpecificSubdirs);
                } else {
                    Trace.traceBegin(262144, "findSupportedAbi");
                    copyRet = NativeLibraryHelper.findSupportedAbi(handle, abiList);
                }
                Trace.traceEnd(262144);
                if (copyRet < 0) {
                    if (copyRet != -114) {
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("Error unpackaging native libs for app, errorCode=");
                        stringBuilder.append(copyRet);
                        throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, stringBuilder.toString());
                    }
                }
                if (copyRet >= 0) {
                    if (pkg.isLibrary()) {
                        throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "Shared library with native libs must be multiarch");
                    }
                    pkg.applicationInfo.primaryCpuAbi = abiList[copyRet];
                } else if (copyRet == -114 && cpuAbiOverride != null) {
                    pkg.applicationInfo.primaryCpuAbi = cpuAbiOverride;
                } else if (needsRenderScriptOverride) {
                    pkg.applicationInfo.primaryCpuAbi = abiList[0];
                }
            }
        } catch (IOException ioe) {
            String str = TAG;
            StringBuilder stringBuilder2 = new StringBuilder();
            stringBuilder2.append("Unable to get canonical file ");
            stringBuilder2.append(ioe.toString());
            Slog.e(str, stringBuilder2.toString());
        } catch (Throwable th) {
            IoUtils.closeQuietly(handle);
        }
        IoUtils.closeQuietly(handle);
        setNativeLibraryPaths(pkg, sAppLib32InstallDir);
    }

    private static List<String> adjustCpuAbisForSharedUserLPw(Set<PackageSetting> packagesForUser, Package scannedPackage) {
        List<String> changedAbiCodePath = null;
        String requiredInstructionSet = null;
        if (!(scannedPackage == null || scannedPackage.applicationInfo.primaryCpuAbi == null)) {
            requiredInstructionSet = VMRuntime.getInstructionSet(scannedPackage.applicationInfo.primaryCpuAbi);
        }
        PackageSetting requirer = null;
        for (PackageSetting ps : packagesForUser) {
            if (scannedPackage == null || !scannedPackage.packageName.equals(ps.name)) {
                if (ps.primaryCpuAbiString != null) {
                    String instructionSet = VMRuntime.getInstructionSet(ps.primaryCpuAbiString);
                    if (!(requiredInstructionSet == null || instructionSet.equals(requiredInstructionSet))) {
                        String errorMessage = new StringBuilder();
                        errorMessage.append("Instruction set mismatch, ");
                        errorMessage.append(requirer == null ? "[caller]" : requirer);
                        errorMessage.append(" requires ");
                        errorMessage.append(requiredInstructionSet);
                        errorMessage.append(" whereas ");
                        errorMessage.append(ps);
                        errorMessage.append(" requires ");
                        errorMessage.append(instructionSet);
                        Slog.w(TAG, errorMessage.toString());
                    }
                    if (requiredInstructionSet == null) {
                        requiredInstructionSet = instructionSet;
                        requirer = ps;
                    }
                }
            }
        }
        if (requiredInstructionSet != null) {
            String adjustedAbi;
            if (requirer != null) {
                adjustedAbi = requirer.primaryCpuAbiString;
                if (scannedPackage != null) {
                    scannedPackage.applicationInfo.primaryCpuAbi = adjustedAbi;
                }
            } else {
                adjustedAbi = scannedPackage.applicationInfo.primaryCpuAbi;
            }
            for (PackageSetting ps2 : packagesForUser) {
                if (scannedPackage == null || !scannedPackage.packageName.equals(ps2.name)) {
                    if (ps2.primaryCpuAbiString == null) {
                        if (SystemProperties.get("persist.sys.shareduid_abi_check", PACKAGE_PARSER_CACHE_VERSION).equals("0")) {
                            ps2.primaryCpuAbiString = adjustedAbi;
                        }
                        if (!(ps2.pkg == null || ps2.pkg.applicationInfo == null || TextUtils.equals(adjustedAbi, ps2.pkg.applicationInfo.primaryCpuAbi))) {
                            if (SystemProperties.get("persist.sys.shareduid_abi_check", PACKAGE_PARSER_CACHE_VERSION).equals("0")) {
                                ps2.pkg.applicationInfo.primaryCpuAbi = adjustedAbi;
                            }
                            if (changedAbiCodePath == null) {
                                changedAbiCodePath = new ArrayList();
                            }
                            SystemProperties.get("persist.sys.shareduid_abi_check", PACKAGE_PARSER_CACHE_VERSION).equals("0");
                            changedAbiCodePath.add(ps2.codePathString);
                        }
                    }
                }
            }
        }
        return changedAbiCodePath;
    }

    void setUpCustomResolverActivity(Package pkg) {
        Slog.w(TAG, "setUpCustomResolverActivity");
        synchronized (this.mPackages) {
            this.mResolverReplaced = true;
            this.mResolveActivity.applicationInfo = pkg.applicationInfo;
            this.mResolveActivity.name = this.mCustomResolverComponentName.getClassName();
            this.mResolveActivity.packageName = pkg.applicationInfo.packageName;
            this.mResolveActivity.processName = pkg.applicationInfo.packageName;
            this.mResolveActivity.launchMode = 0;
            this.mResolveActivity.flags = 288;
            this.mResolveActivity.theme = 0;
            this.mResolveActivity.exported = true;
            this.mResolveActivity.enabled = true;
            this.mResolveInfo.activityInfo = this.mResolveActivity;
            this.mResolveInfo.priority = 0;
            this.mResolveInfo.preferredOrder = 0;
            this.mResolveInfo.match = 0;
            this.mResolveComponentName = this.mCustomResolverComponentName;
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Replacing default ResolverActivity with custom activity: ");
            stringBuilder.append(this.mResolveComponentName);
            Slog.i(str, stringBuilder.toString());
        }
    }

    private void setUpInstantAppInstallerActivityLP(ActivityInfo installerActivity) {
        if (installerActivity == null) {
            if (DEBUG_INSTANT) {
                Slog.d(TAG, "Clear ephemeral installer activity");
            }
            this.mInstantAppInstallerActivity = null;
            return;
        }
        if (DEBUG_INSTANT) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Set ephemeral installer activity: ");
            stringBuilder.append(installerActivity.getComponentName());
            Slog.d(str, stringBuilder.toString());
        }
        this.mInstantAppInstallerActivity = installerActivity;
        ActivityInfo activityInfo = this.mInstantAppInstallerActivity;
        activityInfo.flags |= 288;
        this.mInstantAppInstallerActivity.exported = true;
        this.mInstantAppInstallerActivity.enabled = true;
        this.mInstantAppInstallerInfo.activityInfo = this.mInstantAppInstallerActivity;
        this.mInstantAppInstallerInfo.priority = 1;
        this.mInstantAppInstallerInfo.preferredOrder = 1;
        this.mInstantAppInstallerInfo.isDefault = true;
        this.mInstantAppInstallerInfo.match = 5799936;
    }

    private static String calculateBundledApkRoot(String codePathString) {
        File codeRoot;
        File codePath = new File(codePathString);
        if (FileUtils.contains(Environment.getRootDirectory(), codePath)) {
            codeRoot = Environment.getRootDirectory();
        } else if (FileUtils.contains(Environment.getOemDirectory(), codePath)) {
            codeRoot = Environment.getOemDirectory();
        } else if (FileUtils.contains(Environment.getVendorDirectory(), codePath)) {
            codeRoot = Environment.getVendorDirectory();
        } else if (FileUtils.contains(Environment.getOdmDirectory(), codePath)) {
            codeRoot = Environment.getOdmDirectory();
        } else if (FileUtils.contains(Environment.getProductDirectory(), codePath)) {
            codeRoot = Environment.getProductDirectory();
        } else {
            try {
                File parentFile;
                codeRoot = codePath.getCanonicalFile();
                File parent = codeRoot.getParentFile();
                while (true) {
                    parentFile = parent.getParentFile();
                    File tmp = parentFile;
                    if (parentFile == null) {
                        break;
                    }
                    codeRoot = parent;
                    parent = tmp;
                }
                parentFile = codeRoot;
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Unrecognized code path ");
                stringBuilder.append(codePath);
                stringBuilder.append(" - using ");
                stringBuilder.append(parentFile);
                Slog.w(str, stringBuilder.toString());
                codeRoot = parentFile;
            } catch (IOException e) {
                String str2 = TAG;
                StringBuilder stringBuilder2 = new StringBuilder();
                stringBuilder2.append("Can't canonicalize code path ");
                stringBuilder2.append(codePath);
                Slog.w(str2, stringBuilder2.toString());
                return Environment.getRootDirectory().getPath();
            }
        }
        return codeRoot.getPath();
    }

    protected static void setNativeLibraryPaths(Package pkg, File appLib32InstallDir) {
        ApplicationInfo info = pkg.applicationInfo;
        String codePath = pkg.codePath;
        File codeFile = new File(codePath);
        boolean bundledApp = info.isSystemApp() && !info.isUpdatedSystemApp();
        boolean asecApp = info.isForwardLocked() || info.isExternalAsec();
        info.nativeLibraryRootDir = null;
        info.nativeLibraryRootRequiresIsa = false;
        info.nativeLibraryDir = null;
        info.secondaryNativeLibraryDir = null;
        if (PackageParser.isApkFile(codeFile)) {
            if (bundledApp) {
                String apkRoot = calculateBundledApkRoot(info.sourceDir);
                boolean is64Bit = VMRuntime.is64BitInstructionSet(InstructionSets.getPrimaryInstructionSet(info));
                String apkName = deriveCodePathName(codePath);
                String libDir = is64Bit ? "lib64" : "lib";
                info.nativeLibraryRootDir = Environment.buildPath(new File(apkRoot), new String[]{libDir, apkName}).getAbsolutePath();
                if (info.secondaryCpuAbi != null) {
                    String secondaryLibDir = is64Bit ? "lib" : "lib64";
                    info.secondaryNativeLibraryDir = Environment.buildPath(new File(apkRoot), new String[]{secondaryLibDir, apkName}).getAbsolutePath();
                }
            } else if (asecApp) {
                info.nativeLibraryRootDir = new File(codeFile.getParentFile(), "lib").getAbsolutePath();
            } else {
                info.nativeLibraryRootDir = new File(appLib32InstallDir, deriveCodePathName(codePath)).getAbsolutePath();
            }
            info.nativeLibraryRootRequiresIsa = false;
            info.nativeLibraryDir = info.nativeLibraryRootDir;
            return;
        }
        info.nativeLibraryRootDir = new File(codeFile, "lib").getAbsolutePath();
        info.nativeLibraryRootRequiresIsa = true;
        info.nativeLibraryDir = new File(info.nativeLibraryRootDir, InstructionSets.getPrimaryInstructionSet(info)).getAbsolutePath();
        if (info.secondaryCpuAbi != null) {
            info.secondaryNativeLibraryDir = new File(info.nativeLibraryRootDir, VMRuntime.getInstructionSet(info.secondaryCpuAbi)).getAbsolutePath();
        }
    }

    private static void setBundledAppAbisAndRoots(Package pkg, PackageSetting pkgSetting) {
        setBundledAppAbi(pkg, calculateBundledApkRoot(pkg.applicationInfo.sourceDir), deriveCodePathName(pkg.applicationInfo.getCodePath()));
        if (pkgSetting != null) {
            pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;
            pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;
        }
    }

    private static void setBundledAppAbi(Package pkg, String apkRoot, String apkName) {
        boolean has64BitLibs;
        boolean has32BitLibs;
        File codeFile = new File(pkg.codePath);
        if (PackageParser.isApkFile(codeFile)) {
            has64BitLibs = new File(apkRoot, new File("lib64", apkName).getPath()).exists();
            has32BitLibs = new File(apkRoot, new File("lib", apkName).getPath()).exists();
        } else {
            File rootDir = new File(codeFile, "lib");
            if (ArrayUtils.isEmpty(Build.SUPPORTED_64_BIT_ABIS) || TextUtils.isEmpty(Build.SUPPORTED_64_BIT_ABIS[0])) {
                has32BitLibs = false;
            } else {
                has32BitLibs = new File(rootDir, VMRuntime.getInstructionSet(Build.SUPPORTED_64_BIT_ABIS[0])).exists();
            }
            if (ArrayUtils.isEmpty(Build.SUPPORTED_32_BIT_ABIS) || TextUtils.isEmpty(Build.SUPPORTED_32_BIT_ABIS[0])) {
                has64BitLibs = has32BitLibs;
                has32BitLibs = false;
            } else {
                has64BitLibs = has32BitLibs;
                has32BitLibs = new File(rootDir, VMRuntime.getInstructionSet(Build.SUPPORTED_32_BIT_ABIS[0])).exists();
            }
        }
        if (has64BitLibs && !has32BitLibs) {
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = null;
        } else if (has32BitLibs && !has64BitLibs) {
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = null;
        } else if (has32BitLibs && has64BitLibs) {
            if ((pkg.applicationInfo.flags & Integer.MIN_VALUE) == 0) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Package ");
                stringBuilder.append(pkg);
                stringBuilder.append(" has multiple bundled libs, but is not multiarch.");
                Slog.e(str, stringBuilder.toString());
            }
            if (VMRuntime.is64BitInstructionSet(InstructionSets.getPreferredInstructionSet())) {
                pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
                pkg.applicationInfo.secondaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
                return;
            }
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
        } else {
            pkg.applicationInfo.primaryCpuAbi = null;
            pkg.applicationInfo.secondaryCpuAbi = null;
        }
    }

    private void killApplication(String pkgName, int appId, String reason) {
        killApplication(pkgName, appId, -1, reason);
    }

    private void killApplication(String pkgName, int appId, int userId, String reason) {
        long token = Binder.clearCallingIdentity();
        try {
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                try {
                    am.killApplication(pkgName, appId, userId, reason);
                } catch (RemoteException e) {
                }
            }
            Binder.restoreCallingIdentity(token);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(token);
        }
    }

    private void removePackageLI(Package pkg, boolean chatty) {
        PackageSetting ps = pkg.mExtras;
        if (ps != null) {
            removePackageLI(ps, chatty);
        }
        int i = 0;
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        while (i < childCount) {
            ps = ((Package) pkg.childPackages.get(i)).mExtras;
            if (ps != null) {
                removePackageLI(ps, chatty);
            }
            i++;
        }
    }

    void removePackageLI(PackageSetting ps, boolean chatty) {
        if (DEBUG_INSTALL && chatty) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Removing package ");
            stringBuilder.append(ps.name);
            Log.d(str, stringBuilder.toString());
        }
        synchronized (this.mPackages) {
            this.mPackages.remove(ps.name);
            Package pkg = ps.pkg;
            if (pkg != null) {
                cleanPackageDataStructuresLILPw(pkg, chatty);
            }
        }
    }

    void removeInstalledPackageLI(Package pkg, boolean chatty) {
        if (DEBUG_INSTALL && chatty) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Removing package ");
            stringBuilder.append(pkg.applicationInfo.packageName);
            Log.d(str, stringBuilder.toString());
        }
        synchronized (this.mPackages) {
            this.mPackages.remove(pkg.applicationInfo.packageName);
            cleanPackageDataStructuresLILPw(pkg, chatty);
            int i = 0;
            int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
            while (i < childCount) {
                Package childPkg = (Package) pkg.childPackages.get(i);
                this.mPackages.remove(childPkg.applicationInfo.packageName);
                cleanPackageDataStructuresLILPw(childPkg, chatty);
                i++;
            }
        }
    }

    void cleanPackageDataStructuresLILPw(Package pkg, boolean chatty) {
        int i;
        StringBuilder stringBuilder;
        String str;
        Activity a;
        int N = pkg.providers.size();
        StringBuilder r = null;
        for (i = 0; i < N; i++) {
            Provider p = (Provider) pkg.providers.get(i);
            this.mProviders.removeProvider(p);
            if (p.info.authority != null) {
                String[] names = p.info.authority.split(";");
                for (int j = 0; j < names.length; j++) {
                    if (this.mProvidersByAuthority.get(names[j]) == p) {
                        this.mProvidersByAuthority.remove(names[j]);
                        if (DEBUG_REMOVE && chatty) {
                            String str2 = TAG;
                            StringBuilder stringBuilder2 = new StringBuilder();
                            stringBuilder2.append("Unregistered content provider: ");
                            stringBuilder2.append(names[j]);
                            stringBuilder2.append(", className = ");
                            stringBuilder2.append(p.info.name);
                            stringBuilder2.append(", isSyncable = ");
                            stringBuilder2.append(p.info.isSyncable);
                            Log.d(str2, stringBuilder2.toString());
                        }
                    }
                }
                if (DEBUG_REMOVE && chatty) {
                    if (r == null) {
                        r = new StringBuilder(256);
                    } else {
                        r.append(' ');
                    }
                    r.append(p.info.name);
                }
            }
        }
        if (r != null && DEBUG_REMOVE) {
            String str3 = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("  Providers: ");
            stringBuilder.append(r);
            Log.d(str3, stringBuilder.toString());
        }
        N = pkg.services.size();
        StringBuilder r2 = null;
        for (i = 0; i < N; i++) {
            Service s = (Service) pkg.services.get(i);
            this.mServices.removeService(s);
            if (chatty) {
                if (r2 == null) {
                    r2 = new StringBuilder(256);
                } else {
                    r2.append(' ');
                }
                r2.append(s.info.name);
            }
        }
        if (r2 != null && DEBUG_REMOVE) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("  Services: ");
            stringBuilder.append(r2);
            Log.d(str, stringBuilder.toString());
        }
        N = pkg.receivers.size();
        r2 = null;
        for (i = 0; i < N; i++) {
            a = (Activity) pkg.receivers.get(i);
            this.mReceivers.removeActivity(a, HwBroadcastRadarUtil.KEY_RECEIVER);
            if (DEBUG_REMOVE && chatty) {
                if (r2 == null) {
                    r2 = new StringBuilder(256);
                } else {
                    r2.append(' ');
                }
                r2.append(a.info.name);
            }
        }
        if (r2 != null && DEBUG_REMOVE) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("  Receivers: ");
            stringBuilder.append(r2);
            Log.d(str, stringBuilder.toString());
        }
        N = pkg.activities.size();
        r2 = null;
        for (i = 0; i < N; i++) {
            a = (Activity) pkg.activities.get(i);
            this.mActivities.removeActivity(a, "activity");
            if (DEBUG_REMOVE && chatty) {
                if (r2 == null) {
                    r2 = new StringBuilder(256);
                } else {
                    r2.append(' ');
                }
                r2.append(a.info.name);
            }
        }
        if (r2 != null && DEBUG_REMOVE) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("  Activities: ");
            stringBuilder.append(r2);
            Log.d(str, stringBuilder.toString());
        }
        this.mPermissionManager.removeAllPermissions(pkg, chatty);
        N = pkg.instrumentation.size();
        r2 = null;
        for (i = 0; i < N; i++) {
            Instrumentation a2 = (Instrumentation) pkg.instrumentation.get(i);
            this.mInstrumentation.remove(a2.getComponentName());
            if (DEBUG_REMOVE && chatty) {
                if (r2 == null) {
                    r2 = new StringBuilder(256);
                } else {
                    r2.append(' ');
                }
                r2.append(a2.info.name);
            }
        }
        if (r2 != null && DEBUG_REMOVE) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("  Instrumentation: ");
            stringBuilder.append(r2);
            Log.d(str, stringBuilder.toString());
        }
        r2 = null;
        if (!((pkg.applicationInfo.flags & 1) == 0 || pkg.libraryNames == null)) {
            for (i = 0; i < pkg.libraryNames.size(); i++) {
                str = (String) pkg.libraryNames.get(i);
                if (removeSharedLibraryLPw(str, 0) && DEBUG_REMOVE && chatty) {
                    if (r2 == null) {
                        r2 = new StringBuilder(256);
                    } else {
                        r2.append(' ');
                    }
                    r2.append(str);
                }
            }
        }
        r2 = null;
        if (pkg.staticSharedLibName != null && removeSharedLibraryLPw(pkg.staticSharedLibName, pkg.staticSharedLibVersion) && DEBUG_REMOVE && chatty) {
            if (r2 == null) {
                r2 = new StringBuilder(256);
            } else {
                r2.append(' ');
            }
            r2.append(pkg.staticSharedLibName);
        }
        if (r2 != null && DEBUG_REMOVE) {
            str = TAG;
            StringBuilder stringBuilder3 = new StringBuilder();
            stringBuilder3.append("  Libraries: ");
            stringBuilder3.append(r2);
            Log.d(str, stringBuilder3.toString());
        }
        writePackagesAbi();
    }

    public void sendPackageBroadcast(String action, String pkg, Bundle extras, int flags, String targetPkg, IIntentReceiver finishedReceiver, int[] userIds, int[] instantUserIds) {
        final int[] iArr = userIds;
        final String str = action;
        final String str2 = pkg;
        final Bundle bundle = extras;
        final int i = flags;
        final String str3 = targetPkg;
        final IIntentReceiver iIntentReceiver = finishedReceiver;
        final int[] iArr2 = instantUserIds;
        this.mHandler.post(new Runnable() {
            public void run() {
                try {
                    IActivityManager am = ActivityManager.getService();
                    if (am != null) {
                        int[] runningUserIds;
                        if (iArr == null) {
                            runningUserIds = am.getRunningUserIds();
                        } else {
                            runningUserIds = iArr;
                        }
                        PackageManagerService.this.doSendBroadcast(am, str, str2, bundle, i, str3, iIntentReceiver, runningUserIds, false);
                        if (!(iArr2 == null || iArr2 == PackageManagerService.EMPTY_INT_ARRAY)) {
                            PackageManagerService.this.doSendBroadcast(am, str, str2, bundle, i, str3, iIntentReceiver, iArr2, true);
                        }
                    }
                } catch (RemoteException e) {
                }
            }
        });
    }

    /* JADX WARNING: Missing block: B:9:0x0016, code skipped:
            r0 = r1.length - 1;
     */
    /* JADX WARNING: Missing block: B:10:0x0019, code skipped:
            if (r0 < 0) goto L_0x0023;
     */
    /* JADX WARNING: Missing block: B:11:0x001b, code skipped:
            r1[r0].onPackageAdded(r4);
            r0 = r0 - 1;
     */
    /* JADX WARNING: Missing block: B:12:0x0023, code skipped:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void notifyPackageAdded(String packageName) {
        synchronized (this.mPackages) {
            if (this.mPackageListObservers.size() == 0) {
                return;
            }
            PackageListObserver[] observers = (PackageListObserver[]) this.mPackageListObservers.toArray();
        }
    }

    /* JADX WARNING: Missing block: B:9:0x0016, code skipped:
            r0 = r1.length - 1;
     */
    /* JADX WARNING: Missing block: B:10:0x0019, code skipped:
            if (r0 < 0) goto L_0x0023;
     */
    /* JADX WARNING: Missing block: B:11:0x001b, code skipped:
            r1[r0].onPackageRemoved(r4);
            r0 = r0 - 1;
     */
    /* JADX WARNING: Missing block: B:12:0x0023, code skipped:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void notifyPackageRemoved(String packageName) {
        synchronized (this.mPackages) {
            if (this.mPackageListObservers.size() == 0) {
                return;
            }
            PackageListObserver[] observers = (PackageListObserver[]) this.mPackageListObservers.toArray();
        }
    }

    private void doSendBroadcast(IActivityManager am, String action, String pkg, Bundle extras, int flags, String targetPkg, IIntentReceiver finishedReceiver, int[] userIds, boolean isInstantApp) throws RemoteException {
        String str = pkg;
        Bundle bundle = extras;
        String str2 = targetPkg;
        for (int id : userIds) {
            Intent intent = new Intent(action, str != null ? Uri.fromParts("package", str, null) : null);
            String[] requiredPermissions = isInstantApp ? INSTANT_APP_BROADCAST_PERMISSION : null;
            if (bundle != null) {
                intent.putExtras(bundle);
            }
            if (str2 != null) {
                intent.setPackage(str2);
            }
            int uid = intent.getIntExtra("android.intent.extra.UID", -1);
            if (uid > 0 && UserHandle.getUserId(uid) != id) {
                uid = UserHandle.getUid(id, UserHandle.getAppId(uid));
                intent.putExtra("android.intent.extra.UID", uid);
            }
            intent.putExtra("android.intent.extra.user_handle", id);
            intent.addFlags(67108864 | flags);
            if (DEBUG_BROADCASTS) {
                RuntimeException here = new RuntimeException("here");
                here.fillInStackTrace();
                String str3 = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Sending to user ");
                stringBuilder.append(id);
                stringBuilder.append(": ");
                stringBuilder.append(intent.toShortString(false, true, false, false));
                stringBuilder.append(" ");
                stringBuilder.append(intent.getExtras());
                Slog.d(str3, stringBuilder.toString(), here);
            }
            am.broadcastIntent(null, intent, null, finishedReceiver, 0, null, null, requiredPermissions, -1, null, finishedReceiver != null, false, id);
        }
    }

    private boolean isExternalMediaAvailable() {
        return this.mMediaMounted || Environment.isExternalStorageEmulated();
    }

    public PackageCleanItem nextPackageToClean(PackageCleanItem lastPackage) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null || !isExternalMediaAvailable()) {
            return null;
        }
        synchronized (this.mPackages) {
            ArrayList<PackageCleanItem> pkgs = this.mSettings.mPackagesToBeCleaned;
            if (lastPackage != null) {
                pkgs.remove(lastPackage);
            }
            if (pkgs.size() > 0) {
                PackageCleanItem packageCleanItem = (PackageCleanItem) pkgs.get(0);
                return packageCleanItem;
            }
            return null;
        }
    }

    void schedulePackageCleaning(String packageName, int userId, boolean andCode) {
        Message msg = this.mHandler.obtainMessage(7, userId, andCode, packageName);
        if (this.mSystemReady) {
            msg.sendToTarget();
            return;
        }
        if (this.mPostSystemReadyMessages == null) {
            this.mPostSystemReadyMessages = new ArrayList();
        }
        this.mPostSystemReadyMessages.add(msg);
    }

    /* JADX WARNING: Missing block: B:11:0x0017, code skipped:
            r0 = new android.content.Intent("android.content.pm.CLEAN_EXTERNAL_STORAGE");
            r0.setComponent(DEFAULT_CONTAINER_COMPONENT);
            r1 = android.app.ActivityManager.getService();
     */
    /* JADX WARNING: Missing block: B:12:0x0027, code skipped:
            if (r1 == null) goto L_0x006a;
     */
    /* JADX WARNING: Missing block: B:13:0x0029, code skipped:
            r2 = -1;
            r3 = r10.mPackages;
     */
    /* JADX WARNING: Missing block: B:14:0x002c, code skipped:
            monitor-enter(r3);
     */
    /* JADX WARNING: Missing block: B:17:0x002f, code skipped:
            if (r10.mDefaultContainerWhitelisted != false) goto L_0x0048;
     */
    /* JADX WARNING: Missing block: B:18:0x0031, code skipped:
            r10.mDefaultContainerWhitelisted = true;
     */
    /* JADX WARNING: Missing block: B:19:0x0047, code skipped:
            r2 = android.os.UserHandle.getUid(0, ((com.android.server.pm.PackageSetting) r10.mSettings.mPackages.get(DEFAULT_CONTAINER_PACKAGE)).appId);
     */
    /* JADX WARNING: Missing block: B:20:0x0048, code skipped:
            r9 = r2;
     */
    /* JADX WARNING: Missing block: B:22:?, code skipped:
            monitor-exit(r3);
     */
    /* JADX WARNING: Missing block: B:23:0x004a, code skipped:
            if (r9 <= 0) goto L_0x0052;
     */
    /* JADX WARNING: Missing block: B:25:?, code skipped:
            r1.backgroundWhitelistUid(r9);
     */
    /* JADX WARNING: Missing block: B:28:0x0052, code skipped:
            r1.startService(null, r0, null, false, r10.mContext.getOpPackageName(), 0);
     */
    /* JADX WARNING: Missing block: B:29:0x0064, code skipped:
            r4 = th;
     */
    /* JADX WARNING: Missing block: B:30:0x0065, code skipped:
            r2 = r9;
     */
    /* JADX WARNING: Missing block: B:31:0x0067, code skipped:
            r4 = th;
     */
    /* JADX WARNING: Missing block: B:33:?, code skipped:
            monitor-exit(r3);
     */
    /* JADX WARNING: Missing block: B:34:0x0069, code skipped:
            throw r4;
     */
    /* JADX WARNING: Missing block: B:35:0x006a, code skipped:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    void startCleaningPackages() {
        if (isExternalMediaAvailable()) {
            synchronized (this.mPackages) {
                if (this.mSettings.mPackagesToBeCleaned.isEmpty()) {
                }
            }
        }
    }

    private int fixUpInstallReason(String installerPackageName, int installerUid, int installReason) {
        if (checkUidPermission("android.permission.INSTALL_PACKAGES", installerUid) == 0) {
            return installReason;
        }
        String ownerPackage = this.mProtectedPackages.getDeviceOwnerOrProfileOwnerPackage(UserHandle.getUserId(installerUid));
        if (ownerPackage != null && ownerPackage.equals(installerPackageName)) {
            return 1;
        }
        if (installReason == 1) {
            return 0;
        }
        return installReason;
    }

    void earlyBindToDefContainer() {
        this.mHandler.sendMessage(this.mHandler.obtainMessage(21));
    }

    void installStage(String packageName, File stagedDir, IPackageInstallObserver2 observer, SessionParams sessionParams, String installerPackageName, int installerUid, UserHandle user, SigningDetails signingDetails) {
        SessionParams sessionParams2 = sessionParams;
        int i = installerUid;
        if (!DEBUG_INSTANT || (sessionParams2.installFlags & 2048) == 0) {
            String str = packageName;
        } else {
            String str2 = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Ephemeral install of ");
            stringBuilder.append(packageName);
            Slog.d(str2, stringBuilder.toString());
        }
        VerificationInfo verificationInfo = new VerificationInfo(sessionParams2.originatingUri, sessionParams2.referrerUri, sessionParams2.originatingUid, i);
        OriginInfo origin = OriginInfo.fromStagedFile(stagedDir);
        Message msg = this.mHandler.obtainMessage(5);
        String str3 = installerPackageName;
        int installReason = fixUpInstallReason(str3, i, sessionParams2.installReason);
        int i2 = sessionParams2.installFlags;
        String str4 = sessionParams2.volumeUuid;
        String str5 = sessionParams2.abiOverride;
        String str6 = str5;
        Message msg2 = msg;
        InstallParams params = new InstallParams(origin, null, observer, i2, str3, str4, verificationInfo, user, str6, sessionParams2.grantedRuntimePermissions, signingDetails, installReason);
        params.setTraceMethod("installStage").setTraceCookie(System.identityHashCode(params));
        Message msg3 = msg2;
        msg3.obj = params;
        Trace.asyncTraceBegin(262144, "installStage", System.identityHashCode(msg3.obj));
        Trace.asyncTraceBegin(262144, "queueInstall", System.identityHashCode(msg3.obj));
        this.mHandler.sendMessage(msg3);
    }

    private void sendPackageAddedForUser(String packageName, PackageSetting pkgSetting, int userId) {
        boolean isSystem = isSystemApp(pkgSetting) || isUpdatedSystemApp(pkgSetting);
        boolean isInstantApp = pkgSetting.getInstantApp(userId);
        sendPackageAddedForNewUsers(packageName, isSystem, false, pkgSetting.appId, isInstantApp ? EMPTY_INT_ARRAY : new int[]{userId}, isInstantApp ? new int[]{userId} : EMPTY_INT_ARRAY);
        SessionInfo info = new SessionInfo();
        info.installReason = pkgSetting.getInstallReason(userId);
        info.appPackageName = packageName;
        sendSessionCommitBroadcast(info, userId);
    }

    public void sendPackageAddedForNewUsers(String packageName, boolean sendBootCompleted, boolean includeStopped, int appId, int[] userIds, int[] instantUserIds) {
        int[] iArr = userIds;
        if (!ArrayUtils.isEmpty(userIds) || !ArrayUtils.isEmpty(instantUserIds)) {
            Bundle extras = new Bundle(1);
            extras.putInt("android.intent.extra.UID", UserHandle.getUid(ArrayUtils.isEmpty(userIds) ? instantUserIds[0] : iArr[0], appId));
            sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName, extras, 0, null, null, iArr, instantUserIds);
            if (!sendBootCompleted || ArrayUtils.isEmpty(userIds)) {
                String str = packageName;
                boolean z = includeStopped;
            } else {
                this.mHandler.post(new -$$Lambda$PackageManagerService$8-IQ5_GLnR11f6LVoppcC-6hZ78(this, iArr, packageName, includeStopped));
            }
        }
    }

    public static /* synthetic */ void lambda$sendPackageAddedForNewUsers$5(PackageManagerService packageManagerService, int[] userIds, String packageName, boolean includeStopped) {
        for (int userId : userIds) {
            packageManagerService.sendBootCompletedBroadcastToSystemApp(packageName, includeStopped, userId);
        }
    }

    private void sendBootCompletedBroadcastToSystemApp(String packageName, boolean includeStopped, int userId) {
        RemoteException e;
        String str = packageName;
        int i = userId;
        if (this.mUserManagerInternal.isUserRunning(i)) {
            IActivityManager am = ActivityManager.getService();
            int i2;
            try {
                Intent lockedBcIntent = new Intent("android.intent.action.LOCKED_BOOT_COMPLETED").setPackage(str);
                if (includeStopped) {
                    lockedBcIntent.addFlags(32);
                }
                String[] requiredPermissions = new String[]{"android.permission.RECEIVE_BOOT_COMPLETED"};
                try {
                    am.broadcastIntent(null, lockedBcIntent, null, null, 0, null, null, requiredPermissions, -1, null, false, false, userId);
                    i2 = userId;
                } catch (RemoteException e2) {
                    e = e2;
                    i2 = userId;
                    throw e.rethrowFromSystemServer();
                }
                try {
                    if (this.mUserManagerInternal.isUserUnlockingOrUnlocked(i2)) {
                        Intent bcIntent = new Intent("android.intent.action.BOOT_COMPLETED").setPackage(str);
                        if (includeStopped) {
                            bcIntent.addFlags(32);
                        }
                        am.broadcastIntent(null, bcIntent, null, null, 0, null, null, requiredPermissions, -1, null, false, false, i2);
                    }
                } catch (RemoteException e3) {
                    e = e3;
                    throw e.rethrowFromSystemServer();
                }
            } catch (RemoteException e4) {
                e = e4;
                i2 = i;
                throw e.rethrowFromSystemServer();
            }
        }
    }

    /* JADX WARNING: Missing block: B:56:0x00f9, code skipped:
            r6 = r7;
     */
    /* JADX WARNING: Missing block: B:57:0x00fb, code skipped:
            if (r4 == false) goto L_0x0105;
     */
    /* JADX WARNING: Missing block: B:59:?, code skipped:
            sendPackageAddedForUser(r13, r6, r15);
     */
    /* JADX WARNING: Missing block: B:60:0x0100, code skipped:
            android.os.Binder.restoreCallingIdentity(r2);
     */
    /* JADX WARNING: Missing block: B:61:0x0104, code skipped:
            return true;
     */
    /* JADX WARNING: Missing block: B:62:0x0105, code skipped:
            if (r5 == false) goto L_0x011a;
     */
    /* JADX WARNING: Missing block: B:64:?, code skipped:
            killApplication(r13, android.os.UserHandle.getUid(r15, r6.appId), "hiding pkg");
            sendApplicationHiddenForUser(r13, r6, r15);
     */
    /* JADX WARNING: Missing block: B:65:0x0115, code skipped:
            android.os.Binder.restoreCallingIdentity(r2);
     */
    /* JADX WARNING: Missing block: B:66:0x0119, code skipped:
            return true;
     */
    /* JADX WARNING: Missing block: B:67:0x011a, code skipped:
            android.os.Binder.restoreCallingIdentity(r2);
     */
    /* JADX WARNING: Missing block: B:68:0x011f, code skipped:
            return false;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean setApplicationHiddenSettingAsUser(String packageName, boolean hidden, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MANAGE_USERS", null);
        int callingUid = Binder.getCallingUid();
        PermissionManagerInternal permissionManagerInternal = this.mPermissionManager;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("setApplicationHiddenSetting for user ");
        stringBuilder.append(userId);
        permissionManagerInternal.enforceCrossUserPermission(callingUid, userId, true, true, stringBuilder.toString());
        if (hidden && isPackageDeviceAdmin(packageName, userId)) {
            String str = TAG;
            StringBuilder stringBuilder2 = new StringBuilder();
            stringBuilder2.append("Not hiding package ");
            stringBuilder2.append(packageName);
            stringBuilder2.append(": has active device admin");
            Slog.w(str, stringBuilder2.toString());
            return false;
        }
        long callingId = Binder.clearCallingIdentity();
        boolean sendAdded = false;
        boolean sendRemoved = false;
        try {
            synchronized (this.mPackages) {
                PackageSetting pkgSetting = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (pkgSetting == null) {
                    Binder.restoreCallingIdentity(callingId);
                    return false;
                } else if (filterAppAccessLPr(pkgSetting, callingUid, userId)) {
                    Binder.restoreCallingIdentity(callingId);
                    return false;
                } else if (PLATFORM_PACKAGE_NAME.equals(packageName)) {
                    Slog.w(TAG, "Cannot hide package: android");
                    Binder.restoreCallingIdentity(callingId);
                    return false;
                } else {
                    Package pkg = (Package) this.mPackages.get(packageName);
                    String str2;
                    StringBuilder stringBuilder3;
                    if (pkg == null || pkg.staticSharedLibName == null) {
                        if (hidden) {
                            if (!UserHandle.isSameApp(callingUid, pkgSetting.appId) && this.mProtectedPackages.isPackageStateProtected(userId, packageName)) {
                                str2 = TAG;
                                stringBuilder3 = new StringBuilder();
                                stringBuilder3.append("Not hiding protected package: ");
                                stringBuilder3.append(packageName);
                                Slog.w(str2, stringBuilder3.toString());
                                Binder.restoreCallingIdentity(callingId);
                                return false;
                            }
                        }
                        if (pkgSetting.getHidden(userId) != hidden) {
                            pkgSetting.setHidden(hidden, userId);
                            this.mSettings.writePackageRestrictionsLPr(userId);
                            if (hidden) {
                                sendRemoved = true;
                            } else {
                                sendAdded = true;
                            }
                        }
                    } else {
                        str2 = TAG;
                        stringBuilder3 = new StringBuilder();
                        stringBuilder3.append("Cannot hide package: ");
                        stringBuilder3.append(packageName);
                        stringBuilder3.append(" providing static shared library: ");
                        stringBuilder3.append(pkg.staticSharedLibName);
                        Slog.w(str2, stringBuilder3.toString());
                        Binder.restoreCallingIdentity(callingId);
                        return false;
                    }
                }
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private void sendApplicationHiddenForUser(String packageName, PackageSetting pkgSetting, int userId) {
        PackageRemovedInfo info = new PackageRemovedInfo(this);
        info.removedPackage = packageName;
        info.installerPackageName = pkgSetting.installerPackageName;
        info.removedUsers = new int[]{userId};
        info.broadcastUsers = new int[]{userId};
        info.uid = UserHandle.getUid(userId, pkgSetting.appId);
        info.sendPackageRemovedBroadcasts(true);
    }

    private void sendPackagesSuspendedForUser(String[] pkgList, int userId, boolean suspended, PersistableBundle launcherExtras) {
        if (pkgList.length > 0) {
            String str;
            Bundle extras = new Bundle(1);
            extras.putStringArray("android.intent.extra.changed_package_list", pkgList);
            if (launcherExtras != null) {
                extras.putBundle("android.intent.extra.LAUNCHER_EXTRAS", new Bundle(launcherExtras.deepCopy()));
            }
            if (suspended) {
                str = "android.intent.action.PACKAGES_SUSPENDED";
            } else {
                str = "android.intent.action.PACKAGES_UNSUSPENDED";
            }
            sendPackageBroadcast(str, null, extras, 1073741824, null, null, new int[]{userId}, null);
        }
    }

    public boolean getApplicationHiddenSettingAsUser(String packageName, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MANAGE_USERS", null);
        int callingUid = Binder.getCallingUid();
        PermissionManagerInternal permissionManagerInternal = this.mPermissionManager;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("getApplicationHidden for user ");
        stringBuilder.append(userId);
        permissionManagerInternal.enforceCrossUserPermission(callingUid, userId, true, false, stringBuilder.toString());
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this.mPackages) {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (ps == null) {
                    Binder.restoreCallingIdentity(callingId);
                    return true;
                } else if (filterAppAccessLPr(ps, callingUid, userId)) {
                    Binder.restoreCallingIdentity(callingId);
                    return true;
                } else {
                    boolean hidden = ps.getHidden(userId);
                    Binder.restoreCallingIdentity(callingId);
                    return hidden;
                }
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public int installExistingPackageAsUser(String packageName, int userId, int installFlags, int installReason) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INSTALL_PACKAGES", null);
        return installExistingPackageAsUserInternal(packageName, userId, installFlags, installReason);
    }

    /* JADX WARNING: Missing block: B:49:0x00bf, code skipped:
            r7 = r0;
     */
    /* JADX WARNING: Missing block: B:50:0x00c0, code skipped:
            if (r5 == false) goto L_0x00e7;
     */
    /* JADX WARNING: Missing block: B:53:0x00c4, code skipped:
            if (r7.pkg == null) goto L_0x00d3;
     */
    /* JADX WARNING: Missing block: B:54:0x00c6, code skipped:
            r13 = r1.mInstallLock;
     */
    /* JADX WARNING: Missing block: B:55:0x00c8, code skipped:
            monitor-enter(r13);
     */
    /* JADX WARNING: Missing block: B:57:?, code skipped:
            prepareAppDataAfterInstallLIF(r7.pkg);
     */
    /* JADX WARNING: Missing block: B:58:0x00ce, code skipped:
            monitor-exit(r13);
     */
    /* JADX WARNING: Missing block: B:64:0x00d3, code skipped:
            sendPackageAddedForUser(r2, r7, r9);
            r13 = r1.mPackages;
     */
    /* JADX WARNING: Missing block: B:65:0x00d8, code skipped:
            monitor-enter(r13);
     */
    /* JADX WARNING: Missing block: B:68:?, code skipped:
            updateSequenceNumberLP(r7, new int[]{r9});
     */
    /* JADX WARNING: Missing block: B:69:0x00e2, code skipped:
            monitor-exit(r13);
     */
    /* JADX WARNING: Missing block: B:75:0x00e7, code skipped:
            android.os.Binder.restoreCallingIdentity(r3);
            r0 = r7;
     */
    /* JADX WARNING: Missing block: B:76:0x00ed, code skipped:
            return 1;
     */
    /* JADX WARNING: Missing block: B:83:0x00f3, code skipped:
            r0 = th;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    protected int installExistingPackageAsUserInternal(String packageName, int userId, int installFlags, int installReason) {
        Throwable th;
        String str = packageName;
        int i = userId;
        int i2 = installFlags;
        int callingUid = Binder.getCallingUid();
        PermissionManagerInternal permissionManagerInternal = this.mPermissionManager;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("installExistingPackage for user ");
        stringBuilder.append(i);
        permissionManagerInternal.enforceCrossUserPermission(callingUid, i, true, true, stringBuilder.toString());
        if (isUserRestricted(i, "no_install_apps")) {
            return -111;
        }
        long callingId = Binder.clearCallingIdentity();
        boolean installed = false;
        boolean instantApp = (i2 & 2048) != 0;
        boolean fullApp = (i2 & 16384) != 0;
        int i3;
        try {
            synchronized (this.mPackages) {
                try {
                    PackageSetting pkgSetting = (PackageSetting) this.mSettings.mPackages.get(str);
                    if (pkgSetting == null) {
                        Binder.restoreCallingIdentity(callingId);
                        return -3;
                    }
                    if (!canViewInstantApps(callingUid, UserHandle.getUserId(callingUid))) {
                        boolean installAllowed = false;
                        for (int instantApp2 : sUserManager.getUserIds()) {
                            installAllowed = pkgSetting.getInstantApp(instantApp2) ^ 1;
                            if (installAllowed) {
                                break;
                            }
                        }
                        if (!installAllowed) {
                            Binder.restoreCallingIdentity(callingId);
                            return -3;
                        }
                    }
                    if (pkgSetting.getInstalled(i)) {
                        i3 = installReason;
                        if (fullApp && pkgSetting.getInstantApp(i)) {
                            installed = true;
                        }
                    } else {
                        pkgSetting.setInstalled(true, i);
                        pkgSetting.setHidden(false, i);
                        try {
                            pkgSetting.setInstallReason(installReason, i);
                            this.mSettings.writePackageRestrictionsLPr(i);
                            this.mSettings.writeKernelMappingLPr(pkgSetting);
                            installed = true;
                        } catch (Throwable th2) {
                            th = th2;
                            throw th;
                        }
                    }
                    setInstantAppForUser(pkgSetting, i, instantApp, fullApp);
                } catch (Throwable th3) {
                    th = th3;
                    i3 = installReason;
                    throw th;
                }
            }
        } catch (Throwable th4) {
            th = th4;
            i3 = installReason;
            Binder.restoreCallingIdentity(callingId);
            throw th;
        }
    }

    static void setInstantAppForUser(PackageSetting pkgSetting, int userId, boolean instantApp, boolean fullApp) {
        if (instantApp || fullApp) {
            if (userId == -1) {
                for (int currentUserId : sUserManager.getUserIds()) {
                    if (instantApp && !pkgSetting.getInstantApp(currentUserId)) {
                        pkgSetting.setInstantApp(true, currentUserId);
                    } else if (fullApp && pkgSetting.getInstantApp(currentUserId)) {
                        pkgSetting.setInstantApp(false, currentUserId);
                    }
                }
            } else if (instantApp && !pkgSetting.getInstantApp(userId)) {
                pkgSetting.setInstantApp(true, userId);
            } else if (fullApp && pkgSetting.getInstantApp(userId)) {
                pkgSetting.setInstantApp(false, userId);
            }
        }
    }

    boolean isUserRestricted(int userId, String restrictionKey) {
        if (!sUserManager.getUserRestrictions(userId).getBoolean(restrictionKey, false)) {
            return false;
        }
        String str = TAG;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("User is restricted: ");
        stringBuilder.append(restrictionKey);
        Log.w(str, stringBuilder.toString());
        return true;
    }

    /* JADX WARNING: Missing block: B:85:0x01c5, code skipped:
            r0 = th;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public String[] setPackagesSuspendedAsUser(String[] packageNames, boolean suspended, PersistableBundle appExtras, PersistableBundle launcherExtras, String dialogMessage, String callingPackage, int userId) {
        Throwable th;
        PersistableBundle persistableBundle;
        long callingId;
        Object obj;
        PersistableBundle persistableBundle2;
        String[] strArr = packageNames;
        long callingId2 = suspended;
        String str = callingPackage;
        int i = userId;
        this.mContext.enforceCallingOrSelfPermission("android.permission.SUSPEND_APPS", "setPackagesSuspendedAsUser");
        int callingUid = Binder.getCallingUid();
        int i2 = 0;
        StringBuilder stringBuilder;
        if (callingUid != 0 && callingUid != 1000 && getPackageUid(str, 0, i) != callingUid) {
            stringBuilder = new StringBuilder();
            stringBuilder.append("Calling package ");
            stringBuilder.append(str);
            stringBuilder.append(" in user ");
            stringBuilder.append(i);
            stringBuilder.append(" does not belong to calling uid ");
            stringBuilder.append(callingUid);
            throw new SecurityException(stringBuilder.toString());
        } else if (!PLATFORM_PACKAGE_NAME.equals(str) && this.mProtectedPackages.getDeviceOwnerOrProfileOwnerPackage(i) != null) {
            stringBuilder = new StringBuilder();
            stringBuilder.append("Cannot suspend/unsuspend packages. User ");
            stringBuilder.append(i);
            stringBuilder.append(" has an active DO or PO");
            throw new UnsupportedOperationException(stringBuilder.toString());
        } else if (ArrayUtils.isEmpty(packageNames)) {
            return strArr;
        } else {
            ArrayList changedPackagesList = new ArrayList(strArr.length);
            ArrayList unactionedPackages = new ArrayList(strArr.length);
            long callingId3 = Binder.clearCallingIdentity();
            try {
                ArrayMap arrayMap = this.mPackages;
                synchronized (arrayMap) {
                    ArrayMap arrayMap2;
                    boolean z;
                    while (i2 < strArr.length) {
                        try {
                            try {
                                String str2;
                                StringBuilder stringBuilder2;
                                String packageName;
                                String packageName2 = strArr[i2];
                                if (str != null) {
                                    try {
                                        if (str.equals(packageName2)) {
                                            str2 = TAG;
                                            stringBuilder2 = new StringBuilder();
                                            stringBuilder2.append("Calling package: ");
                                            stringBuilder2.append(str);
                                            stringBuilder2.append(" trying to ");
                                            stringBuilder2.append(callingId2 != null ? BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS : "un");
                                            stringBuilder2.append("suspend itself. Ignoring");
                                            Slog.w(str2, stringBuilder2.toString());
                                            unactionedPackages.add(packageName2);
                                            arrayMap2 = arrayMap;
                                            callingId2 = callingId3;
                                            i2++;
                                            callingId3 = callingId2;
                                            arrayMap = arrayMap2;
                                            strArr = packageNames;
                                            callingId2 = suspended;
                                            str = callingPackage;
                                        }
                                    } catch (Throwable th2) {
                                        th = th2;
                                        persistableBundle = launcherExtras;
                                        arrayMap2 = arrayMap;
                                        callingId = callingId3;
                                        obj = callingId2;
                                        persistableBundle2 = appExtras;
                                        while (true) {
                                            try {
                                                break;
                                            } catch (Throwable th3) {
                                                th = th3;
                                            }
                                        }
                                        throw th;
                                    }
                                }
                                PackageSetting pkgSetting = (PackageSetting) this.mSettings.mPackages.get(packageName2);
                                PackageSetting packageSetting;
                                if (pkgSetting == null) {
                                    packageSetting = pkgSetting;
                                    packageName = packageName2;
                                    arrayMap2 = arrayMap;
                                    callingId2 = callingId3;
                                } else if (filterAppAccessLPr(pkgSetting, callingUid, i)) {
                                    packageSetting = pkgSetting;
                                    packageName = packageName2;
                                    arrayMap2 = arrayMap;
                                    callingId2 = callingId3;
                                } else {
                                    if (callingId2 != null) {
                                        if (!canSuspendPackageForUserLocked(packageName2, i)) {
                                            unactionedPackages.add(packageName2);
                                            arrayMap2 = arrayMap;
                                            callingId2 = callingId3;
                                            i2++;
                                            callingId3 = callingId2;
                                            arrayMap = arrayMap2;
                                            strArr = packageNames;
                                            callingId2 = suspended;
                                            str = callingPackage;
                                        }
                                    }
                                    boolean z2 = callingId2;
                                    packageName = packageName2;
                                    arrayMap2 = arrayMap;
                                    callingId2 = callingId3;
                                    try {
                                        pkgSetting.setSuspended(z2, str, dialogMessage, appExtras, launcherExtras, i);
                                        changedPackagesList.add(packageName);
                                        i2++;
                                        callingId3 = callingId2;
                                        arrayMap = arrayMap2;
                                        strArr = packageNames;
                                        callingId2 = suspended;
                                        str = callingPackage;
                                    } catch (Throwable th4) {
                                        th = th4;
                                        persistableBundle2 = appExtras;
                                        persistableBundle = launcherExtras;
                                        callingId = callingId2;
                                        z = suspended;
                                        while (true) {
                                            break;
                                        }
                                        throw th;
                                    }
                                }
                                str2 = TAG;
                                stringBuilder2 = new StringBuilder();
                                stringBuilder2.append("Could not find package setting for package: ");
                                stringBuilder2.append(packageName);
                                stringBuilder2.append(". Skipping suspending/un-suspending.");
                                Slog.w(str2, stringBuilder2.toString());
                                unactionedPackages.add(packageName);
                                i2++;
                                callingId3 = callingId2;
                                arrayMap = arrayMap2;
                                strArr = packageNames;
                                callingId2 = suspended;
                                str = callingPackage;
                            } catch (Throwable th5) {
                                th = th5;
                                arrayMap2 = arrayMap;
                                persistableBundle2 = appExtras;
                                persistableBundle = launcherExtras;
                                callingId = callingId3;
                                z = suspended;
                                while (true) {
                                    break;
                                }
                                throw th;
                            }
                        } catch (Throwable th6) {
                            th = th6;
                            persistableBundle = launcherExtras;
                            arrayMap2 = arrayMap;
                            callingId = callingId3;
                            obj = callingId2;
                            persistableBundle2 = appExtras;
                            while (true) {
                                break;
                            }
                            throw th;
                        }
                    }
                    arrayMap2 = arrayMap;
                    callingId2 = callingId3;
                    try {
                        Binder.restoreCallingIdentity(callingId2);
                        if (changedPackagesList.isEmpty()) {
                            persistableBundle2 = appExtras;
                            persistableBundle = launcherExtras;
                            callingId = callingId2;
                            z = suspended;
                        } else {
                            strArr = (String[]) changedPackagesList.toArray(new String[changedPackagesList.size()]);
                            z = suspended;
                            sendPackagesSuspendedForUser(strArr, i, z, launcherExtras);
                            sendMyPackageSuspendedOrUnsuspended(strArr, z, appExtras, i);
                            synchronized (this.mPackages) {
                                scheduleWritePackageRestrictionsLocked(i);
                            }
                        }
                        return (String[]) unactionedPackages.toArray(new String[unactionedPackages.size()]);
                    } catch (Throwable th7) {
                        th = th7;
                        persistableBundle2 = appExtras;
                        persistableBundle = launcherExtras;
                        callingId = callingId2;
                        z = suspended;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                }
            } catch (Throwable th8) {
                th = th8;
                persistableBundle2 = appExtras;
                persistableBundle = launcherExtras;
                callingId = callingId3;
                obj = callingId2;
                Binder.restoreCallingIdentity(callingId);
                throw th;
            }
        }
    }

    public PersistableBundle getSuspendedPackageAppExtras(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        if (getPackageUid(packageName, 0, userId) == callingUid) {
            synchronized (this.mPackages) {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("Unknown target package: ");
                    stringBuilder.append(packageName);
                    throw new IllegalArgumentException(stringBuilder.toString());
                }
                PackageUserState packageUserState = ps.readUserState(userId);
                if (packageUserState.suspended) {
                    PersistableBundle persistableBundle = packageUserState.suspendedAppExtras;
                    return persistableBundle;
                }
                return null;
            }
        }
        StringBuilder stringBuilder2 = new StringBuilder();
        stringBuilder2.append("Calling package ");
        stringBuilder2.append(packageName);
        stringBuilder2.append(" does not belong to calling uid ");
        stringBuilder2.append(callingUid);
        throw new SecurityException(stringBuilder2.toString());
    }

    private void sendMyPackageSuspendedOrUnsuspended(String[] affectedPackages, boolean suspended, PersistableBundle appExtras, int userId) {
        String action;
        Bundle intentExtras = new Bundle();
        if (suspended) {
            action = "android.intent.action.MY_PACKAGE_SUSPENDED";
            if (appExtras != null) {
                intentExtras.putBundle("android.intent.extra.SUSPENDED_PACKAGE_EXTRAS", new Bundle(appExtras.deepCopy()));
            }
        } else {
            action = "android.intent.action.MY_PACKAGE_UNSUSPENDED";
        }
        final String action2 = action;
        final boolean z = suspended;
        final int i = userId;
        final String[] strArr = affectedPackages;
        final Bundle bundle = intentExtras;
        this.mHandler.post(new Runnable() {
            public void run() {
                try {
                    IActivityManager am = ActivityManager.getService();
                    if (am == null) {
                        String str = PackageManagerService.TAG;
                        StringBuilder stringBuilder = new StringBuilder();
                        stringBuilder.append("IActivityManager null. Cannot send MY_PACKAGE_ ");
                        stringBuilder.append(z ? BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS : "UN");
                        stringBuilder.append("SUSPENDED broadcasts");
                        Slog.wtf(str, stringBuilder.toString());
                        return;
                    }
                    int[] targetUserIds = new int[]{i};
                    for (String packageName : strArr) {
                        PackageManagerService.this.doSendBroadcast(am, action2, null, bundle, DumpState.DUMP_SERVICE_PERMISSIONS, packageName, null, targetUserIds, false);
                    }
                } catch (RemoteException e) {
                }
            }
        });
    }

    public boolean isPackageSuspendedForUser(String packageName, int userId) {
        boolean suspended;
        int callingUid = Binder.getCallingUid();
        PermissionManagerInternal permissionManagerInternal = this.mPermissionManager;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("isPackageSuspendedForUser for user ");
        stringBuilder.append(userId);
        permissionManagerInternal.enforceCrossUserPermission(callingUid, userId, true, false, stringBuilder.toString());
        synchronized (this.mPackages) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                StringBuilder stringBuilder2 = new StringBuilder();
                stringBuilder2.append("Unknown target package: ");
                stringBuilder2.append(packageName);
                throw new IllegalArgumentException(stringBuilder2.toString());
            }
            suspended = ps.getSuspended(userId);
        }
        return suspended;
    }

    void unsuspendForSuspendingPackage(String packageName, int affectedUser) {
        int i = 0;
        int[] userIds = affectedUser == -1 ? sUserManager.getUserIds() : new int[]{affectedUser};
        int length = userIds.length;
        while (i < length) {
            int userId = userIds[i];
            Objects.requireNonNull(packageName);
            unsuspendForSuspendingPackages(new -$$Lambda$PackageManagerService$S4BXTl5Ly3EHhXAReFCtlz2B8eo(packageName), userId);
            i++;
        }
    }

    void unsuspendForNonSystemSuspendingPackages(ArraySet<Integer> userIds) {
        int sz = userIds.size();
        for (int i = 0; i < sz; i++) {
            unsuspendForSuspendingPackages(-$$Lambda$PackageManagerService$bnLYyNywBZdr_a6WGQKRTv8z0S4.INSTANCE, ((Integer) userIds.valueAt(i)).intValue());
        }
    }

    private void unsuspendForSuspendingPackages(Predicate<String> packagePredicate, int userId) {
        List<String> affectedPackages = new ArrayList();
        synchronized (this.mPackages) {
            for (PackageSetting ps : this.mSettings.mPackages.values()) {
                PackageUserState pus = ps.readUserState(userId);
                if (pus.suspended && packagePredicate.test(pus.suspendingPackage)) {
                    ps.setSuspended(false, null, null, null, null, userId);
                    affectedPackages.add(ps.name);
                }
            }
        }
        if (!affectedPackages.isEmpty()) {
            String[] packageArray = (String[]) affectedPackages.toArray(new String[affectedPackages.size()]);
            sendMyPackageSuspendedOrUnsuspended(packageArray, false, null, userId);
            sendPackagesSuspendedForUser(packageArray, userId, false, null);
            this.mSettings.writePackageRestrictionsLPr(userId);
        }
    }

    @GuardedBy("mPackages")
    private boolean canSuspendPackageForUserLocked(String packageName, int userId) {
        String str;
        StringBuilder stringBuilder;
        if (isPackageDeviceAdmin(packageName, userId)) {
            String str2 = TAG;
            StringBuilder stringBuilder2 = new StringBuilder();
            stringBuilder2.append("Cannot suspend package \"");
            stringBuilder2.append(packageName);
            stringBuilder2.append("\": has an active device admin");
            Slog.w(str2, stringBuilder2.toString());
            return false;
        } else if (packageName.equals(getActiveLauncherPackageName(userId))) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("Cannot suspend package \"");
            stringBuilder.append(packageName);
            stringBuilder.append("\": contains the active launcher");
            Slog.w(str, stringBuilder.toString());
            return false;
        } else if (packageName.equals(this.mRequiredInstallerPackage)) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("Cannot suspend package \"");
            stringBuilder.append(packageName);
            stringBuilder.append("\": required for package installation");
            Slog.w(str, stringBuilder.toString());
            return false;
        } else if (packageName.equals(this.mRequiredUninstallerPackage)) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("Cannot suspend package \"");
            stringBuilder.append(packageName);
            stringBuilder.append("\": required for package uninstallation");
            Slog.w(str, stringBuilder.toString());
            return false;
        } else if (packageName.equals(this.mRequiredVerifierPackage)) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("Cannot suspend package \"");
            stringBuilder.append(packageName);
            stringBuilder.append("\": required for package verification");
            Slog.w(str, stringBuilder.toString());
            return false;
        } else if (packageName.equals(getDefaultDialerPackageName(userId))) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("Cannot suspend package \"");
            stringBuilder.append(packageName);
            stringBuilder.append("\": is the default dialer");
            Slog.w(str, stringBuilder.toString());
            return false;
        } else if (this.mProtectedPackages.isPackageStateProtected(userId, packageName)) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("Cannot suspend package \"");
            stringBuilder.append(packageName);
            stringBuilder.append("\": protected package");
            Slog.w(str, stringBuilder.toString());
            return false;
        } else {
            Package pkg = (Package) this.mPackages.get(packageName);
            String str3;
            StringBuilder stringBuilder3;
            if (pkg != null && pkg.applicationInfo.isStaticSharedLibrary()) {
                str3 = TAG;
                stringBuilder3 = new StringBuilder();
                stringBuilder3.append("Cannot suspend package: ");
                stringBuilder3.append(packageName);
                stringBuilder3.append(" providing static shared library: ");
                stringBuilder3.append(pkg.staticSharedLibName);
                Slog.w(str3, stringBuilder3.toString());
                return false;
            } else if (!PLATFORM_PACKAGE_NAME.equals(packageName)) {
                return true;
            } else {
                str3 = TAG;
                stringBuilder3 = new StringBuilder();
                stringBuilder3.append("Cannot suspend package: ");
                stringBuilder3.append(packageName);
                Slog.w(str3, stringBuilder3.toString());
                return false;
            }
        }
    }

    private String getActiveLauncherPackageName(int userId) {
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory("android.intent.category.HOME");
        ResolveInfo resolveInfo = resolveIntent(intent, intent.resolveTypeIfNeeded(this.mContext.getContentResolver()), 65536, userId);
        return resolveInfo == null ? null : resolveInfo.activityInfo.packageName;
    }

    private String getDefaultDialerPackageName(int userId) {
        String defaultDialerPackageNameLPw;
        synchronized (this.mPackages) {
            defaultDialerPackageNameLPw = this.mSettings.getDefaultDialerPackageNameLPw(userId);
        }
        return defaultDialerPackageNameLPw;
    }

    public void verifyPendingInstall(int id, int verificationCode) throws RemoteException {
        this.mContext.enforceCallingOrSelfPermission("android.permission.PACKAGE_VERIFICATION_AGENT", "Only package verification agents can verify applications");
        Message msg = this.mHandler.obtainMessage(15);
        PackageVerificationResponse response = new PackageVerificationResponse(verificationCode, Binder.getCallingUid());
        msg.arg1 = id;
        msg.obj = response;
        this.mHandler.sendMessage(msg);
    }

    public void extendVerificationTimeout(int id, int verificationCodeAtTimeout, long millisecondsToDelay) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.PACKAGE_VERIFICATION_AGENT", "Only package verification agents can extend verification timeouts");
        PackageVerificationState state = (PackageVerificationState) this.mPendingVerification.get(id);
        PackageVerificationResponse response = new PackageVerificationResponse(verificationCodeAtTimeout, Binder.getCallingUid());
        if (millisecondsToDelay > SettingsObserver.DEFAULT_STRONG_USAGE_TIMEOUT) {
            millisecondsToDelay = SettingsObserver.DEFAULT_STRONG_USAGE_TIMEOUT;
        }
        if (millisecondsToDelay < 0) {
            millisecondsToDelay = 0;
        }
        if (!(verificationCodeAtTimeout == 1 || verificationCodeAtTimeout == -1)) {
        }
        if (state != null && !state.timeoutExtended()) {
            state.extendTimeout();
            Message msg = this.mHandler.obtainMessage(15);
            msg.arg1 = id;
            msg.obj = response;
            this.mHandler.sendMessageDelayed(msg, millisecondsToDelay);
        }
    }

    private void broadcastPackageVerified(int verificationId, Uri packageUri, int verificationCode, UserHandle user) {
        Intent intent = new Intent("android.intent.action.PACKAGE_VERIFIED");
        intent.setDataAndType(packageUri, PACKAGE_MIME_TYPE);
        intent.addFlags(1);
        intent.putExtra("android.content.pm.extra.VERIFICATION_ID", verificationId);
        intent.putExtra("android.content.pm.extra.VERIFICATION_RESULT", verificationCode);
        this.mContext.sendBroadcastAsUser(intent, user, "android.permission.PACKAGE_VERIFICATION_AGENT");
    }

    private ComponentName matchComponentForVerifier(String packageName, List<ResolveInfo> receivers) {
        ActivityInfo targetReceiver = null;
        int NR = receivers.size();
        for (int i = 0; i < NR; i++) {
            ResolveInfo info = (ResolveInfo) receivers.get(i);
            if (info.activityInfo != null && packageName.equals(info.activityInfo.packageName)) {
                targetReceiver = info.activityInfo;
                break;
            }
        }
        if (targetReceiver == null) {
            return null;
        }
        return new ComponentName(targetReceiver.packageName, targetReceiver.name);
    }

    private List<ComponentName> matchVerifiers(PackageInfoLite pkgInfo, List<ResolveInfo> receivers, PackageVerificationState verificationState) {
        if (pkgInfo.verifiers.length == 0) {
            return null;
        }
        List<ComponentName> sufficientVerifiers = new ArrayList(N + 1);
        for (VerifierInfo verifierInfo : pkgInfo.verifiers) {
            ComponentName comp = matchComponentForVerifier(verifierInfo.packageName, receivers);
            if (comp != null) {
                int verifierUid = getUidForVerifier(verifierInfo);
                if (verifierUid != -1) {
                    if (DEBUG_VERIFY) {
                        String str = TAG;
                        StringBuilder stringBuilder = new StringBuilder();
                        stringBuilder.append("Added sufficient verifier ");
                        stringBuilder.append(verifierInfo.packageName);
                        stringBuilder.append(" with the correct signature");
                        Slog.d(str, stringBuilder.toString());
                    }
                    sufficientVerifiers.add(comp);
                    verificationState.addSufficientVerifier(verifierUid);
                }
            }
        }
        return sufficientVerifiers;
    }

    private int getUidForVerifier(VerifierInfo verifierInfo) {
        synchronized (this.mPackages) {
            Package pkg = (Package) this.mPackages.get(verifierInfo.packageName);
            if (pkg == null) {
                return -1;
            } else if (pkg.mSigningDetails.signatures.length != 1) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Verifier package ");
                stringBuilder.append(verifierInfo.packageName);
                stringBuilder.append(" has more than one signature; ignoring");
                Slog.i(str, stringBuilder.toString());
                return -1;
            } else {
                try {
                    if (Arrays.equals(verifierInfo.publicKey.getEncoded(), pkg.mSigningDetails.signatures[0].getPublicKey().getEncoded())) {
                        int i = pkg.applicationInfo.uid;
                        return i;
                    }
                    String str2 = TAG;
                    StringBuilder stringBuilder2 = new StringBuilder();
                    stringBuilder2.append("Verifier package ");
                    stringBuilder2.append(verifierInfo.packageName);
                    stringBuilder2.append(" does not have the expected public key; ignoring");
                    Slog.i(str2, stringBuilder2.toString());
                    return -1;
                } catch (CertificateException e) {
                    return -1;
                }
            }
        }
    }

    public void finishPackageInstall(int token, boolean didLaunch) {
        enforceSystemOrRoot("Only the system is allowed to finish installs");
        if (DEBUG_INSTALL) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("BM finishing package install for ");
            stringBuilder.append(token);
            Slog.v(str, stringBuilder.toString());
        }
        Trace.asyncTraceEnd(262144, "restore", token);
        this.mHandler.sendMessage(this.mHandler.obtainMessage(9, token, didLaunch));
    }

    private long getVerificationTimeout() {
        return Global.getLong(this.mContext.getContentResolver(), "verifier_timeout", 10000);
    }

    private int getDefaultVerificationResponse(UserHandle user) {
        if (sUserManager.hasUserRestriction("ensure_verify_apps", user.getIdentifier())) {
            return -1;
        }
        return Global.getInt(this.mContext.getContentResolver(), "verifier_default_response", 1);
    }

    private boolean isVerificationEnabled(int userId, int installFlags, int installerUid) {
        boolean ensureVerifyAppsEnabled = isUserRestricted(userId, "ensure_verify_apps");
        boolean z = false;
        if ((installFlags & 32) != 0) {
            if (ActivityManager.isRunningInTestHarness()) {
                return false;
            }
            if (ensureVerifyAppsEnabled) {
                return true;
            }
            if (Global.getInt(this.mContext.getContentResolver(), "verifier_verify_adb_installs", 1) == 0) {
                return false;
            }
        } else if (!((installFlags & 2048) == 0 || this.mInstantAppInstallerActivity == null || !this.mInstantAppInstallerActivity.packageName.equals(this.mRequiredVerifierPackage))) {
            try {
                ((AppOpsManager) this.mContext.getSystemService(AppOpsManager.class)).checkPackage(installerUid, this.mRequiredVerifierPackage);
                if (DEBUG_VERIFY) {
                    Slog.i(TAG, "disable verification for instant app");
                }
                return false;
            } catch (SecurityException e) {
            }
        }
        if (ensureVerifyAppsEnabled) {
            return true;
        }
        if (Global.getInt(this.mContext.getContentResolver(), "package_verifier_enable", 1) == 1) {
            z = true;
        }
        return z;
    }

    public void verifyIntentFilter(int id, int verificationCode, List<String> failedDomains) throws RemoteException {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTENT_FILTER_VERIFICATION_AGENT", "Only intentfilter verification agents can verify applications");
        Message msg = this.mHandler.obtainMessage(18);
        IntentFilterVerificationResponse response = new IntentFilterVerificationResponse(Binder.getCallingUid(), verificationCode, failedDomains);
        msg.arg1 = id;
        msg.obj = response;
        this.mHandler.sendMessage(msg);
    }

    /* JADX WARNING: Missing block: B:18:0x004d, code skipped:
            return 0;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public int getIntentVerificationStatus(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        if (UserHandle.getUserId(callingUid) != userId) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("getIntentVerificationStatus");
            stringBuilder.append(userId);
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", stringBuilder.toString());
        }
        if (getInstantAppPackageName(callingUid) != null) {
            return 0;
        }
        synchronized (this.mPackages) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (ps != null) {
                if (!filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    int intentFilterVerificationStatusLPr = this.mSettings.getIntentFilterVerificationStatusLPr(packageName, userId);
                    return intentFilterVerificationStatusLPr;
                }
            }
        }
    }

    /* JADX WARNING: Missing block: B:10:0x002f, code skipped:
            if (r0 == false) goto L_0x0034;
     */
    /* JADX WARNING: Missing block: B:11:0x0031, code skipped:
            scheduleWritePackageRestrictionsLocked(r8);
     */
    /* JADX WARNING: Missing block: B:12:0x0034, code skipped:
            return r0;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean updateIntentVerificationStatus(String packageName, int status, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        synchronized (this.mPackages) {
            if (filterAppAccessLPr((PackageSetting) this.mSettings.mPackages.get(packageName), Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                return false;
            }
            boolean result = this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, status, userId);
        }
    }

    public ParceledListSlice<IntentFilterVerificationInfo> getIntentFilterVerifications(String packageName) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return ParceledListSlice.emptyList();
        }
        synchronized (this.mPackages) {
            ParceledListSlice emptyList;
            if (filterAppAccessLPr((PackageSetting) this.mSettings.mPackages.get(packageName), callingUid, UserHandle.getUserId(callingUid))) {
                emptyList = ParceledListSlice.emptyList();
                return emptyList;
            }
            emptyList = new ParceledListSlice(this.mSettings.getIntentFilterVerificationsLPr(packageName));
            return emptyList;
        }
    }

    public ParceledListSlice<IntentFilter> getAllIntentFilters(String packageName) {
        if (TextUtils.isEmpty(packageName)) {
            return ParceledListSlice.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        synchronized (this.mPackages) {
            ParceledListSlice emptyList;
            Package pkg = (Package) this.mPackages.get(packageName);
            if (pkg != null) {
                if (pkg.activities != null) {
                    if (pkg.mExtras == null) {
                        emptyList = ParceledListSlice.emptyList();
                        return emptyList;
                    } else if (filterAppAccessLPr(pkg.mExtras, callingUid, callingUserId)) {
                        ParceledListSlice emptyList2 = ParceledListSlice.emptyList();
                        return emptyList2;
                    } else {
                        int count = pkg.activities.size();
                        ArrayList<IntentFilter> result = new ArrayList();
                        for (int n = 0; n < count; n++) {
                            Activity activity = (Activity) pkg.activities.get(n);
                            if (activity.intents != null && activity.intents.size() > 0) {
                                result.addAll(activity.intents);
                            }
                        }
                        ParceledListSlice parceledListSlice = new ParceledListSlice(result);
                        return parceledListSlice;
                    }
                }
            }
            emptyList = ParceledListSlice.emptyList();
            return emptyList;
        }
    }

    public boolean setDefaultBrowserPackageName(String packageName, int userId) {
        boolean result;
        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        if (UserHandle.getCallingUserId() != userId) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        }
        synchronized (this.mPackages) {
            result = this.mSettings.setDefaultBrowserPackageNameLPw(packageName, userId);
            if (packageName != null) {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultBrowser(packageName, userId);
            }
        }
        return result;
    }

    public String getDefaultBrowserPackageName(int userId) {
        if (UserHandle.getCallingUserId() != userId) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        }
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        String defaultBrowserPackageNameLPw;
        synchronized (this.mPackages) {
            defaultBrowserPackageNameLPw = this.mSettings.getDefaultBrowserPackageNameLPw(userId);
        }
        return defaultBrowserPackageNameLPw;
    }

    private int getUnknownSourcesSettings() {
        return Secure.getInt(this.mContext.getContentResolver(), "install_non_market_apps", -1);
    }

    public void setInstallerPackageName(String targetPackage, String installerPackageName) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null) {
            synchronized (this.mPackages) {
                PackageSetting targetPackageSetting = (PackageSetting) this.mSettings.mPackages.get(targetPackage);
                if (targetPackageSetting == null || filterAppAccessLPr(targetPackageSetting, callingUid, UserHandle.getUserId(callingUid))) {
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("Unknown target package: ");
                    stringBuilder.append(targetPackage);
                    throw new IllegalArgumentException(stringBuilder.toString());
                }
                PackageSetting installerPackageSetting;
                if (installerPackageName != null) {
                    installerPackageSetting = (PackageSetting) this.mSettings.mPackages.get(installerPackageName);
                    if (installerPackageSetting == null) {
                        StringBuilder stringBuilder2 = new StringBuilder();
                        stringBuilder2.append("Unknown installer package: ");
                        stringBuilder2.append(installerPackageName);
                        throw new IllegalArgumentException(stringBuilder2.toString());
                    }
                } else {
                    installerPackageSetting = null;
                }
                Object obj = this.mSettings.getUserIdLPr(callingUid);
                StringBuilder stringBuilder3;
                if (obj != null) {
                    Signature[] callerSignature;
                    if (obj instanceof SharedUserSetting) {
                        callerSignature = ((SharedUserSetting) obj).signatures.mSigningDetails.signatures;
                    } else if (obj instanceof PackageSetting) {
                        callerSignature = ((PackageSetting) obj).signatures.mSigningDetails.signatures;
                    } else {
                        stringBuilder3 = new StringBuilder();
                        stringBuilder3.append("Bad object ");
                        stringBuilder3.append(obj);
                        stringBuilder3.append(" for uid ");
                        stringBuilder3.append(callingUid);
                        throw new SecurityException(stringBuilder3.toString());
                    }
                    if (installerPackageSetting != null) {
                        if (PackageManagerServiceUtils.compareSignatures(callerSignature, installerPackageSetting.signatures.mSigningDetails.signatures) != 0) {
                            StringBuilder stringBuilder4 = new StringBuilder();
                            stringBuilder4.append("Caller does not have same cert as new installer package ");
                            stringBuilder4.append(installerPackageName);
                            throw new SecurityException(stringBuilder4.toString());
                        }
                    }
                    if (targetPackageSetting.installerPackageName != null) {
                        PackageSetting setting = (PackageSetting) this.mSettings.mPackages.get(targetPackageSetting.installerPackageName);
                        if (setting != null) {
                            if (PackageManagerServiceUtils.compareSignatures(callerSignature, setting.signatures.mSigningDetails.signatures) != 0) {
                                StringBuilder stringBuilder5 = new StringBuilder();
                                stringBuilder5.append("Caller does not have same cert as old installer package ");
                                stringBuilder5.append(targetPackageSetting.installerPackageName);
                                throw new SecurityException(stringBuilder5.toString());
                            }
                        }
                    }
                    targetPackageSetting.installerPackageName = installerPackageName;
                    if (installerPackageName != null) {
                        this.mSettings.mInstallerPackages.add(installerPackageName);
                    }
                    scheduleWriteSettingsLocked();
                } else {
                    stringBuilder3 = new StringBuilder();
                    stringBuilder3.append("Unknown calling UID: ");
                    stringBuilder3.append(callingUid);
                    throw new SecurityException(stringBuilder3.toString());
                }
            }
        }
    }

    public void setApplicationCategoryHint(String packageName, int categoryHint, String callerPackageName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            ((AppOpsManager) this.mContext.getSystemService(AppOpsManager.class)).checkPackage(Binder.getCallingUid(), callerPackageName);
            synchronized (this.mPackages) {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                StringBuilder stringBuilder;
                if (ps == null) {
                    stringBuilder = new StringBuilder();
                    stringBuilder.append("Unknown target package ");
                    stringBuilder.append(packageName);
                    throw new IllegalArgumentException(stringBuilder.toString());
                } else if (filterAppAccessLPr(ps, Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                    stringBuilder = new StringBuilder();
                    stringBuilder.append("Unknown target package ");
                    stringBuilder.append(packageName);
                    throw new IllegalArgumentException(stringBuilder.toString());
                } else if (Objects.equals(callerPackageName, ps.installerPackageName)) {
                    if (ps.categoryHint != categoryHint) {
                        ps.categoryHint = categoryHint;
                        scheduleWriteSettingsLocked();
                    }
                } else {
                    stringBuilder = new StringBuilder();
                    stringBuilder.append("Calling package ");
                    stringBuilder.append(callerPackageName);
                    stringBuilder.append(" is not installer for ");
                    stringBuilder.append(packageName);
                    throw new IllegalArgumentException(stringBuilder.toString());
                }
            }
            return;
        }
        throw new SecurityException("Instant applications don't have access to this method");
    }

    private void processPendingInstall(final InstallArgs args, final int currentStatus) {
        this.mHandler.post(new Runnable() {
            public void run() {
                String str;
                PackageManagerService.this.mHandler.removeCallbacks(this);
                PackageInstalledInfo res = new PackageInstalledInfo();
                res.setReturnCode(currentStatus);
                res.uid = -1;
                res.pkg = null;
                res.removedInfo = null;
                if (res.returnCode == 1) {
                    args.doPreInstall(res.returnCode);
                    synchronized (PackageManagerService.this.mInstallLock) {
                        PackageManagerService.this.installPackageTracedLI(args, res);
                        Package pkg = res.pkg;
                        String pkgName = null;
                        if (pkg != null) {
                            pkgName = pkg.packageName;
                        }
                        if (pkgName != null) {
                            InstallerMgr.getInstance().installPackage(1, args.installerPackageName, pkgName);
                        }
                    }
                    args.doPostInstall(res.returnCode, res.uid);
                }
                boolean update = (res.removedInfo == null || res.removedInfo.removedPackage == null) ? false : true;
                boolean doRestore = (update || (32768 & (res.pkg == null ? 0 : res.pkg.applicationInfo.flags)) == 0) ? false : true;
                if (PackageManagerService.this.mNextInstallToken < 0) {
                    PackageManagerService.this.mNextInstallToken = 1;
                }
                PackageManagerService packageManagerService = PackageManagerService.this;
                int i = packageManagerService.mNextInstallToken;
                packageManagerService.mNextInstallToken = i + 1;
                int token = i;
                PackageManagerService.this.mRunningInstalls.put(token, new PostInstallData(args, res));
                if (PackageManagerService.DEBUG_INSTALL) {
                    str = PackageManagerService.TAG;
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("+ starting restore round-trip ");
                    stringBuilder.append(token);
                    Log.v(str, stringBuilder.toString());
                }
                if (res.returnCode == 1 && doRestore) {
                    IBackupManager bm = IBackupManager.Stub.asInterface(ServiceManager.getService(HealthServiceWrapper.INSTANCE_HEALTHD));
                    if (bm != null) {
                        if (PackageManagerService.DEBUG_INSTALL) {
                            str = PackageManagerService.TAG;
                            StringBuilder stringBuilder2 = new StringBuilder();
                            stringBuilder2.append("token ");
                            stringBuilder2.append(token);
                            stringBuilder2.append(" to BM for possible restore");
                            Log.v(str, stringBuilder2.toString());
                        }
                        Trace.asyncTraceBegin(262144, "restore", token);
                        try {
                            if (bm.isBackupServiceActive(0)) {
                                bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);
                            } else {
                                doRestore = false;
                            }
                        } catch (RemoteException e) {
                        } catch (Exception e2) {
                            Slog.e(PackageManagerService.TAG, "Exception trying to enqueue restore", e2);
                            doRestore = false;
                        }
                    } else {
                        Slog.e(PackageManagerService.TAG, "Backup Manager not found!");
                        doRestore = false;
                    }
                }
                if (!doRestore) {
                    if (PackageManagerService.DEBUG_INSTALL) {
                        String str2 = PackageManagerService.TAG;
                        StringBuilder stringBuilder3 = new StringBuilder();
                        stringBuilder3.append("No restore - queue post-install for ");
                        stringBuilder3.append(token);
                        Log.v(str2, stringBuilder3.toString());
                    }
                    Trace.asyncTraceBegin(262144, "postInstall", token);
                    PackageManagerService.this.mHandler.sendMessage(PackageManagerService.this.mHandler.obtainMessage(9, token, 0));
                }
            }
        });
    }

    void notifyFirstLaunch(final String packageName, final String installerPackage, final int userId) {
        this.mHandler.post(new Runnable() {
            public void run() {
                for (int i = 0; i < PackageManagerService.this.mRunningInstalls.size(); i++) {
                    PostInstallData data = (PostInstallData) PackageManagerService.this.mRunningInstalls.valueAt(i);
                    if (data.res.returnCode == 1 && packageName.equals(data.res.pkg.applicationInfo.packageName)) {
                        for (int i2 : data.res.newUsers) {
                            if (userId == i2) {
                                if (PackageManagerService.DEBUG_BACKUP) {
                                    String str = PackageManagerService.TAG;
                                    StringBuilder stringBuilder = new StringBuilder();
                                    stringBuilder.append("Package ");
                                    stringBuilder.append(packageName);
                                    stringBuilder.append(" being restored so deferring FIRST_LAUNCH");
                                    Slog.i(str, stringBuilder.toString());
                                }
                                return;
                            }
                        }
                        continue;
                    }
                }
                if (PackageManagerService.DEBUG_BACKUP) {
                    String str2 = PackageManagerService.TAG;
                    StringBuilder stringBuilder2 = new StringBuilder();
                    stringBuilder2.append("Package ");
                    stringBuilder2.append(packageName);
                    stringBuilder2.append(" sending normal FIRST_LAUNCH");
                    Slog.i(str2, stringBuilder2.toString());
                }
                boolean isInstantApp = PackageManagerService.this.isInstantApp(packageName, userId);
                PackageManagerService.this.sendFirstLaunchBroadcast(packageName, installerPackage, isInstantApp ? PackageManagerService.EMPTY_INT_ARRAY : new int[]{userId}, isInstantApp ? new int[]{userId} : PackageManagerService.EMPTY_INT_ARRAY);
            }
        });
    }

    private void sendFirstLaunchBroadcast(String pkgName, String installerPkg, int[] userIds, int[] instantUserIds) {
        sendPackageBroadcast("android.intent.action.PACKAGE_FIRST_LAUNCH", pkgName, null, 0, installerPkg, null, userIds, instantUserIds);
    }

    private static void clearDirectory(IMediaContainerService mcs, File[] paths) {
        for (File path : paths) {
            try {
                mcs.clearDirectory(path.getAbsolutePath());
            } catch (RemoteException e) {
            }
        }
    }

    private InstallArgs createInstallArgs(InstallParams params) {
        if (params.move != null) {
            return new MoveInstallArgs(this, params);
        }
        return new FileInstallArgs(this, params);
    }

    private InstallArgs createInstallArgsForExisting(int installFlags, String codePath, String resourcePath, String[] instructionSets) {
        return new FileInstallArgs(this, codePath, resourcePath, instructionSets);
    }

    void removeDexFiles(List<String> allCodePaths, String[] instructionSets) {
        if (!allCodePaths.isEmpty()) {
            if (instructionSets != null) {
                String[] dexCodeInstructionSets = InstructionSets.getDexCodeInstructionSets(instructionSets);
                for (String codePath : allCodePaths) {
                    for (String dexCodeInstructionSet : dexCodeInstructionSets) {
                        try {
                            this.mInstaller.rmdex(codePath, dexCodeInstructionSet);
                        } catch (InstallerException e) {
                        }
                    }
                }
                return;
            }
            throw new IllegalStateException("instructionSet == null");
        }
    }

    private static void maybeThrowExceptionForMultiArchCopy(String message, int copyRet) throws PackageManagerException {
        if (copyRet < 0 && copyRet != -114 && copyRet != -113) {
            throw new PackageManagerException(copyRet, message);
        }
    }

    static String cidFromCodePath(String fullCodePath) {
        int eidx = fullCodePath.lastIndexOf(SliceAuthority.DELIMITER);
        String subStr1 = fullCodePath.substring(null, eidx);
        return subStr1.substring(subStr1.lastIndexOf(SliceAuthority.DELIMITER) + 1, eidx);
    }

    static String getAsecPackageName(String packageCid) {
        int idx = packageCid.lastIndexOf(INSTALL_PACKAGE_SUFFIX);
        if (idx == -1) {
            return packageCid;
        }
        return packageCid.substring(0, idx);
    }

    private static String getNextCodePath(String oldCodePath, String prefix, String suffix) {
        String idxStr = BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS;
        int idx = 1;
        if (oldCodePath != null) {
            String subStr = oldCodePath;
            if (suffix != null && subStr.endsWith(suffix)) {
                subStr = subStr.substring(0, subStr.length() - suffix.length());
            }
            int sidx = subStr.lastIndexOf(prefix);
            if (sidx != -1) {
                subStr = subStr.substring(prefix.length() + sidx);
                if (subStr != null) {
                    if (subStr.startsWith(INSTALL_PACKAGE_SUFFIX)) {
                        subStr = subStr.substring(INSTALL_PACKAGE_SUFFIX.length());
                    }
                    try {
                        idx = Integer.parseInt(subStr);
                        idx = idx <= 1 ? idx + 1 : idx - 1;
                    } catch (NumberFormatException e) {
                    }
                }
            }
        }
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(INSTALL_PACKAGE_SUFFIX);
        stringBuilder.append(Integer.toString(idx));
        idxStr = stringBuilder.toString();
        stringBuilder = new StringBuilder();
        stringBuilder.append(prefix);
        stringBuilder.append(idxStr);
        return stringBuilder.toString();
    }

    private File getNextCodePath(File targetDir, String packageName) {
        File result;
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[16];
        do {
            random.nextBytes(bytes);
            String suffix = Base64.encodeToString(bytes, 10);
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(packageName);
            stringBuilder.append(INSTALL_PACKAGE_SUFFIX);
            stringBuilder.append(suffix);
            result = new File(targetDir, stringBuilder.toString());
        } while (result.exists());
        return result;
    }

    static String deriveCodePathName(String codePath) {
        if (codePath == null) {
            return null;
        }
        File codeFile = new File(codePath);
        String name = codeFile.getName();
        if (codeFile.isDirectory()) {
            return name;
        }
        if (name.endsWith(".apk") || name.endsWith(".tmp")) {
            return name.substring(0, name.lastIndexOf(46));
        }
        String str = TAG;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("Odd, ");
        stringBuilder.append(codePath);
        stringBuilder.append(" doesn't look like an APK");
        Slog.w(str, stringBuilder.toString());
        return null;
    }

    /* JADX WARNING: Missing block: B:15:?, code skipped:
            r0 = scanPackageTracedLI(r11, r18, r19, java.lang.System.currentTimeMillis(), r20);
            updateSettingsLI(r0, r21, null, r12, r20, r24);
     */
    /* JADX WARNING: Missing block: B:16:0x0095, code skipped:
            if (r12.returnCode != 1) goto L_0x009b;
     */
    /* JADX WARNING: Missing block: B:17:0x0097, code skipped:
            prepareAppDataAfterInstallLIF(r0);
     */
    /* JADX WARNING: Missing block: B:18:0x009b, code skipped:
            r1 = new java.lang.StringBuilder();
            r1.append("updateSettingsLI failed: ");
            r1.append(r12.returnCode);
            r1.append(", delete pkg: ");
            r1.append(r15);
            android.util.Flog.i(207, r1.toString());
            deletePackageLIF(r15, android.os.UserHandle.ALL, false, null, 1, r12.removedInfo, true, null);
     */
    /* JADX WARNING: Missing block: B:19:0x00c9, code skipped:
            r0 = move-exception;
     */
    /* JADX WARNING: Missing block: B:20:0x00ca, code skipped:
            r1 = new java.lang.StringBuilder();
            r1.append("Package couldn't be installed in ");
            r1.append(r11.codePath);
            r12.setError(r1.toString(), r0);
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void installNewPackageLIF(Package pkg, int parseFlags, int scanFlags, UserHandle user, String installerPackageName, String volumeUuid, PackageInstalledInfo res, int installReason) {
        Package packageR = pkg;
        PackageInstalledInfo packageInstalledInfo = res;
        Trace.traceBegin(262144, "installNewPackage");
        String pkgName = packageR.packageName;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("installNewPackageLI: ");
        stringBuilder.append(packageR);
        Flog.i(207, stringBuilder.toString());
        synchronized (this.mPackages) {
            String renamedPackage = this.mSettings.getRenamedPackageLPr(pkgName);
            StringBuilder stringBuilder2;
            if (renamedPackage != null) {
                stringBuilder2 = new StringBuilder();
                stringBuilder2.append("Attempt to re-install ");
                stringBuilder2.append(pkgName);
                stringBuilder2.append(" without first uninstalling package running as ");
                stringBuilder2.append(renamedPackage);
                packageInstalledInfo.setError(-1, stringBuilder2.toString());
                return;
            } else if (this.mPackages.containsKey(pkgName)) {
                stringBuilder2 = new StringBuilder();
                stringBuilder2.append("Attempt to re-install ");
                stringBuilder2.append(pkgName);
                stringBuilder2.append(" without first uninstalling.");
                packageInstalledInfo.setError(-1, stringBuilder2.toString());
                return;
            }
        }
        Trace.traceEnd(262144);
    }

    /* JADX WARNING: Missing block: B:13:0x001b, code skipped:
            $closeResource(r1, r0);
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private static void updateDigest(MessageDigest digest, File file) throws IOException {
        DigestInputStream digestStream = new DigestInputStream(new FileInputStream(file), digest);
        while (digestStream.read() != -1) {
        }
        $closeResource(null, digestStream);
    }

    /* JADX WARNING: Removed duplicated region for block: B:94:0x01b9 A:{SYNTHETIC, Splitter:B:94:0x01b9} */
    /* JADX WARNING: Removed duplicated region for block: B:89:0x0198  */
    /* JADX WARNING: Exception block dominator not found, dom blocks: [B:20:0x005f, B:64:0x0129] */
    /* JADX WARNING: Missing block: B:24:0x006b, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:25:0x006c, code skipped:
            r27 = r10;
     */
    /* JADX WARNING: Missing block: B:139:0x028c, code skipped:
            r8 = r4;
            r6 = r0;
            r14.removedInfo = new com.android.server.pm.PackageManagerService.PackageRemovedInfo(r11);
            r14.removedInfo.uid = r8.applicationInfo.uid;
            r14.removedInfo.removedPackage = r8.packageName;
            r14.removedInfo.installerPackageName = r7.installerPackageName;
            r0 = r14.removedInfo;
     */
    /* JADX WARNING: Missing block: B:140:0x02ad, code skipped:
            if (r12.staticSharedLibName == null) goto L_0x02b1;
     */
    /* JADX WARNING: Missing block: B:141:0x02af, code skipped:
            r1 = true;
     */
    /* JADX WARNING: Missing block: B:142:0x02b1, code skipped:
            r1 = false;
     */
    /* JADX WARNING: Missing block: B:143:0x02b2, code skipped:
            r0.isStaticSharedLib = r1;
            r14.removedInfo.isUpdate = true;
            r14.removedInfo.origUsers = r5;
            r14.removedInfo.installReasons = new android.util.SparseArray(r5.length);
            r0 = 0;
     */
    /* JADX WARNING: Missing block: B:145:0x02c9, code skipped:
            if (r0 >= r5.length) goto L_0x02df;
     */
    /* JADX WARNING: Missing block: B:146:0x02cb, code skipped:
            r1 = r5[r0];
            r14.removedInfo.installReasons.put(r1, java.lang.Integer.valueOf(r7.getInstallReason(r1)));
            r0 = r0 + 1;
     */
    /* JADX WARNING: Missing block: B:148:0x02e1, code skipped:
            if (r8.childPackages == null) goto L_0x02ea;
     */
    /* JADX WARNING: Missing block: B:149:0x02e3, code skipped:
            r1 = r8.childPackages.size();
     */
    /* JADX WARNING: Missing block: B:150:0x02ea, code skipped:
            r1 = 0;
     */
    /* JADX WARNING: Missing block: B:151:0x02eb, code skipped:
            r3 = r1;
            r0 = 0;
     */
    /* JADX WARNING: Missing block: B:152:0x02ed, code skipped:
            r1 = r0;
     */
    /* JADX WARNING: Missing block: B:153:0x02ee, code skipped:
            if (r1 >= r3) goto L_0x039b;
     */
    /* JADX WARNING: Missing block: B:154:0x02f0, code skipped:
            r2 = (android.content.pm.PackageParser.Package) r8.childPackages.get(r1);
            r32 = false;
            r4 = r11.mSettings.getPackageLPr(r2.packageName);
     */
    /* JADX WARNING: Missing block: B:155:0x0305, code skipped:
            if (r14.addedChildPackages == null) goto L_0x0341;
     */
    /* JADX WARNING: Missing block: B:156:0x0307, code skipped:
            r33 = r3;
            r0 = (com.android.server.pm.PackageManagerService.PackageInstalledInfo) r14.addedChildPackages.get(r2.packageName);
     */
    /* JADX WARNING: Missing block: B:157:0x0313, code skipped:
            if (r0 == null) goto L_0x033e;
     */
    /* JADX WARNING: Missing block: B:158:0x0315, code skipped:
            r34 = r5;
            r0.removedInfo.uid = r2.applicationInfo.uid;
            r0.removedInfo.removedPackage = r2.packageName;
     */
    /* JADX WARNING: Missing block: B:159:0x0325, code skipped:
            if (r4 == null) goto L_0x032d;
     */
    /* JADX WARNING: Missing block: B:160:0x0327, code skipped:
            r0.removedInfo.installerPackageName = r4.installerPackageName;
     */
    /* JADX WARNING: Missing block: B:161:0x032d, code skipped:
            r0.removedInfo.isUpdate = true;
            r0.removedInfo.installReasons = r14.removedInfo.installReasons;
            r32 = true;
     */
    /* JADX WARNING: Missing block: B:162:0x033e, code skipped:
            r34 = r5;
     */
    /* JADX WARNING: Missing block: B:163:0x0341, code skipped:
            r33 = r3;
            r34 = r5;
     */
    /* JADX WARNING: Missing block: B:164:0x0345, code skipped:
            if (r32 != false) goto L_0x038d;
     */
    /* JADX WARNING: Missing block: B:165:0x0347, code skipped:
            r3 = new com.android.server.pm.PackageManagerService.PackageRemovedInfo(r11);
            r3.removedPackage = r2.packageName;
     */
    /* JADX WARNING: Missing block: B:166:0x0351, code skipped:
            if (r4 == null) goto L_0x0357;
     */
    /* JADX WARNING: Missing block: B:167:0x0353, code skipped:
            r3.installerPackageName = r4.installerPackageName;
     */
    /* JADX WARNING: Missing block: B:168:0x0357, code skipped:
            r3.isUpdate = false;
            r3.dataRemoved = true;
            r5 = r11.mPackages;
     */
    /* JADX WARNING: Missing block: B:169:0x035f, code skipped:
            monitor-enter(r5);
     */
    /* JADX WARNING: Missing block: B:170:0x0360, code skipped:
            if (r4 == null) goto L_0x036e;
     */
    /* JADX WARNING: Missing block: B:171:0x0362, code skipped:
            r35 = r7;
     */
    /* JADX WARNING: Missing block: B:173:?, code skipped:
            r3.origUsers = r4.queryInstalledUsers(r6, true);
     */
    /* JADX WARNING: Missing block: B:176:0x036e, code skipped:
            r35 = r7;
     */
    /* JADX WARNING: Missing block: B:177:0x0371, code skipped:
            monitor-exit(r5);
     */
    /* JADX WARNING: Missing block: B:179:0x0376, code skipped:
            if (r14.removedInfo.removedChildPackages != null) goto L_0x0381;
     */
    /* JADX WARNING: Missing block: B:180:0x0378, code skipped:
            r14.removedInfo.removedChildPackages = new android.util.ArrayMap();
     */
    /* JADX WARNING: Missing block: B:181:0x0381, code skipped:
            r14.removedInfo.removedChildPackages.put(r2.packageName, r3);
     */
    /* JADX WARNING: Missing block: B:185:0x038d, code skipped:
            r35 = r7;
     */
    /* JADX WARNING: Missing block: B:186:0x0390, code skipped:
            r0 = r1 + 1;
            r3 = r33;
            r5 = r34;
            r7 = r35;
     */
    /* JADX WARNING: Missing block: B:187:0x039b, code skipped:
            r33 = r3;
            r34 = r5;
            r35 = r7;
            r0 = true;
     */
    /* JADX WARNING: Missing block: B:188:0x03a6, code skipped:
            if (isSystemApp(r8) == false) goto L_0x0420;
     */
    /* JADX WARNING: Missing block: B:190:0x03af, code skipped:
            if ((r8.applicationInfo.privateFlags & 8) == 0) goto L_0x03b3;
     */
    /* JADX WARNING: Missing block: B:191:0x03b1, code skipped:
            r1 = true;
     */
    /* JADX WARNING: Missing block: B:192:0x03b3, code skipped:
            r1 = false;
     */
    /* JADX WARNING: Missing block: B:193:0x03b4, code skipped:
            r18 = r1;
     */
    /* JADX WARNING: Missing block: B:194:0x03bd, code skipped:
            if ((r8.applicationInfo.privateFlags & 131072) == 0) goto L_0x03c1;
     */
    /* JADX WARNING: Missing block: B:195:0x03bf, code skipped:
            r1 = true;
     */
    /* JADX WARNING: Missing block: B:196:0x03c1, code skipped:
            r1 = false;
     */
    /* JADX WARNING: Missing block: B:197:0x03c2, code skipped:
            r19 = r1;
            r3 = 262144;
     */
    /* JADX WARNING: Missing block: B:198:0x03cb, code skipped:
            if ((r8.applicationInfo.privateFlags & 262144) == 0) goto L_0x03cf;
     */
    /* JADX WARNING: Missing block: B:199:0x03cd, code skipped:
            r1 = true;
     */
    /* JADX WARNING: Missing block: B:200:0x03cf, code skipped:
            r1 = false;
     */
    /* JADX WARNING: Missing block: B:201:0x03d0, code skipped:
            r20 = r1;
            r5 = 524288;
     */
    /* JADX WARNING: Missing block: B:202:0x03d9, code skipped:
            if ((r8.applicationInfo.privateFlags & 524288) == 0) goto L_0x03dc;
     */
    /* JADX WARNING: Missing block: B:203:0x03dc, code skipped:
            r0 = false;
     */
    /* JADX WARNING: Missing block: B:204:0x03dd, code skipped:
            r4 = r9;
            r1 = r13 | 131072;
     */
    /* JADX WARNING: Missing block: B:205:0x03e0, code skipped:
            if (r18 == false) goto L_0x03e3;
     */
    /* JADX WARNING: Missing block: B:206:0x03e3, code skipped:
            r3 = 0;
     */
    /* JADX WARNING: Missing block: B:207:0x03e4, code skipped:
            r1 = r1 | r3;
     */
    /* JADX WARNING: Missing block: B:208:0x03e5, code skipped:
            if (r19 == false) goto L_0x03e8;
     */
    /* JADX WARNING: Missing block: B:209:0x03e8, code skipped:
            r5 = 0;
     */
    /* JADX WARNING: Missing block: B:210:0x03e9, code skipped:
            r1 = r1 | r5;
     */
    /* JADX WARNING: Missing block: B:211:0x03ea, code skipped:
            if (r20 == false) goto L_0x03ef;
     */
    /* JADX WARNING: Missing block: B:212:0x03ec, code skipped:
            r2 = 1048576;
     */
    /* JADX WARNING: Missing block: B:213:0x03ef, code skipped:
            r2 = 0;
     */
    /* JADX WARNING: Missing block: B:214:0x03f0, code skipped:
            r1 = r1 | r2;
     */
    /* JADX WARNING: Missing block: B:215:0x03f1, code skipped:
            if (r0 == false) goto L_0x03f6;
     */
    /* JADX WARNING: Missing block: B:216:0x03f3, code skipped:
            r2 = 2097152;
     */
    /* JADX WARNING: Missing block: B:217:0x03f6, code skipped:
            r2 = 0;
     */
    /* JADX WARNING: Missing block: B:218:0x03f7, code skipped:
            r21 = r1 | r2;
            r11.mHwPMSEx.resolvePersistentFlagForPackage(r8.applicationInfo.flags, r12);
            r22 = r33;
            r23 = r34;
            r25 = r35;
            r26 = r8;
            r27 = r10;
            replaceSystemPackageLIF(r8, r12, r4, r21, r40, r6, r41, r14, r43);
     */
    /* JADX WARNING: Missing block: B:219:0x0420, code skipped:
            r27 = r10;
            r22 = r33;
            r23 = r34;
            r25 = r35;
            replaceNonSystemPackageLIF(r8, r12, r38, r13, r40, r6, r41, r14, r43);
     */
    /* JADX WARNING: Missing block: B:220:0x043f, code skipped:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void replacePackageLIF(Package pkg, int parseFlags, int scanFlags, UserHandle user, String installerPackageName, PackageInstalledInfo res, int installReason) {
        boolean z;
        Package packageR = pkg;
        int i = scanFlags;
        PackageInstalledInfo packageInstalledInfo = res;
        boolean isInstantApp = (i & 16384) != 0;
        String pkgName = packageR.packageName;
        synchronized (this.mPackages) {
            Package oldPackage = (Package) this.mPackages.get(pkgName);
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("replacePackageLI: new=");
            stringBuilder.append(packageR);
            stringBuilder.append(", old=");
            stringBuilder.append(oldPackage);
            Flog.i(207, stringBuilder.toString());
            boolean oldTargetsPreRelease = oldPackage.applicationInfo.targetSdkVersion == 10000;
            boolean newTargetsPreRelease = packageR.applicationInfo.targetSdkVersion == 10000;
            int i2;
            if (!oldTargetsPreRelease || newTargetsPreRelease) {
                i2 = parseFlags;
            } else {
                i2 = parseFlags;
                if ((i2 & 128) == 0) {
                    Slog.w(TAG, "Can't install package targeting released sdk");
                    packageInstalledInfo.setReturnCode(-7);
                    return;
                }
            }
            try {
                StringBuilder stringBuilder2;
                String str;
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(pkgName);
                KeySetManagerService ksms = this.mSettings.mKeySetManagerService;
                if (ksms.shouldCheckUpgradeKeySetLocked(ps, i)) {
                    if (!ksms.checkUpgradeKeySetLocked(ps, packageR)) {
                        stringBuilder2 = new StringBuilder();
                        stringBuilder2.append("New package not signed by keys specified by upgrade-keysets: ");
                        stringBuilder2.append(pkgName);
                        packageInstalledInfo.setError(-7, stringBuilder2.toString());
                        return;
                    }
                } else if (!packageR.mSigningDetails.checkCapability(oldPackage.mSigningDetails, 1)) {
                    if (!oldPackage.mSigningDetails.checkCapability(packageR.mSigningDetails, 8)) {
                        if (isSystemSignatureUpdated(oldPackage.mSigningDetails.signatures, packageR.mSigningDetails.signatures)) {
                            str = TAG;
                            stringBuilder2 = new StringBuilder();
                            stringBuilder2.append("CertCompat: ");
                            stringBuilder2.append(packageR.packageName);
                            stringBuilder2.append(" system signature updated. Ignore signature matching.");
                            Slog.i(str, stringBuilder2.toString());
                        } else {
                            StringBuilder stringBuilder3 = new StringBuilder();
                            stringBuilder3.append("New package has a different signature: ");
                            stringBuilder3.append(pkgName);
                            packageInstalledInfo.setError(-7, stringBuilder3.toString());
                            return;
                        }
                    }
                }
                if (oldPackage.restrictUpdateHash != null) {
                    if (oldPackage.isSystem()) {
                        byte[] digestBytes = null;
                        try {
                            MessageDigest digest = MessageDigest.getInstance("SHA-512");
                            try {
                                int length;
                                updateDigest(digest, new File(packageR.baseCodePath));
                                if (ArrayUtils.isEmpty(packageR.splitCodePaths)) {
                                } else {
                                    String[] strArr = packageR.splitCodePaths;
                                    length = strArr.length;
                                    int newTargetsPreRelease2 = 0;
                                    while (newTargetsPreRelease2 < length) {
                                        String[] strArr2 = strArr;
                                        int i3 = length;
                                        updateDigest(digest, new File(strArr[newTargetsPreRelease2]));
                                        newTargetsPreRelease2++;
                                        strArr = strArr2;
                                        length = i3;
                                    }
                                }
                                if (Arrays.equals(oldPackage.restrictUpdateHash, digest.digest())) {
                                    packageR.restrictUpdateHash = oldPackage.restrictUpdateHash;
                                    str = getParentOrChildPackageChangedSharedUser(oldPackage, packageR);
                                    StringBuilder stringBuilder4;
                                    if (str == null) {
                                        stringBuilder4 = new StringBuilder();
                                        stringBuilder4.append("Package ");
                                        stringBuilder4.append(str);
                                        stringBuilder4.append(" tried to change user ");
                                        stringBuilder4.append(oldPackage.mSharedUserId);
                                        packageInstalledInfo.setError(-8, stringBuilder4.toString());
                                        return;
                                    }
                                    boolean oldPkgSupportMultiArch = oldPackage.applicationInfo.secondaryCpuAbi != null;
                                    boolean newPkgSupportMultiArch = packageR.applicationInfo.secondaryCpuAbi != null;
                                    if (isSystemApp(oldPackage) && oldPkgSupportMultiArch && !newPkgSupportMultiArch) {
                                        stringBuilder = new StringBuilder();
                                        stringBuilder.append("Update to package ");
                                        stringBuilder.append(pkgName);
                                        stringBuilder.append(" doesn't support multi arch");
                                        packageInstalledInfo.setError(-7, stringBuilder.toString());
                                        return;
                                    }
                                    int[] allUsers = sUserManager.getUserIds();
                                    int[] installedUsers = ps.queryInstalledUsers(allUsers, true);
                                    if (isInstantApp) {
                                        String str2;
                                        boolean z2;
                                        if (user != null) {
                                            if (user.getIdentifier()) {
                                                z2 = oldTargetsPreRelease;
                                            } else if (!ps.getInstantApp(user.getIdentifier())) {
                                                str2 = TAG;
                                                stringBuilder4 = new StringBuilder();
                                                stringBuilder4.append("Can't replace full app with instant app: ");
                                                stringBuilder4.append(pkgName);
                                                stringBuilder4.append(" for user: ");
                                                stringBuilder4.append(user.getIdentifier());
                                                Slog.w(str2, stringBuilder4.toString());
                                                packageInstalledInfo.setReturnCode(-116);
                                                return;
                                            }
                                        }
                                        z2 = oldTargetsPreRelease;
                                        int length2 = allUsers.length;
                                        length = 0;
                                        while (length < length2) {
                                            int currentUser = allUsers[length];
                                            if (ps.getInstantApp(currentUser)) {
                                                length++;
                                                ksms = ksms;
                                            } else {
                                                str2 = TAG;
                                                stringBuilder4 = new StringBuilder();
                                                stringBuilder4.append("Can't replace full app with instant app: ");
                                                stringBuilder4.append(pkgName);
                                                stringBuilder4.append(" for user: ");
                                                stringBuilder4.append(currentUser);
                                                Slog.w(str2, stringBuilder4.toString());
                                                packageInstalledInfo.setReturnCode(-116);
                                                return;
                                            }
                                        }
                                    }
                                } else {
                                    stringBuilder2 = new StringBuilder();
                                    stringBuilder2.append("New package fails restrict-update check: ");
                                    stringBuilder2.append(pkgName);
                                    packageInstalledInfo.setError(-2, stringBuilder2.toString());
                                    return;
                                }
                            } catch (IOException | NoSuchAlgorithmException e) {
                                z = newTargetsPreRelease;
                                stringBuilder2 = new StringBuilder();
                                stringBuilder2.append("Could not compute hash: ");
                                stringBuilder2.append(pkgName);
                                packageInstalledInfo.setError(-2, stringBuilder2.toString());
                                return;
                            }
                        } catch (IOException | NoSuchAlgorithmException e2) {
                            byte[] bArr = digestBytes;
                            z = newTargetsPreRelease;
                            stringBuilder2 = new StringBuilder();
                            stringBuilder2.append("Could not compute hash: ");
                            stringBuilder2.append(pkgName);
                            packageInstalledInfo.setError(-2, stringBuilder2.toString());
                            return;
                        }
                    }
                }
                str = getParentOrChildPackageChangedSharedUser(oldPackage, packageR);
                if (str == null) {
                }
            } catch (Throwable th) {
                Throwable th2 = th;
                String str3 = pkgName;
                while (true) {
                    try {
                        break;
                    } catch (Throwable th3) {
                        th2 = th3;
                    }
                }
                throw th2;
            }
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:106:0x02a3  */
    /* JADX WARNING: Removed duplicated region for block: B:58:0x018b  */
    /* JADX WARNING: Removed duplicated region for block: B:58:0x018b  */
    /* JADX WARNING: Removed duplicated region for block: B:106:0x02a3  */
    /* JADX WARNING: Missing block: B:91:0x0234, code skipped:
            r0 = TAG;
            r2 = new java.lang.StringBuilder();
            r2.append("Successfully restored package : ");
            r2.append(r7);
            r2.append(" after failed upgrade");
            android.util.Slog.i(r0, r2.toString());
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void replaceNonSystemPackageLIF(Package deletedPackage, Package pkg, int parseFlags, int scanFlags, UserHandle user, int[] allUsers, String installerPackageName, PackageInstalledInfo res, int installReason) {
        String str;
        StringBuilder stringBuilder;
        PackageManagerException e;
        Throwable th;
        boolean z;
        int i;
        String str2;
        String pkgName;
        Package packageR = deletedPackage;
        Package packageR2 = pkg;
        int i2 = scanFlags;
        PackageInstalledInfo packageInstalledInfo = res;
        if (DEBUG_INSTALL) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("replaceNonSystemPackageLI: new=");
            stringBuilder.append(packageR2);
            stringBuilder.append(", old=");
            stringBuilder.append(packageR);
            Slog.d(str, stringBuilder.toString());
        }
        if (!isMDMDisallowedInstallPackage(packageR2, packageInstalledInfo)) {
            boolean z2;
            String pkgName2;
            boolean deletedPkg;
            String pkgName3 = packageR.packageName;
            boolean addedPkg = false;
            boolean killApp = (i2 & 2048) == 0;
            int i3 = 8;
            int deleteFlags = 1 | (killApp ? 0 : 8);
            String pkgName4 = pkgName3;
            long origUpdateTime = packageR2.mExtras != null ? ((PackageSetting) packageR2.mExtras).lastUpdateTime : 0;
            PackageInstalledInfo packageInstalledInfo2 = packageInstalledInfo;
            if (deletePackageLIF(pkgName3, null, true, allUsers, deleteFlags, packageInstalledInfo.removedInfo, true, packageR2)) {
                if (deletedPackage.isForwardLocked() || isExternal(deletedPackage)) {
                    if (DEBUG_INSTALL) {
                        str = TAG;
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("upgrading pkg ");
                        stringBuilder.append(packageR);
                        stringBuilder.append(" is ASEC-hosted -> UNAVAILABLE");
                        Slog.i(str, stringBuilder.toString());
                    }
                    z2 = true;
                    int[] uidArray = new int[]{packageR.applicationInfo.uid};
                    ArrayList<String> pkgList = new ArrayList(1);
                    pkgList.add(packageR.applicationInfo.packageName);
                    sendResourcesChangedBroadcast(false, true, (ArrayList) pkgList, uidArray, null);
                } else {
                    z2 = true;
                }
                clearAppDataLIF(packageR2, -1, UsbTerminalTypes.TERMINAL_IN_PERSONAL_MIC);
                try {
                    Package newPackage = scanPackageTracedLI(packageR2, parseFlags, i2 | 8, System.currentTimeMillis(), user);
                    updateSettingsLI(newPackage, installerPackageName, allUsers, packageInstalledInfo2, user, installReason);
                    pkgName2 = pkgName4;
                    try {
                        PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(pkgName2);
                        if (killApp) {
                            ps.oldCodePaths = null;
                        } else {
                            if (ps.oldCodePaths == null) {
                                ps.oldCodePaths = new ArraySet();
                            }
                            Set set = ps.oldCodePaths;
                            String[] strArr = new String[z2];
                            strArr[0] = packageR.baseCodePath;
                            Collections.addAll(set, strArr);
                            if (packageR.splitCodePaths != null) {
                                Collections.addAll(ps.oldCodePaths, packageR.splitCodePaths);
                            }
                        }
                        if (ps.childPackageNames != null) {
                            for (int i4 = ps.childPackageNames.size() - z2; i4 >= 0; i4--) {
                                ((PackageSetting) this.mSettings.mPackages.get((String) ps.childPackageNames.get(i4))).oldCodePaths = ps.oldCodePaths;
                            }
                        }
                        prepareAppDataAfterInstallLIF(newPackage);
                        addedPkg = true;
                        this.mDexManager.notifyPackageUpdated(newPackage.packageName, newPackage.baseCodePath, newPackage.splitCodePaths);
                    } catch (PackageManagerException e2) {
                        e = e2;
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("Package couldn't be installed in ");
                        stringBuilder.append(packageR2.codePath);
                        packageInstalledInfo2.setError(stringBuilder.toString(), e);
                        deletedPkg = true;
                        if (packageInstalledInfo2.returnCode != z2) {
                        }
                    }
                } catch (PackageManagerException e3) {
                    e = e3;
                    pkgName2 = pkgName4;
                    stringBuilder = new StringBuilder();
                    stringBuilder.append("Package couldn't be installed in ");
                    stringBuilder.append(packageR2.codePath);
                    packageInstalledInfo2.setError(stringBuilder.toString(), e);
                    deletedPkg = true;
                    if (packageInstalledInfo2.returnCode != z2) {
                    }
                }
                deletedPkg = true;
            } else {
                packageInstalledInfo2.setError(-10, "replaceNonSystemPackageLI");
                deletedPkg = false;
                pkgName2 = pkgName4;
                z2 = true;
            }
            Package packageR3;
            PackageInstalledInfo packageInstalledInfo3;
            long j;
            if (packageInstalledInfo2.returnCode != z2) {
                if (DEBUG_INSTALL) {
                    str = TAG;
                    stringBuilder = new StringBuilder();
                    stringBuilder.append("Install failed, rolling pack: ");
                    stringBuilder.append(pkgName2);
                    Slog.d(str, stringBuilder.toString());
                }
                if (addedPkg) {
                    deletePackageLIF(pkgName2, null, true, allUsers, deleteFlags, packageInstalledInfo2.removedInfo, true, null);
                }
                if (deletedPkg) {
                    if (DEBUG_INSTALL) {
                        str = TAG;
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("Install failed, reinstalling: ");
                        stringBuilder.append(packageR);
                        Slog.d(str, stringBuilder.toString());
                    }
                    File restoreFile = new File(packageR.codePath);
                    boolean oldExternal = isExternal(deletedPackage);
                    int i5 = (this.mDefParseFlags | Integer.MIN_VALUE) | (deletedPackage.isForwardLocked() ? 4 : 0);
                    if (!oldExternal) {
                        i3 = 0;
                    }
                    int oldParseFlags = i5 | i3;
                    packageR3 = packageR2;
                    Package packageR4 = packageR;
                    PackageInstalledInfo packageInstalledInfo4 = packageInstalledInfo2;
                    String pkgName5 = pkgName2;
                    try {
                        scanPackageTracedLI(restoreFile, oldParseFlags, 10, origUpdateTime, null);
                        synchronized (this.mPackages) {
                            try {
                                setInstallerPackageNameLPw(packageR4, installerPackageName);
                                try {
                                    oldExternal = pkgName5;
                                    oldParseFlags = res;
                                } catch (Throwable th2) {
                                    th = th2;
                                    z = oldExternal;
                                    i = oldParseFlags;
                                    oldParseFlags = res;
                                    oldExternal = pkgName5;
                                    throw th;
                                }
                                try {
                                    this.mPermissionManager.updatePermissions(packageR4.packageName, packageR4, false, this.mPackages.values(), this.mPermissionCallback);
                                    try {
                                        this.mSettings.writeLPr();
                                    } catch (Throwable th3) {
                                        th = th3;
                                        throw th;
                                    }
                                } catch (Throwable th4) {
                                    th = th4;
                                    throw th;
                                }
                            } catch (Throwable th5) {
                                th = th5;
                                z = oldExternal;
                                i = oldParseFlags;
                                oldExternal = pkgName5;
                                oldParseFlags = packageInstalledInfo4;
                                throw th;
                            }
                        }
                    } catch (PackageManagerException e4) {
                        str2 = installerPackageName;
                        z = oldExternal;
                        i = oldParseFlags;
                        pkgName = pkgName5;
                        oldParseFlags = packageInstalledInfo4;
                        PackageManagerException packageManagerException = e4;
                        String str3 = TAG;
                        StringBuilder stringBuilder2 = new StringBuilder();
                        stringBuilder2.append("Failed to restore package : ");
                        stringBuilder2.append(pkgName);
                        stringBuilder2.append(" after failed upgrade: ");
                        stringBuilder2.append(e4.getMessage());
                        Slog.e(str3, stringBuilder2.toString());
                        return;
                    }
                }
                packageR3 = packageR2;
                packageInstalledInfo3 = packageInstalledInfo2;
                pkgName = pkgName2;
                j = origUpdateTime;
                str2 = installerPackageName;
            } else {
                boolean z3 = z2;
                packageR3 = packageR2;
                packageInstalledInfo3 = packageInstalledInfo2;
                pkgName = pkgName2;
                j = origUpdateTime;
                str2 = installerPackageName;
                synchronized (this.mPackages) {
                    PackageSetting ps2 = this.mSettings.getPackageLPr(packageR3.packageName);
                    if (ps2 != null) {
                        packageInstalledInfo3.removedInfo.removedForAllUsers = this.mPackages.get(ps2.name) == null ? z3 : false;
                        if (packageInstalledInfo3.removedInfo.removedChildPackages != null) {
                            for (int i6 = packageInstalledInfo3.removedInfo.removedChildPackages.size() - 1; i6 >= 0; i6--) {
                                if (packageInstalledInfo3.addedChildPackages.containsKey((String) packageInstalledInfo3.removedInfo.removedChildPackages.keyAt(i6))) {
                                    packageInstalledInfo3.removedInfo.removedChildPackages.removeAt(i6);
                                } else {
                                    PackageRemovedInfo childInfo = (PackageRemovedInfo) packageInstalledInfo3.removedInfo.removedChildPackages.valueAt(i6);
                                    childInfo.removedForAllUsers = this.mPackages.get(childInfo.removedPackage) == null ? z3 : false;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:139:? A:{SYNTHETIC, RETURN, ORIG_RETURN} */
    /* JADX WARNING: Removed duplicated region for block: B:97:0x01f6  */
    /* JADX WARNING: Removed duplicated region for block: B:97:0x01f6  */
    /* JADX WARNING: Removed duplicated region for block: B:139:? A:{SYNTHETIC, RETURN, ORIG_RETURN} */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void replaceSystemPackageLIF(Package deletedPackage, Package pkg, int parseFlags, int scanFlags, UserHandle user, int[] allUsers, String installerPackageName, PackageInstalledInfo res, int installReason) {
        String str;
        StringBuilder stringBuilder;
        boolean disabledSystem;
        String disableSysPath;
        PackageManagerException e;
        Package newPackage;
        Package packageR = deletedPackage;
        Package packageR2 = pkg;
        PackageInstalledInfo packageInstalledInfo = res;
        if (DEBUG_INSTALL) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("replaceSystemPackageLI: new=");
            stringBuilder.append(packageR2);
            stringBuilder.append(", old=");
            stringBuilder.append(packageR);
            Slog.d(str, stringBuilder.toString());
        }
        String packageName = packageR.packageName;
        PackageSetting deletePackageSetting = (PackageSetting) this.mSettings.mPackages.get(packageName);
        removePackageLI(packageR, true);
        synchronized (this.mPackages) {
            disabledSystem = disableSystemPackageLPw(deletedPackage, pkg);
        }
        if (disabledSystem) {
            packageInstalledInfo.removedInfo.args = null;
        } else {
            packageInstalledInfo.removedInfo.args = createInstallArgsForExisting(0, packageR.applicationInfo.getCodePath(), packageR.applicationInfo.getResourcePath(), InstructionSets.getAppDexInstructionSets(packageR.applicationInfo));
        }
        clearAppDataLIF(packageR2, -1, UsbTerminalTypes.TERMINAL_IN_PERSONAL_MIC);
        packageInstalledInfo.setReturnCode(1);
        packageR2.setApplicationInfoFlags(128, 128);
        synchronized (this.mPackages) {
            disableSysPath = this.mSettings.getDisabledSysPackagesPath(packageName);
            PackageSetting disableSysSetting = this.mSettings.getDisabledSystemPkgLPr(packageName);
            boolean disableSysPathInDel = false;
            boolean disableSysInData = false;
            if (disableSysPath != null && (containDelPath(disableSysPath) || isPreRemovableApp(disableSysPath))) {
                disableSysPathInDel = true;
            }
            if (disableSysSetting != null && isDelappInData(disableSysSetting)) {
                disableSysInData = true;
            }
            if (disableSysSetting != null && isDelappInCust(disableSysSetting)) {
                disableSysInData = true;
            }
            if (containDelPath(packageR.applicationInfo.sourceDir) || isPreRemovableApp(packageR.applicationInfo.sourceDir) || isDelappInData(deletePackageSetting) || isDelappInCust(deletePackageSetting) || disableSysPathInDel || disableSysInData) {
                ApplicationInfo applicationInfo = packageR2.applicationInfo;
                applicationInfo.hwFlags |= 67108864;
            }
        }
        int i = 0;
        Package newPackage2;
        try {
            newPackage2 = scanPackageTracedLI(packageR2, parseFlags, scanFlags, 0, user);
            try {
                PackageSetting deletedPkgSetting = (PackageSetting) packageR.mExtras;
                setInstallAndUpdateTime(newPackage2, deletedPkgSetting.firstInstallTime, System.currentTimeMillis());
                if (packageInstalledInfo.returnCode == 1) {
                    int size;
                    int deletedChildCount;
                    if (packageR.childPackages != null) {
                        try {
                            size = packageR.childPackages.size();
                        } catch (PackageManagerException e2) {
                            e = e2;
                        }
                    } else {
                        size = 0;
                    }
                    int deletedChildCount2 = size;
                    int newChildCount = newPackage2.childPackages != null ? newPackage2.childPackages.size() : 0;
                    size = 0;
                    while (true) {
                        int i2 = size;
                        if (i2 >= deletedChildCount2) {
                            break;
                        }
                        boolean childPackageDeleted;
                        int i3;
                        int newChildCount2;
                        Package deletedChildPkg = (Package) packageR.childPackages.get(i2);
                        boolean childPackageDeleted2 = true;
                        int j = i;
                        while (j < newChildCount) {
                            childPackageDeleted = childPackageDeleted2;
                            if (deletedChildPkg.packageName.equals(((Package) newPackage2.childPackages.get(j)).packageName)) {
                                childPackageDeleted = false;
                                break;
                            } else {
                                j++;
                                childPackageDeleted2 = childPackageDeleted;
                            }
                        }
                        childPackageDeleted = childPackageDeleted2;
                        if (childPackageDeleted) {
                            PackageSetting ps = this.mSettings.getDisabledSystemPkgLPr(deletedChildPkg.packageName);
                            if (!(ps == null || packageInstalledInfo.removedInfo.removedChildPackages == null)) {
                                PackageRemovedInfo removedChildRes = (PackageRemovedInfo) packageInstalledInfo.removedInfo.removedChildPackages.get(deletedChildPkg.packageName);
                                i3 = i2;
                                newChildCount2 = newChildCount;
                                deletedChildCount = deletedChildCount2;
                                removePackageDataLIF(ps, allUsers, removedChildRes, 0, 0);
                                removedChildRes.removedForAllUsers = this.mPackages.get(ps.name) == null;
                                size = i3 + 1;
                                deletedChildCount2 = deletedChildCount;
                                newChildCount = newChildCount2;
                                i = 0;
                            }
                        }
                        i3 = i2;
                        newChildCount2 = newChildCount;
                        deletedChildCount = deletedChildCount2;
                        size = i3 + 1;
                        deletedChildCount2 = deletedChildCount;
                        newChildCount = newChildCount2;
                        i = 0;
                    }
                    deletedChildCount = deletedChildCount2;
                    newPackage = newPackage2;
                    try {
                        updateSettingsLI(newPackage2, installerPackageName, allUsers, packageInstalledInfo, user, installReason);
                        prepareAppDataAfterInstallLIF(newPackage);
                        this.mDexManager.notifyPackageUpdated(newPackage.packageName, newPackage.baseCodePath, newPackage.splitCodePaths);
                    } catch (PackageManagerException e3) {
                        e = e3;
                        newPackage2 = newPackage;
                    }
                } else {
                    newPackage = newPackage2;
                }
            } catch (PackageManagerException e4) {
                e = e4;
                newPackage = newPackage2;
                packageInstalledInfo.setReturnCode(RequestStatus.SYS_ETIMEDOUT);
                stringBuilder = new StringBuilder();
                stringBuilder.append("Package couldn't be installed in ");
                stringBuilder.append(packageR2.codePath);
                packageInstalledInfo.setError(stringBuilder.toString(), e);
                newPackage = newPackage2;
                if (packageInstalledInfo.returnCode != 1) {
                }
            }
        } catch (PackageManagerException e5) {
            e = e5;
            newPackage2 = null;
            packageInstalledInfo.setReturnCode(RequestStatus.SYS_ETIMEDOUT);
            stringBuilder = new StringBuilder();
            stringBuilder.append("Package couldn't be installed in ");
            stringBuilder.append(packageR2.codePath);
            packageInstalledInfo.setError(stringBuilder.toString(), e);
            newPackage = newPackage2;
            if (packageInstalledInfo.returnCode != 1) {
            }
        }
        if (packageInstalledInfo.returnCode != 1) {
            if (newPackage != null) {
                stringBuilder = new StringBuilder();
                stringBuilder.append("replace syspkg, Install failed: ");
                stringBuilder.append(packageInstalledInfo.returnCode);
                stringBuilder.append(", pkg: ");
                stringBuilder.append(newPackage.packageName);
                Flog.i(207, stringBuilder.toString());
                removeInstalledPackageLI(newPackage, true);
            }
            try {
                scanPackageTracedLI(packageR, parseFlags, 2, 0, user);
            } catch (PackageManagerException e6) {
                PackageManagerException packageManagerException = e6;
                disableSysPath = TAG;
                StringBuilder stringBuilder2 = new StringBuilder();
                stringBuilder2.append("Failed to restore original package: ");
                stringBuilder2.append(e6.getMessage());
                Slog.e(disableSysPath, stringBuilder2.toString());
            }
            synchronized (this.mPackages) {
                if (disabledSystem) {
                    try {
                        enableSystemPackageLPw(deletedPackage);
                    } catch (Throwable th) {
                        while (true) {
                        }
                    }
                }
                setInstallerPackageNameLPw(packageR, installerPackageName);
                this.mPermissionManager.updatePermissions(packageR.packageName, packageR, false, this.mPackages.values(), this.mPermissionCallback);
                this.mSettings.writeLPr();
            }
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("Successfully restored package : ");
            stringBuilder.append(packageR.packageName);
            stringBuilder.append(" after failed upgrade");
            Slog.i(str, stringBuilder.toString());
        }
    }

    private String getParentOrChildPackageChangedSharedUser(Package oldPkg, Package newPkg) {
        if (!Objects.equals(oldPkg.mSharedUserId, newPkg.mSharedUserId)) {
            return newPkg.packageName;
        }
        int oldChildCount = oldPkg.childPackages != null ? oldPkg.childPackages.size() : 0;
        int newChildCount = newPkg.childPackages != null ? newPkg.childPackages.size() : 0;
        for (int i = 0; i < newChildCount; i++) {
            Package newChildPkg = (Package) newPkg.childPackages.get(i);
            for (int j = 0; j < oldChildCount; j++) {
                Package oldChildPkg = (Package) oldPkg.childPackages.get(j);
                if (newChildPkg.packageName.equals(oldChildPkg.packageName) && !Objects.equals(newChildPkg.mSharedUserId, oldChildPkg.mSharedUserId)) {
                    return newChildPkg.packageName;
                }
            }
        }
        return null;
    }

    private void removeNativeBinariesLI(PackageSetting ps) {
        if (ps != null) {
            NativeLibraryHelper.removeNativeBinariesLI(ps.legacyNativeLibraryPathString);
            int i = 0;
            int childCount = ps.childPackageNames != null ? ps.childPackageNames.size() : 0;
            while (i < childCount) {
                PackageSetting childPs;
                synchronized (this.mPackages) {
                    childPs = this.mSettings.getPackageLPr((String) ps.childPackageNames.get(i));
                }
                if (childPs != null) {
                    NativeLibraryHelper.removeNativeBinariesLI(childPs.legacyNativeLibraryPathString);
                }
                i++;
            }
        }
    }

    private void enableSystemPackageLPw(Package pkg) {
        this.mSettings.enableSystemPackageLPw(pkg.packageName);
        int i = 0;
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        while (i < childCount) {
            this.mSettings.enableSystemPackageLPw(((Package) pkg.childPackages.get(i)).packageName);
            i++;
        }
    }

    private boolean disableSystemPackageLPw(Package oldPkg, Package newPkg) {
        boolean disabled = this.mSettings.disableSystemPackageLPw(oldPkg.packageName, true);
        int i = 0;
        int childCount = oldPkg.childPackages != null ? oldPkg.childPackages.size() : 0;
        while (i < childCount) {
            Package childPkg = (Package) oldPkg.childPackages.get(i);
            disabled |= this.mSettings.disableSystemPackageLPw(childPkg.packageName, newPkg.hasChildPackage(childPkg.packageName));
            i++;
        }
        return disabled;
    }

    private void setInstallerPackageNameLPw(Package pkg, String installerPackageName) {
        this.mSettings.setInstallerPackageName(pkg.packageName, installerPackageName);
        int i = 0;
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        while (i < childCount) {
            this.mSettings.setInstallerPackageName(((Package) pkg.childPackages.get(i)).packageName, installerPackageName);
            i++;
        }
    }

    protected void updateSettingsLI(Package newPackage, String installerPackageName, int[] allUsers, PackageInstalledInfo res, UserHandle user, int installReason) {
        Package packageR = newPackage;
        PackageInstalledInfo packageInstalledInfo = res;
        updateSettingsInternalLI(packageR, installerPackageName, allUsers, packageInstalledInfo.origUsers, packageInstalledInfo, user, installReason);
        int i = 0;
        int childCount = packageR.childPackages != null ? packageR.childPackages.size() : 0;
        while (i < childCount) {
            Package childPackage = (Package) packageR.childPackages.get(i);
            PackageInstalledInfo childRes = (PackageInstalledInfo) packageInstalledInfo.addedChildPackages.get(childPackage.packageName);
            updateSettingsInternalLI(childPackage, installerPackageName, allUsers, childRes.origUsers, childRes, user, installReason);
            i++;
        }
    }

    private void updateSettingsInternalLI(Package pkg, String installerPackageName, int[] allUsers, int[] installedForUsers, PackageInstalledInfo res, UserHandle user, int installReason) {
        Throwable th;
        Package packageR = pkg;
        String str = installerPackageName;
        int[] iArr = allUsers;
        int[] iArr2 = installedForUsers;
        PackageInstalledInfo packageInstalledInfo = res;
        int i = installReason;
        Trace.traceBegin(262144, "updateSettings");
        String pkgName = packageR.packageName;
        if (DEBUG_INSTALL) {
            String str2 = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("New package installed in ");
            stringBuilder.append(packageR.codePath);
            Slog.d(str2, stringBuilder.toString());
        }
        ArrayMap arrayMap = this.mPackages;
        synchronized (arrayMap) {
            ArrayMap arrayMap2;
            String pkgName2;
            try {
                arrayMap2 = arrayMap;
                pkgName2 = pkgName;
                try {
                    this.mPermissionManager.updatePermissions(packageR.packageName, packageR, true, this.mPackages.values(), this.mPermissionCallback);
                    PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(pkgName2);
                    updateFlagsForMarketSystemApp(pkg);
                    int userId = user.getIdentifier();
                    if (ps != null) {
                        int i2;
                        int origUserId;
                        int installReasonCount;
                        int i3;
                        if (isSystemApp(pkg)) {
                            if (DEBUG_INSTALL) {
                                String str3 = TAG;
                                StringBuilder stringBuilder2 = new StringBuilder();
                                stringBuilder2.append("Implicitly enabling system package on upgrade: ");
                                stringBuilder2.append(pkgName2);
                                Slog.d(str3, stringBuilder2.toString());
                            }
                            if (packageInstalledInfo.origUsers != null) {
                                for (int origUserId2 : packageInstalledInfo.origUsers) {
                                    if (userId != -1) {
                                        origUserId = origUserId2;
                                        if (userId != origUserId) {
                                        }
                                    } else {
                                        origUserId = origUserId2;
                                    }
                                    ps.setEnabled(0, origUserId, str);
                                }
                            }
                            if (!(iArr == null || iArr2 == null)) {
                                origUserId = iArr.length;
                                int i4 = 0;
                                while (i4 < origUserId) {
                                    int i5;
                                    i2 = iArr[i4];
                                    boolean installed = ArrayUtils.contains(iArr2, i2);
                                    if (DEBUG_INSTALL) {
                                        String str4 = TAG;
                                        StringBuilder stringBuilder3 = new StringBuilder();
                                        i5 = origUserId;
                                        stringBuilder3.append("    user ");
                                        stringBuilder3.append(i2);
                                        stringBuilder3.append(" => ");
                                        stringBuilder3.append(installed);
                                        Slog.d(str4, stringBuilder3.toString());
                                    } else {
                                        i5 = origUserId;
                                    }
                                    ps.setInstalled(installed, i2);
                                    i4++;
                                    origUserId = i5;
                                }
                            }
                        }
                        if (userId != -1) {
                            ps.setInstalled(true, userId);
                            origUserId = 0;
                            ps.setEnabled(0, userId, str);
                        } else {
                            origUserId = 0;
                        }
                        Set<Integer> previousUserIds = new ArraySet();
                        if (!(packageInstalledInfo.removedInfo == null || packageInstalledInfo.removedInfo.installReasons == null)) {
                            installReasonCount = packageInstalledInfo.removedInfo.installReasons.size();
                            for (i3 = origUserId; i3 < installReasonCount; i3++) {
                                i2 = packageInstalledInfo.removedInfo.installReasons.keyAt(i3);
                                ps.setInstallReason(((Integer) packageInstalledInfo.removedInfo.installReasons.valueAt(i3)).intValue(), i2);
                                previousUserIds.add(Integer.valueOf(i2));
                            }
                        }
                        if (userId == -1) {
                            for (String pkgName3 : sUserManager.getUserIds()) {
                                if (!previousUserIds.contains(Integer.valueOf(pkgName3))) {
                                    ps.setInstallReason(i, pkgName3);
                                }
                            }
                        } else if (!previousUserIds.contains(Integer.valueOf(userId))) {
                            ps.setInstallReason(i, userId);
                        }
                        this.mSettings.writeKernelMappingLPr(ps);
                    }
                    packageInstalledInfo.name = pkgName2;
                    packageInstalledInfo.uid = packageR.applicationInfo.uid;
                    packageInstalledInfo.pkg = packageR;
                    this.mSettings.setInstallerPackageName(pkgName2, str);
                    packageInstalledInfo.setReturnCode(1);
                    Trace.traceBegin(262144, "writeSettings");
                    this.mSettings.writeLPr();
                    Trace.traceEnd(262144);
                    Trace.traceEnd(262144);
                } catch (Throwable th2) {
                    th = th2;
                    throw th;
                }
            } catch (Throwable th3) {
                th = th3;
                arrayMap2 = arrayMap;
                pkgName2 = pkgName3;
                throw th;
            }
        }
    }

    private void installPackageTracedLI(InstallArgs args, PackageInstalledInfo res) {
        try {
            Trace.traceBegin(262144, "installPackage");
            installPackageLI(args, res);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:242:0x04f9  */
    /* JADX WARNING: Removed duplicated region for block: B:237:0x04ce  */
    /* JADX WARNING: Removed duplicated region for block: B:380:0x0825  */
    /* JADX WARNING: Removed duplicated region for block: B:366:0x07d8 A:{SYNTHETIC, Splitter:B:366:0x07d8} */
    /* JADX WARNING: Removed duplicated region for block: B:416:0x08c0 A:{SYNTHETIC, Splitter:B:416:0x08c0} */
    /* JADX WARNING: Removed duplicated region for block: B:432:0x08fd A:{Catch:{ all -> 0x090f }} */
    /* JADX WARNING: Removed duplicated region for block: B:431:0x08fb A:{Catch:{ all -> 0x090f }} */
    /* JADX WARNING: Removed duplicated region for block: B:492:0x0ae3 A:{Catch:{ all -> 0x0b32 }} */
    /* JADX WARNING: Removed duplicated region for block: B:483:0x0a1a A:{Catch:{ all -> 0x0b32 }} */
    /* JADX WARNING: Removed duplicated region for block: B:729:0x0f9e  */
    /* JADX WARNING: Removed duplicated region for block: B:729:0x0f9e  */
    /* JADX WARNING: Removed duplicated region for block: B:729:0x0f9e  */
    /* JADX WARNING: Removed duplicated region for block: B:729:0x0f9e  */
    /* JADX WARNING: Removed duplicated region for block: B:416:0x08c0 A:{SYNTHETIC, Splitter:B:416:0x08c0} */
    /* JADX WARNING: Removed duplicated region for block: B:431:0x08fb A:{Catch:{ all -> 0x090f }} */
    /* JADX WARNING: Removed duplicated region for block: B:432:0x08fd A:{Catch:{ all -> 0x090f }} */
    /* JADX WARNING: Removed duplicated region for block: B:452:0x0961 A:{SYNTHETIC, Splitter:B:452:0x0961} */
    /* JADX WARNING: Removed duplicated region for block: B:571:0x0c92  */
    /* JADX WARNING: Removed duplicated region for block: B:569:0x0c8b  */
    /* JADX WARNING: Missing block: B:706:0x0f59, code skipped:
            if (r12.returnCode != 1) goto L_0x0f65;
     */
    /* JADX WARNING: Missing block: B:707:0x0f5b, code skipped:
            recordInstallAppInfo(r14.packageName, r71, r74);
     */
    /* JADX WARNING: Missing block: B:708:0x0f65, code skipped:
            r7 = r71;
            r6 = r74;
     */
    /* JADX WARNING: Missing block: B:709:0x0f69, code skipped:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {
        PackageParserException e;
        boolean z;
        File file;
        String str;
        int i;
        PackageParser packageParser;
        boolean z2;
        Throwable th;
        String installerPackageName;
        String oldCodePath;
        boolean systemApp;
        boolean replace;
        File file2;
        boolean replace2;
        String volumeUuid;
        Object obj;
        boolean replace3;
        PackageManagerException e2;
        PackageSetting packageSetting;
        PackageManagerException oldCodePath2;
        int scanFlags;
        boolean installFlags;
        Throwable th2;
        Object obj2;
        int i2;
        long installBeginTime;
        int installFlags2;
        Object obj3;
        InstallArgs installArgs = args;
        PackageInstalledInfo packageInstalledInfo = res;
        if (Secure.getInt(this.mContext.getContentResolver(), SUW_FRP_STATE, 0) != 1 || Global.getInt(this.mContext.getContentResolver(), "device_provisioned", 0) == 1) {
            String str2;
            StringBuilder stringBuilder;
            int installFlags3 = installArgs.installFlags;
            String installerPackageName2 = installArgs.installerPackageName;
            String volumeUuid2 = installArgs.volumeUuid;
            File tmpPackageFile = new File(args.getCodePath());
            boolean forwardLocked = (installFlags3 & 1) != 0;
            boolean z3 = ((installFlags3 & 8) == 0 && installArgs.volumeUuid == null) ? false : true;
            boolean onExternal = z3;
            boolean instantApp = (installFlags3 & 2048) != 0;
            boolean fullApp = (installFlags3 & 16384) != 0;
            boolean forceSdk = (installFlags3 & 8192) != 0;
            boolean virtualPreload = (installFlags3 & 65536) != 0;
            boolean replace4 = false;
            int scanFlags2 = 6;
            if (installArgs.move != null) {
                scanFlags2 = 6 | 512;
            }
            if ((installFlags3 & 4096) != 0) {
                scanFlags2 |= 2048;
            }
            if (instantApp) {
                scanFlags2 |= 16384;
            }
            if (fullApp) {
                scanFlags2 |= 32768;
            }
            if (virtualPreload) {
                scanFlags2 |= 65536;
            }
            packageInstalledInfo.setReturnCode(1);
            packageInstalledInfo.installerPackageName = installerPackageName2;
            int installFlags4 = installFlags3;
            long installBeginTime2 = SystemClock.elapsedRealtime();
            if (DEBUG_INSTALL) {
                str2 = TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("installPackageLI: path=");
                stringBuilder.append(tmpPackageFile);
                Slog.d(str2, stringBuilder.toString());
            }
            if (instantApp && (forwardLocked || onExternal)) {
                str2 = TAG;
                StringBuilder stringBuilder2 = new StringBuilder();
                stringBuilder2.append("Incompatible ephemeral install; fwdLocked=");
                stringBuilder2.append(forwardLocked);
                stringBuilder2.append(" external=");
                stringBuilder2.append(onExternal);
                Slog.i(str2, stringBuilder2.toString());
                packageInstalledInfo.setReturnCode(-116);
                return;
            }
            int parseFlags = ((((this.mDefParseFlags | Integer.MIN_VALUE) | 64) | (forwardLocked ? 4 : 0)) | (onExternal ? 8 : 0)) | (forceSdk ? 128 : 0);
            PackageParser pp = new PackageParser();
            pp.setSeparateProcesses(this.mSeparateProcesses);
            pp.setDisplayMetrics(this.mMetrics);
            pp.setCallback(this.mPackageParserCallback);
            boolean onExternal2 = onExternal;
            long j = 262144;
            Trace.traceBegin(262144, "parsePackage");
            boolean z4;
            try {
                Package pp2;
                int childCount;
                int i3;
                long installBeginTime3;
                PackageSetting childPs;
                File tmpPackageFile2;
                StringBuilder stringBuilder3;
                Package pkg = pp.parsePackage(tmpPackageFile, parseFlags);
                DexMetadataHelper.validatePackageDexMetadata(pkg);
                if (pkg != null) {
                    try {
                        if (isInMultiWinWhiteList(pkg.packageName)) {
                            pkg.forceResizeableAllActivity();
                        }
                    } catch (PackageParserException e3) {
                        e = e3;
                        z4 = false;
                        z = forwardLocked;
                        file = tmpPackageFile;
                        str = volumeUuid2;
                        i = parseFlags;
                        packageParser = pp;
                        replace4 = installerPackageName2;
                        z2 = onExternal2;
                        j = 262144;
                        forwardLocked = installBeginTime2;
                        try {
                            packageInstalledInfo.setError("Failed parse during installPackageLI", e);
                            Trace.traceEnd(j);
                            return;
                        } catch (Throwable th3) {
                            th = th3;
                            Trace.traceEnd(j);
                            throw th;
                        }
                    } catch (Throwable th4) {
                        th = th4;
                        z4 = false;
                        z = forwardLocked;
                        file = tmpPackageFile;
                        str = volumeUuid2;
                        i = parseFlags;
                        packageParser = pp;
                        replace4 = installerPackageName2;
                        z2 = onExternal2;
                        j = 262144;
                        forwardLocked = installBeginTime2;
                        Trace.traceEnd(j);
                        throw th;
                    }
                }
                Trace.traceEnd(262144);
                Package pkg2 = pkg;
                if (instantApp) {
                    pp2 = pkg2;
                    if (pp2.applicationInfo.targetSdkVersion < 26) {
                        str2 = TAG;
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("Instant app package ");
                        stringBuilder.append(pp2.packageName);
                        stringBuilder.append(" does not target at least O");
                        Slog.w(str2, stringBuilder.toString());
                        packageInstalledInfo.setError(-116, "Instant app package must target at least O");
                        return;
                    } else if (pp2.applicationInfo.targetSandboxVersion != 2) {
                        str2 = TAG;
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("Instant app package ");
                        stringBuilder.append(pp2.packageName);
                        stringBuilder.append(" does not target targetSandboxVersion 2");
                        Slog.w(str2, stringBuilder.toString());
                        packageInstalledInfo.setError(-116, "Instant app package must use targetSandboxVersion 2");
                        return;
                    } else if (pp2.mSharedUserId != null) {
                        str2 = TAG;
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("Instant app package ");
                        stringBuilder.append(pp2.packageName);
                        stringBuilder.append(" may not declare sharedUserId.");
                        Slog.w(str2, stringBuilder.toString());
                        packageInstalledInfo.setError(-116, "Instant app package may not declare a sharedUserId");
                        return;
                    }
                }
                pp2 = pkg2;
                if (pp2.applicationInfo.isStaticSharedLibrary()) {
                    renameStaticSharedLibraryPackage(pp2);
                    if (onExternal2) {
                        Slog.i(TAG, "Static shared libs can only be installed on internal storage.");
                        packageInstalledInfo.setError(-19, "Packages declaring static-shared libs cannot be updated");
                        return;
                    }
                }
                if (pp2.childPackages != null) {
                    synchronized (this.mPackages) {
                        try {
                            childCount = pp2.childPackages.size();
                            i3 = 0;
                            while (i3 < childCount) {
                                int childCount2 = childCount;
                                pkg = (Package) pp2.childPackages.get(i3);
                                installBeginTime3 = installBeginTime2;
                                try {
                                    installBeginTime2 = new PackageInstalledInfo();
                                    installBeginTime2.setReturnCode(1);
                                    installBeginTime2.pkg = pkg;
                                    installBeginTime2.name = pkg.packageName;
                                    z4 = replace4;
                                    try {
                                        childPs = this.mSettings.getPackageLPr(pkg.packageName);
                                        if (childPs != null) {
                                            tmpPackageFile2 = tmpPackageFile;
                                            installBeginTime2.origUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                                        } else {
                                            tmpPackageFile2 = tmpPackageFile;
                                        }
                                        if (this.mPackages.containsKey(pkg.packageName)) {
                                            installBeginTime2.removedInfo = new PackageRemovedInfo(this);
                                            installBeginTime2.removedInfo.removedPackage = pkg.packageName;
                                            installBeginTime2.removedInfo.installerPackageName = childPs.installerPackageName;
                                        }
                                        if (packageInstalledInfo.addedChildPackages == null) {
                                            packageInstalledInfo.addedChildPackages = new ArrayMap();
                                        }
                                        packageInstalledInfo.addedChildPackages.put(pkg.packageName, installBeginTime2);
                                        i3++;
                                        childCount = childCount2;
                                        installBeginTime2 = installBeginTime3;
                                        replace4 = z4;
                                        tmpPackageFile = tmpPackageFile2;
                                    } catch (Throwable th5) {
                                        th = th5;
                                        throw th;
                                    }
                                } catch (Throwable th6) {
                                    th = th6;
                                    z4 = replace4;
                                    tmpPackageFile2 = tmpPackageFile;
                                    throw th;
                                }
                            }
                            installBeginTime3 = installBeginTime2;
                            z4 = replace4;
                            tmpPackageFile2 = tmpPackageFile;
                        } catch (Throwable th7) {
                            th = th7;
                            installBeginTime3 = installBeginTime2;
                            z4 = false;
                            tmpPackageFile2 = tmpPackageFile;
                            throw th;
                        }
                    }
                }
                installBeginTime3 = installBeginTime2;
                z4 = false;
                tmpPackageFile2 = tmpPackageFile;
                if (TextUtils.isEmpty(pp2.cpuAbiOverride)) {
                    pp2.cpuAbiOverride = installArgs.abiOverride;
                }
                str2 = pp2.packageName;
                packageInstalledInfo.name = str2;
                installBeginTime2 = str2;
                if (!isAppInstallAllowed(installerPackageName2, installBeginTime2)) {
                    str = volumeUuid2;
                    i = parseFlags;
                    installerPackageName = installerPackageName2;
                    z2 = onExternal2;
                    forwardLocked = installBeginTime3;
                    file = tmpPackageFile2;
                } else if (installArgs.origin != null && isUnAppInstallAllowed(installArgs.origin.resolvedPath)) {
                    z = forwardLocked;
                    str = volumeUuid2;
                    i = parseFlags;
                    installerPackageName = installerPackageName2;
                    z2 = onExternal2;
                    forwardLocked = installBeginTime3;
                    file = tmpPackageFile2;
                } else if ((pp2.applicationInfo.flags & 256) == 0 || (installFlags4 & 4) != 0) {
                    computeMetaHash(pp2);
                    try {
                        if (installArgs.signingDetails != SigningDetails.UNKNOWN) {
                            try {
                                pp2.setSigningDetails(installArgs.signingDetails);
                            } catch (PackageParserException e4) {
                                e = e4;
                                z = forwardLocked;
                                str = volumeUuid2;
                                i = parseFlags;
                                installerPackageName = installerPackageName2;
                                z2 = onExternal2;
                                forwardLocked = installBeginTime3;
                                file = tmpPackageFile2;
                            }
                        } else {
                            PackageParser.collectCertificates(pp2, false);
                        }
                        if (instantApp && pp2.mSigningDetails.signatureSchemeVersion < 2) {
                            str2 = TAG;
                            stringBuilder3 = new StringBuilder();
                            stringBuilder3.append("Instant app package ");
                            stringBuilder3.append(pp2.packageName);
                            stringBuilder3.append(" is not signed with at least APK Signature Scheme v2");
                            Slog.w(str2, stringBuilder3.toString());
                            packageInstalledInfo.setError(-116, "Instant app package must be signed with APK Signature Scheme v2 or greater");
                            return;
                        } else if (this.mHwPMSEx.isDisallowedInstallApk(pp2)) {
                            packageInstalledInfo.setError(-111, "PackageName is disallowd to be installed");
                            str2 = TAG;
                            stringBuilder3 = new StringBuilder();
                            stringBuilder3.append(installerPackageName2);
                            stringBuilder3.append(" is disallowed to be installed");
                            Slog.i(str2, stringBuilder3.toString());
                            return;
                        } else {
                            try {
                                if (checkUninstalledSystemApp(pp2, installArgs, packageInstalledInfo)) {
                                    try {
                                        Slog.i(TAG, "restore the uninstalled app and upgrad it");
                                        tmpPackageFile = installFlags4 | 2;
                                    } catch (PackageManagerException e5) {
                                        z = forwardLocked;
                                        str = volumeUuid2;
                                        i = parseFlags;
                                        installerPackageName = installerPackageName2;
                                        z2 = onExternal2;
                                        forwardLocked = installBeginTime3;
                                        file = tmpPackageFile2;
                                        Slog.i(TAG, "downgrade package from preset system app, just restore the uninstalled system app");
                                        return;
                                    }
                                }
                                tmpPackageFile = installFlags4;
                                synchronized (this.mPackages) {
                                    String str3;
                                    StringBuilder stringBuilder4;
                                    StringBuilder stringBuilder5;
                                    KeySetManagerService ksms;
                                    StringBuilder stringBuilder6;
                                    if ((tmpPackageFile & 2) != 0) {
                                        String str4;
                                        try {
                                            str2 = this.mSettings.getRenamedPackageLPr(installBeginTime2);
                                            if (pp2.mOriginalPackages != null) {
                                                try {
                                                    if (pp2.mOriginalPackages.contains(str2) && this.mPackages.containsKey(str2)) {
                                                        pp2.setPackageName(str2);
                                                        installBeginTime2 = pp2.packageName;
                                                        try {
                                                            if (DEBUG_INSTALL) {
                                                                oldCodePath = null;
                                                                try {
                                                                    str3 = TAG;
                                                                    systemApp = false;
                                                                    try {
                                                                        stringBuilder4 = new StringBuilder();
                                                                        replace = true;
                                                                        try {
                                                                            stringBuilder4.append("Replacing existing renamed package: oldName=");
                                                                            stringBuilder4.append(str2);
                                                                            stringBuilder4.append(" pkgName=");
                                                                            stringBuilder4.append(installBeginTime2);
                                                                            Slog.d(str3, stringBuilder4.toString());
                                                                        } catch (Throwable th8) {
                                                                            th = th8;
                                                                            z = forwardLocked;
                                                                            file2 = tmpPackageFile;
                                                                            str = volumeUuid2;
                                                                            i = parseFlags;
                                                                            installerPackageName = installerPackageName2;
                                                                            z2 = onExternal2;
                                                                            forwardLocked = installBeginTime3;
                                                                            file = tmpPackageFile2;
                                                                            str3 = oldCodePath;
                                                                            replace4 = replace;
                                                                        }
                                                                    } catch (Throwable th9) {
                                                                        th = th9;
                                                                        z = forwardLocked;
                                                                        onExternal = tmpPackageFile;
                                                                        str = volumeUuid2;
                                                                        i = parseFlags;
                                                                        installerPackageName = installerPackageName2;
                                                                        z2 = onExternal2;
                                                                        forwardLocked = installBeginTime3;
                                                                        file = tmpPackageFile2;
                                                                        str3 = oldCodePath;
                                                                        replace4 = true;
                                                                        while (true) {
                                                                            try {
                                                                                break;
                                                                            } catch (Throwable th10) {
                                                                                th = th10;
                                                                            }
                                                                        }
                                                                        throw th;
                                                                    }
                                                                } catch (Throwable th11) {
                                                                    th = th11;
                                                                    systemApp = false;
                                                                    z = forwardLocked;
                                                                    onExternal = tmpPackageFile;
                                                                    str = volumeUuid2;
                                                                    i = parseFlags;
                                                                    installerPackageName = installerPackageName2;
                                                                    z2 = onExternal2;
                                                                    forwardLocked = installBeginTime3;
                                                                    file = tmpPackageFile2;
                                                                    str3 = oldCodePath;
                                                                    replace4 = true;
                                                                    while (true) {
                                                                        break;
                                                                    }
                                                                    throw th;
                                                                }
                                                            }
                                                            oldCodePath = null;
                                                            systemApp = false;
                                                            replace = true;
                                                            str4 = str2;
                                                            replace4 = replace;
                                                        } catch (Throwable th12) {
                                                            th = th12;
                                                            oldCodePath = null;
                                                            systemApp = false;
                                                            z = forwardLocked;
                                                            onExternal = tmpPackageFile;
                                                            str = volumeUuid2;
                                                            i = parseFlags;
                                                            installerPackageName = installerPackageName2;
                                                            z2 = onExternal2;
                                                            forwardLocked = installBeginTime3;
                                                            file = tmpPackageFile2;
                                                            replace4 = true;
                                                            while (true) {
                                                                break;
                                                            }
                                                            throw th;
                                                        }
                                                        try {
                                                            if (pp2.parentPackage == null) {
                                                                stringBuilder3 = new StringBuilder();
                                                                stringBuilder3.append("Package ");
                                                                stringBuilder3.append(pp2.packageName);
                                                                stringBuilder3.append(" is child of package ");
                                                                stringBuilder3.append(pp2.parentPackage.parentPackage);
                                                                stringBuilder3.append(". Child packages can be updated only through the parent package.");
                                                                packageInstalledInfo.setError(-106, stringBuilder3.toString());
                                                                return;
                                                            }
                                                            String pkgName;
                                                            if (replace4) {
                                                                pkg = (Package) this.mPackages.get(installBeginTime2);
                                                                installFlags3 = pkg.applicationInfo.targetSdkVersion;
                                                                i3 = pp2.applicationInfo.targetSdkVersion;
                                                                replace2 = replace4;
                                                                if (installFlags3 <= true || i3 > 22) {
                                                                    volumeUuid = volumeUuid2;
                                                                    try {
                                                                        StringBuilder stringBuilder7;
                                                                        if ((pkg.applicationInfo.flags & 8) != 0) {
                                                                            if (!this.mHwPMSEx.isPersistentUpdatable(pp2)) {
                                                                                stringBuilder7 = new StringBuilder();
                                                                                stringBuilder7.append("Package ");
                                                                                stringBuilder7.append(pkg.packageName);
                                                                                stringBuilder7.append(" is a persistent app. Persistent apps are not updateable.");
                                                                                packageInstalledInfo.setError(-2, stringBuilder7.toString());
                                                                                return;
                                                                            }
                                                                        }
                                                                        if (pkg.parentPackage != null) {
                                                                            stringBuilder7 = new StringBuilder();
                                                                            stringBuilder7.append("Package ");
                                                                            stringBuilder7.append(pp2.packageName);
                                                                            stringBuilder7.append(" is child of package ");
                                                                            stringBuilder7.append(pkg.parentPackage);
                                                                            stringBuilder7.append(". Child packages can be updated only through the parent package.");
                                                                            packageInstalledInfo.setError(-106, stringBuilder7.toString());
                                                                            return;
                                                                        } else if (!isSystemApp(pkg) || installBeginTime2 == null || installBeginTime2.equals(this.mRequiredVerifierPackage) || installBeginTime2.equals(this.mRequiredInstallerPackage) || installBeginTime2.equals(this.mRequiredUninstallerPackage)) {
                                                                            pkgName = installBeginTime2;
                                                                        } else {
                                                                            int oldTargetSdk;
                                                                            Iterator it = pp2.activities.iterator();
                                                                            while (it.hasNext()) {
                                                                                Iterator it2;
                                                                                Package oldPackage = pkg;
                                                                                pkg = ((Activity) it.next()).intents.iterator();
                                                                                while (pkg.hasNext()) {
                                                                                    Package packageR = pkg;
                                                                                    pkgName = installBeginTime2;
                                                                                    installBeginTime2 = (ActivityIntentInfo) pkg.next();
                                                                                    try {
                                                                                        pkg = installBeginTime2.matchAction("android.intent.action.INSTALL_PACKAGE");
                                                                                        oldTargetSdk = installFlags3;
                                                                                        boolean hasDefaultCategory = installBeginTime2.hasCategory("android.intent.category.DEFAULT");
                                                                                        it2 = it;
                                                                                        replace4 = installBeginTime2.hasDataType(PACKAGE_MIME_TYPE);
                                                                                        boolean hasInstallAction;
                                                                                        if (pkg != null && hasDefaultCategory && replace4) {
                                                                                            hasInstallAction = pkg;
                                                                                            packageInstalledInfo.setError((int) true, "Detect dangerous App, may cause system problem!");
                                                                                            packageInstalledInfo.origPackage = this.mRequiredInstallerPackage;
                                                                                            return;
                                                                                        }
                                                                                        hasInstallAction = pkg;
                                                                                        boolean z5 = replace4;
                                                                                        pkg = installBeginTime2.matchAction("android.intent.action.UNINSTALL_PACKAGE");
                                                                                        replace4 = installBeginTime2.hasDataScheme("package");
                                                                                        if (pkg != null && hasDefaultCategory && replace4) {
                                                                                            boolean hasUninstallAction = pkg;
                                                                                            ActivityIntentInfo filter = installBeginTime2;
                                                                                            packageInstalledInfo.setError((int) -112, "Detect dangerous App, may cause system problem!");
                                                                                            packageInstalledInfo.origPackage = this.mRequiredUninstallerPackage;
                                                                                            return;
                                                                                        }
                                                                                        pkg = packageR;
                                                                                        installBeginTime2 = pkgName;
                                                                                        installFlags3 = oldTargetSdk;
                                                                                        it = it2;
                                                                                    } catch (Throwable th13) {
                                                                                        th = th13;
                                                                                        z = forwardLocked;
                                                                                        file2 = tmpPackageFile;
                                                                                        i = parseFlags;
                                                                                        installerPackageName = installerPackageName2;
                                                                                        z2 = onExternal2;
                                                                                        forwardLocked = installBeginTime3;
                                                                                        file = tmpPackageFile2;
                                                                                        str3 = oldCodePath;
                                                                                        replace4 = replace2;
                                                                                        str = volumeUuid;
                                                                                        installBeginTime2 = pkgName;
                                                                                        while (true) {
                                                                                            break;
                                                                                        }
                                                                                        throw th;
                                                                                    }
                                                                                }
                                                                                pkgName = installBeginTime2;
                                                                                oldTargetSdk = installFlags3;
                                                                                it2 = it;
                                                                                pkg = oldPackage;
                                                                            }
                                                                            pkgName = installBeginTime2;
                                                                            oldTargetSdk = installFlags3;
                                                                            Iterator it3 = pp2.receivers.iterator();
                                                                            while (it3.hasNext() != null) {
                                                                                Iterator it4;
                                                                                installBeginTime2 = (Activity) it3.next();
                                                                                Iterator it5 = installBeginTime2.intents.iterator();
                                                                                while (it5.hasNext()) {
                                                                                    ActivityIntentInfo filter2 = (ActivityIntentInfo) it5.next();
                                                                                    volumeUuid2 = filter2.matchAction("android.intent.action.PACKAGE_NEEDS_VERIFICATION");
                                                                                    it4 = it3;
                                                                                    z3 = filter2.hasDataType(PACKAGE_MIME_TYPE);
                                                                                    if (volumeUuid2 == null || !z3) {
                                                                                        it3 = it4;
                                                                                        installBeginTime2 = installBeginTime2;
                                                                                    } else {
                                                                                        Activity a = installBeginTime2;
                                                                                        packageInstalledInfo.setError((int) -112, "Detect dangerous App, may cause system problem!");
                                                                                        packageInstalledInfo.origPackage = this.mRequiredVerifierPackage;
                                                                                        return;
                                                                                    }
                                                                                }
                                                                                it4 = it3;
                                                                            }
                                                                        }
                                                                    } catch (Throwable th14) {
                                                                        th = th14;
                                                                        obj = installBeginTime2;
                                                                        z = forwardLocked;
                                                                        file2 = tmpPackageFile;
                                                                        i = parseFlags;
                                                                        installerPackageName = installerPackageName2;
                                                                        z2 = onExternal2;
                                                                        forwardLocked = installBeginTime3;
                                                                        file = tmpPackageFile2;
                                                                        str3 = oldCodePath;
                                                                        str = volumeUuid;
                                                                        while (true) {
                                                                            break;
                                                                        }
                                                                        throw th;
                                                                    }
                                                                }
                                                                try {
                                                                    stringBuilder4 = new StringBuilder();
                                                                    volumeUuid = volumeUuid2;
                                                                    try {
                                                                        stringBuilder4.append("Package ");
                                                                        stringBuilder4.append(pp2.packageName);
                                                                        stringBuilder4.append(" new target SDK ");
                                                                        stringBuilder4.append(i3);
                                                                        stringBuilder4.append(" doesn't support runtime permissions but the old target SDK ");
                                                                        stringBuilder4.append(installFlags3);
                                                                        stringBuilder4.append(" does.");
                                                                        packageInstalledInfo.setError(-26, stringBuilder4.toString());
                                                                        return;
                                                                    } catch (Throwable th15) {
                                                                        th = th15;
                                                                        z = forwardLocked;
                                                                        file2 = tmpPackageFile;
                                                                        i = parseFlags;
                                                                        installerPackageName = installerPackageName2;
                                                                        z2 = onExternal2;
                                                                        forwardLocked = installBeginTime3;
                                                                        file = tmpPackageFile2;
                                                                        str3 = oldCodePath;
                                                                        replace4 = replace2;
                                                                        while (true) {
                                                                            break;
                                                                        }
                                                                        throw th;
                                                                    }
                                                                } catch (Throwable th16) {
                                                                    th = th16;
                                                                    z = forwardLocked;
                                                                    file2 = tmpPackageFile;
                                                                    str = volumeUuid2;
                                                                    i = parseFlags;
                                                                    installerPackageName = installerPackageName2;
                                                                    z2 = onExternal2;
                                                                    forwardLocked = installBeginTime3;
                                                                    file = tmpPackageFile2;
                                                                    str3 = oldCodePath;
                                                                    replace4 = replace2;
                                                                    while (true) {
                                                                        break;
                                                                    }
                                                                    throw th;
                                                                }
                                                            }
                                                            pkgName = installBeginTime2;
                                                            replace2 = replace4;
                                                            volumeUuid = volumeUuid2;
                                                            onExternal = replace2;
                                                            volumeUuid2 = pkgName;
                                                        } catch (Throwable th17) {
                                                            th = th17;
                                                            obj = installBeginTime2;
                                                            replace2 = replace4;
                                                            z = forwardLocked;
                                                            file2 = tmpPackageFile;
                                                            str = volumeUuid2;
                                                            i = parseFlags;
                                                            installerPackageName = installerPackageName2;
                                                            z2 = onExternal2;
                                                            forwardLocked = installBeginTime3;
                                                            file = tmpPackageFile2;
                                                            str3 = oldCodePath;
                                                            while (true) {
                                                                break;
                                                            }
                                                            throw th;
                                                        }
                                                    }
                                                } catch (Throwable th18) {
                                                    th = th18;
                                                    oldCodePath = null;
                                                    systemApp = false;
                                                    z = forwardLocked;
                                                    file2 = tmpPackageFile;
                                                    str = volumeUuid2;
                                                    i = parseFlags;
                                                    installerPackageName = installerPackageName2;
                                                    z2 = onExternal2;
                                                    forwardLocked = installBeginTime3;
                                                    replace4 = z4;
                                                    file = tmpPackageFile2;
                                                    while (true) {
                                                        break;
                                                    }
                                                    throw th;
                                                }
                                            }
                                            oldCodePath = null;
                                            systemApp = false;
                                        } catch (Throwable th19) {
                                            th = th19;
                                            oldCodePath = null;
                                            systemApp = false;
                                            z = forwardLocked;
                                            file2 = tmpPackageFile;
                                            str = volumeUuid2;
                                            i = parseFlags;
                                            installerPackageName = installerPackageName2;
                                            z2 = onExternal2;
                                            forwardLocked = installBeginTime3;
                                            replace4 = z4;
                                            file = tmpPackageFile2;
                                            while (true) {
                                                break;
                                            }
                                            throw th;
                                        }
                                        try {
                                            if (this.mPackages.containsKey(installBeginTime2)) {
                                                replace4 = true;
                                                try {
                                                    if (DEBUG_INSTALL) {
                                                        str3 = TAG;
                                                        stringBuilder5 = new StringBuilder();
                                                        stringBuilder5.append("Replace existing pacakge: ");
                                                        stringBuilder5.append(installBeginTime2);
                                                        Slog.d(str3, stringBuilder5.toString());
                                                    }
                                                } catch (Throwable th20) {
                                                    th = th20;
                                                    z = forwardLocked;
                                                    file2 = tmpPackageFile;
                                                    str = volumeUuid2;
                                                    i = parseFlags;
                                                    installerPackageName = installerPackageName2;
                                                    z2 = onExternal2;
                                                    forwardLocked = installBeginTime3;
                                                    file = tmpPackageFile2;
                                                    str3 = oldCodePath;
                                                    while (true) {
                                                        break;
                                                    }
                                                    throw th;
                                                }
                                            }
                                            str4 = str2;
                                            replace4 = z4;
                                            if (pp2.parentPackage == null) {
                                            }
                                        } catch (Throwable th21) {
                                            th = th21;
                                            i3 = tmpPackageFile;
                                            forwardLocked = installBeginTime3;
                                            replace4 = z4;
                                            while (true) {
                                                break;
                                            }
                                            throw th;
                                        }
                                    }
                                    oldCodePath = null;
                                    systemApp = false;
                                    volumeUuid = volumeUuid2;
                                    volumeUuid2 = installBeginTime2;
                                    onExternal = z4;
                                    try {
                                        installBeginTime2 = (PackageSetting) this.mSettings.mPackages.get(volumeUuid2);
                                        this.mHwPMSEx.checkHwCertification(pp2, true);
                                        replaceSignatureIfNeeded(installBeginTime2, pp2, false, true);
                                        if (installBeginTime2 != null) {
                                            try {
                                                if (DEBUG_INSTALL) {
                                                    try {
                                                        str2 = TAG;
                                                        stringBuilder3 = new StringBuilder();
                                                        stringBuilder3.append("Existing package: ");
                                                        stringBuilder3.append(installBeginTime2);
                                                        Slog.d(str2, stringBuilder3.toString());
                                                    } catch (Throwable th22) {
                                                        th = th22;
                                                        z = forwardLocked;
                                                        onExternal = tmpPackageFile;
                                                        installBeginTime2 = volumeUuid2;
                                                        i = parseFlags;
                                                    }
                                                }
                                                PackageSetting signatureCheckPs = installBeginTime2;
                                                if (pp2.applicationInfo.isStaticSharedLibrary()) {
                                                    SharedLibraryEntry libraryEntry = getLatestSharedLibraVersionLPr(pp2);
                                                    if (libraryEntry != null) {
                                                        childPs = this.mSettings.getPackageLPr(libraryEntry.apk);
                                                        ksms = this.mSettings.mKeySetManagerService;
                                                        int installFlags5;
                                                        if (ksms.shouldCheckUpgradeKeySetLocked(childPs, scanFlags2)) {
                                                            i = parseFlags;
                                                            try {
                                                                replace3 = onExternal;
                                                                installFlags5 = tmpPackageFile;
                                                                try {
                                                                    if (PackageManagerServiceUtils.verifySignatures(childPs, false, pp2.mSigningDetails, isCompatSignatureUpdateNeeded(pp2), isRecoverSignatureUpdateNeeded(pp2))) {
                                                                        try {
                                                                            synchronized (this.mPackages) {
                                                                                ksms.removeAppKeySetDataLPw(pp2.packageName);
                                                                            }
                                                                        } catch (PackageManagerException e6) {
                                                                            e2 = e6;
                                                                        }
                                                                    }
                                                                } catch (PackageManagerException e7) {
                                                                    e2 = e7;
                                                                    packageSetting = childPs;
                                                                    try {
                                                                        if (installBeginTime2.sharedUser == null || !isSystemSignatureUpdated(installBeginTime2.signatures.mSigningDetails.signatures, pp2.mSigningDetails.signatures)) {
                                                                            packageInstalledInfo.setError(e2.error, e2.getMessage());
                                                                            return;
                                                                        }
                                                                        str3 = TAG;
                                                                        stringBuilder5 = new StringBuilder();
                                                                        stringBuilder5.append("CertCompat: ");
                                                                        stringBuilder5.append(pp2.packageName);
                                                                        stringBuilder5.append(" system signature updated. Update signatures.");
                                                                        Slog.i(str3, stringBuilder5.toString());
                                                                        installBeginTime2.signatures.mSigningDetails = pp2.mSigningDetails;
                                                                        if (SystemProperties.get("ro.config.hw_optb", "0").equals("156") != null) {
                                                                        }
                                                                        oldCodePath2 = ((PackageSetting) this.mSettings.mPackages.get(volumeUuid2)).codePathString;
                                                                        if ((installBeginTime2.pkg.applicationInfo.flags & 1) != null) {
                                                                        }
                                                                        systemApp = (installBeginTime2.pkg.applicationInfo.flags & 1) != null ? true : null;
                                                                        packageInstalledInfo.origUsers = installBeginTime2.queryInstalledUsers(sUserManager.getUserIds(), 1);
                                                                        parseFlags = oldCodePath2;
                                                                        childCount = pp2.permissions.size();
                                                                        installFlags3 = childCount - 1;
                                                                        while (installFlags3 >= 0) {
                                                                        }
                                                                        installerPackageName = installerPackageName2;
                                                                        try {
                                                                            if (systemApp) {
                                                                                if (onExternal2) {
                                                                                    packageInstalledInfo.setError(-19, "Cannot install updates to system apps on sdcard");
                                                                                    return;
                                                                                } else if (instantApp) {
                                                                                    packageInstalledInfo.setError((int) -116, "Cannot update a system app with an instant app");
                                                                                    return;
                                                                                }
                                                                            }
                                                                            InstallerMgr.getInstance().installPackage(0, installArgs.installerPackageName, volumeUuid2);
                                                                            String str5;
                                                                            StringBuilder stringBuilder8;
                                                                            if (installArgs.move != null) {
                                                                                installBeginTime2 = (scanFlags2 | 1) | 256;
                                                                                synchronized (this.mPackages) {
                                                                                    signatureCheckPs = (PackageSetting) this.mSettings.mPackages.get(volumeUuid2);
                                                                                    if (signatureCheckPs == null) {
                                                                                        stringBuilder4 = new StringBuilder();
                                                                                        stringBuilder4.append("Missing settings for moved package ");
                                                                                        stringBuilder4.append(volumeUuid2);
                                                                                        packageInstalledInfo.setError((int) RequestStatus.SYS_ETIMEDOUT, stringBuilder4.toString());
                                                                                    }
                                                                                    pp2.applicationInfo.primaryCpuAbi = signatureCheckPs.primaryCpuAbiString;
                                                                                    pp2.applicationInfo.secondaryCpuAbi = signatureCheckPs.secondaryCpuAbiString;
                                                                                    str5 = TAG;
                                                                                    stringBuilder8 = new StringBuilder();
                                                                                    stringBuilder8.append("installPackageLI-> install move case, pkg=");
                                                                                    stringBuilder8.append(pp2);
                                                                                    stringBuilder8.append(", primaryCpuAbi=");
                                                                                    stringBuilder8.append(pp2.applicationInfo.primaryCpuAbi);
                                                                                    Slog.d(str5, stringBuilder8.toString());
                                                                                }
                                                                            } else if (forwardLocked || pp2.applicationInfo.isExternalAsec()) {
                                                                                scanFlags = scanFlags2;
                                                                                if (this.mCustPms != null && this.mCustPms.needDerivePkgAbi(pp2)) {
                                                                                    derivePackageAbi(pp2, installArgs.abiOverride, 1);
                                                                                }
                                                                                if (installArgs.doRename(packageInstalledInfo.returnCode, pp2, parseFlags)) {
                                                                                    packageInstalledInfo.setError(-4, "Failed rename");
                                                                                    return;
                                                                                }
                                                                                if (PackageManagerServiceUtils.isApkVerityEnabled()) {
                                                                                    installBeginTime2 = null;
                                                                                    synchronized (this.mPackages) {
                                                                                        signatureCheckPs = (PackageSetting) this.mSettings.mPackages.get(volumeUuid2);
                                                                                        if (signatureCheckPs != null && signatureCheckPs.isPrivileged()) {
                                                                                            installBeginTime2 = pp2.baseCodePath;
                                                                                        }
                                                                                    }
                                                                                    if (installBeginTime2 != null) {
                                                                                        SetupResult result = VerityUtils.generateApkVeritySetupData(installBeginTime2);
                                                                                        if (result.isOk()) {
                                                                                            if (Build.IS_DEBUGGABLE) {
                                                                                                str2 = TAG;
                                                                                                stringBuilder4 = new StringBuilder();
                                                                                                stringBuilder4.append("Enabling apk verity to ");
                                                                                                stringBuilder4.append(installBeginTime2);
                                                                                                Slog.i(str2, stringBuilder4.toString());
                                                                                            }
                                                                                            FileDescriptor fd = result.getUnownedFileDescriptor();
                                                                                            try {
                                                                                                byte[] signedRootHash = VerityUtils.generateFsverityRootHash(installBeginTime2);
                                                                                                this.mInstaller.installApkVerity(installBeginTime2, fd, result.getContentSize());
                                                                                                this.mInstaller.assertFsverityRootHashMatches(installBeginTime2, signedRootHash);
                                                                                            } catch (InstallerException | IOException | DigestException | NoSuchAlgorithmException e8) {
                                                                                                stringBuilder8 = new StringBuilder();
                                                                                                stringBuilder8.append("Failed to set up verity: ");
                                                                                                stringBuilder8.append(e8);
                                                                                                packageInstalledInfo.setError((int) RequestStatus.SYS_ETIMEDOUT, stringBuilder8.toString());
                                                                                                return;
                                                                                            } finally {
                                                                                                IoUtils.closeQuietly(fd);
                                                                                            }
                                                                                        } else if (result.isFailed()) {
                                                                                            packageInstalledInfo.setError((int) RequestStatus.SYS_ETIMEDOUT, "Failed to generate verity");
                                                                                            return;
                                                                                        }
                                                                                    }
                                                                                }
                                                                                if (instantApp) {
                                                                                    onExternal = replace3;
                                                                                    if (DEBUG_DOMAIN_VERIFICATION) {
                                                                                        str2 = TAG;
                                                                                        installBeginTime2 = new StringBuilder();
                                                                                        installBeginTime2.append("Not verifying instant app install for app links: ");
                                                                                        installBeginTime2.append(volumeUuid2);
                                                                                        Slog.d(str2, installBeginTime2.toString());
                                                                                    }
                                                                                } else {
                                                                                    onExternal = replace3;
                                                                                    startIntentFilterVerifications(installArgs.user.getIdentifier(), onExternal, pp2);
                                                                                }
                                                                                tmpPackageFile = installFlags;
                                                                                PackageFreezer freezer = freezePackageForInstall(volumeUuid2, tmpPackageFile, "installPackageLI");
                                                                                if (onExternal) {
                                                                                    try {
                                                                                        if (pp2.applicationInfo.isStaticSharedLibrary()) {
                                                                                            try {
                                                                                                pkg = (Package) this.mPackages.get(pp2.packageName);
                                                                                                if (!(pkg == null || pkg.getLongVersionCode() == pp2.getLongVersionCode())) {
                                                                                                    packageInstalledInfo.setError((int) -5, "Packages declaring static-shared libs cannot be updated");
                                                                                                    if (freezer != null) {
                                                                                                        $closeResource(null, freezer);
                                                                                                    }
                                                                                                    return;
                                                                                                }
                                                                                            } catch (Throwable th23) {
                                                                                                th = th23;
                                                                                                th2 = null;
                                                                                                z4 = onExternal;
                                                                                                z = forwardLocked;
                                                                                                onExternal = tmpPackageFile;
                                                                                                String oldCodePath3 = parseFlags;
                                                                                                z2 = onExternal2;
                                                                                                forwardLocked = installBeginTime3;
                                                                                                file = tmpPackageFile2;
                                                                                                str = volumeUuid;
                                                                                                parseFlags = freezer;
                                                                                                scanFlags = volumeUuid2;
                                                                                                if (parseFlags != 0) {
                                                                                                }
                                                                                                throw th;
                                                                                            }
                                                                                        }
                                                                                        installBeginTime = installBeginTime3;
                                                                                        obj2 = parseFlags;
                                                                                        parseFlags = null;
                                                                                        parseFlags = freezer;
                                                                                        z4 = onExternal;
                                                                                        z2 = onExternal2;
                                                                                        z = forwardLocked;
                                                                                        installFlags2 = tmpPackageFile;
                                                                                        file = tmpPackageFile2;
                                                                                    } catch (Throwable th24) {
                                                                                        th = th24;
                                                                                        z4 = onExternal;
                                                                                        z = forwardLocked;
                                                                                        obj2 = parseFlags;
                                                                                        z2 = onExternal2;
                                                                                        file = tmpPackageFile2;
                                                                                        parseFlags = freezer;
                                                                                        onExternal = tmpPackageFile;
                                                                                        i2 = scanFlags;
                                                                                        forwardLocked = installBeginTime3;
                                                                                        str = volumeUuid;
                                                                                        th2 = null;
                                                                                        scanFlags = volumeUuid2;
                                                                                        if (parseFlags != 0) {
                                                                                            $closeResource(th2, parseFlags);
                                                                                        }
                                                                                        throw th;
                                                                                    }
                                                                                    try {
                                                                                        replacePackageLIF(pp2, i, scanFlags, installArgs.user, installerPackageName, packageInstalledInfo, installArgs.installReason);
                                                                                        i2 = scanFlags;
                                                                                        str = volumeUuid;
                                                                                        scanFlags = volumeUuid2;
                                                                                    } catch (Throwable th25) {
                                                                                        th = th25;
                                                                                        i2 = scanFlags;
                                                                                        str = volumeUuid;
                                                                                        forwardLocked = installBeginTime;
                                                                                        i3 = installFlags2;
                                                                                        th2 = null;
                                                                                        scanFlags = volumeUuid2;
                                                                                        if (parseFlags != 0) {
                                                                                        }
                                                                                        throw th;
                                                                                    }
                                                                                }
                                                                                z = forwardLocked;
                                                                                installFlags2 = tmpPackageFile;
                                                                                obj2 = parseFlags;
                                                                                z2 = onExternal2;
                                                                                installBeginTime = installBeginTime3;
                                                                                file = tmpPackageFile2;
                                                                                parseFlags = freezer;
                                                                                scanFlags2 = scanFlags | 64;
                                                                                try {
                                                                                    i2 = scanFlags;
                                                                                    str = volumeUuid;
                                                                                    scanFlags = volumeUuid2;
                                                                                    try {
                                                                                        installNewPackageLIF(pp2, i, scanFlags2, installArgs.user, installerPackageName, volumeUuid, packageInstalledInfo, installArgs.installReason);
                                                                                    } catch (Throwable th26) {
                                                                                        th = th26;
                                                                                        forwardLocked = installBeginTime;
                                                                                        i3 = installFlags2;
                                                                                        th2 = 0;
                                                                                        if (parseFlags != 0) {
                                                                                        }
                                                                                        throw th;
                                                                                    }
                                                                                } catch (Throwable th27) {
                                                                                    th = th27;
                                                                                    i2 = scanFlags;
                                                                                    str = volumeUuid;
                                                                                    forwardLocked = installBeginTime;
                                                                                    i3 = installFlags2;
                                                                                    scanFlags = volumeUuid2;
                                                                                    th2 = 0;
                                                                                    if (parseFlags != 0) {
                                                                                    }
                                                                                    throw th;
                                                                                }
                                                                                if (parseFlags != 0) {
                                                                                    $closeResource(0, parseFlags);
                                                                                }
                                                                                HwFrameworkFactory.getHwBehaviorCollectManager().sendEvent(1, pp2.applicationInfo.uid, 0, pp2.packageName, installArgs.installerPackageName);
                                                                                this.mArtManagerService.prepareAppProfiles(pp2, resolveUserIds(installArgs.user.getIdentifier()));
                                                                                z3 = packageInstalledInfo.returnCode == 1 && !z && !pp2.applicationInfo.isExternalAsec() && (!(instantApp && Global.getInt(this.mContext.getContentResolver(), "instant_app_dexopt_enabled", 0) == 0) && (pp2.applicationInfo.flags & 2) == 0);
                                                                                if (z3) {
                                                                                    Trace.traceBegin(262144, "dexopt");
                                                                                    this.mPackageDexOptimizer.performDexOpt(pp2, pp2.usesLibraryFiles, null, getOrCreateCompilerPackageStats(pp2), this.mDexManager.getPackageUseInfoOrDefault(pp2.packageName), new DexoptOptions(pp2.packageName, 2, (int) UsbTerminalTypes.TERMINAL_BIDIR_SKRPHONE_SUPRESS));
                                                                                    Trace.traceEnd(262144);
                                                                                }
                                                                                BackgroundDexOptService.notifyPackageChanged(pp2.packageName);
                                                                                synchronized (this.mPackages) {
                                                                                    signatureCheckPs = (PackageSetting) this.mSettings.mPackages.get(scanFlags);
                                                                                    if (signatureCheckPs != null) {
                                                                                        try {
                                                                                            packageInstalledInfo.newUsers = signatureCheckPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                                                                                            signatureCheckPs.setUpdateAvailable(0);
                                                                                        } catch (Throwable th28) {
                                                                                            th = th28;
                                                                                            forwardLocked = installBeginTime;
                                                                                            i3 = installFlags2;
                                                                                        }
                                                                                    }
                                                                                    try {
                                                                                        if (packageInstalledInfo.returnCode == 1) {
                                                                                            installBeginTime2 = null;
                                                                                            writeCertCompatPackages(false);
                                                                                        } else {
                                                                                            installBeginTime2 = null;
                                                                                        }
                                                                                        scanFlags2 = pp2.childPackages != null ? pp2.childPackages.size() : installBeginTime2;
                                                                                        while (installBeginTime2 < scanFlags2) {
                                                                                            Package childPkg = (Package) pp2.childPackages.get(installBeginTime2);
                                                                                            PackageInstalledInfo childRes = (PackageInstalledInfo) packageInstalledInfo.addedChildPackages.get(childPkg.packageName);
                                                                                            forwardLocked = this.mSettings.getPackageLPr(childPkg.packageName);
                                                                                            if (forwardLocked) {
                                                                                                childRes.newUsers = forwardLocked.queryInstalledUsers(sUserManager.getUserIds(), true);
                                                                                            }
                                                                                            installBeginTime2++;
                                                                                        }
                                                                                        if (packageInstalledInfo.returnCode == 1) {
                                                                                            updateSequenceNumberLP(signatureCheckPs, packageInstalledInfo.newUsers);
                                                                                            updateInstantAppInstallerLocked(scanFlags);
                                                                                        }
                                                                                    } catch (Throwable th29) {
                                                                                        th = th29;
                                                                                        forwardLocked = installBeginTime;
                                                                                        i3 = installFlags2;
                                                                                        while (true) {
                                                                                            try {
                                                                                                break;
                                                                                            } catch (Throwable th30) {
                                                                                                th = th30;
                                                                                            }
                                                                                        }
                                                                                        throw th;
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                installBeginTime2 = scanFlags2 | 1;
                                                                                try {
                                                                                    derivePackageAbi(pp2, TextUtils.isEmpty(pp2.cpuAbiOverride) ? installArgs.abiOverride : pp2.cpuAbiOverride, pp2.isLibrary() ^ true);
                                                                                    str5 = TAG;
                                                                                    stringBuilder8 = new StringBuilder();
                                                                                    stringBuilder8.append("installPackageLI-> install derivePackageAbi case, pkg=");
                                                                                    stringBuilder8.append(pp2);
                                                                                    stringBuilder8.append(", primaryCpuAbi=");
                                                                                    stringBuilder8.append(pp2.applicationInfo.primaryCpuAbi);
                                                                                    Slog.d(str5, stringBuilder8.toString());
                                                                                    synchronized (this.mPackages) {
                                                                                        try {
                                                                                            updateSharedLibrariesLPr(pp2, null);
                                                                                        } catch (PackageManagerException e22) {
                                                                                            PackageManagerException packageManagerException = e22;
                                                                                            str5 = TAG;
                                                                                            stringBuilder8 = new StringBuilder();
                                                                                            stringBuilder8.append("updateAllSharedLibrariesLPw failed: ");
                                                                                            stringBuilder8.append(e22.getMessage());
                                                                                            Slog.e(str5, stringBuilder8.toString());
                                                                                        }
                                                                                    }
                                                                                } catch (PackageManagerException e222) {
                                                                                    Slog.e(TAG, "Error deriving application ABI", e222);
                                                                                    packageInstalledInfo.setError((int) RequestStatus.SYS_ETIMEDOUT, "Error deriving application ABI");
                                                                                    return;
                                                                                }
                                                                            }
                                                                            scanFlags = installBeginTime2;
                                                                            try {
                                                                                derivePackageAbi(pp2, installArgs.abiOverride, 1);
                                                                                if (installArgs.doRename(packageInstalledInfo.returnCode, pp2, parseFlags)) {
                                                                                }
                                                                            } catch (PackageManagerException e2222) {
                                                                                Slog.e(TAG, "Error deriving application ABI install app to sdcard", e2222);
                                                                                packageInstalledInfo.setError((int) RequestStatus.SYS_ETIMEDOUT, "Error deriving application ABI");
                                                                                return;
                                                                            }
                                                                        } catch (Throwable th31) {
                                                                            th = th31;
                                                                            z = forwardLocked;
                                                                            z2 = onExternal2;
                                                                            forwardLocked = installBeginTime3;
                                                                            file = tmpPackageFile2;
                                                                            str = volumeUuid;
                                                                            i3 = installFlags;
                                                                            installBeginTime2 = volumeUuid2;
                                                                            replace4 = replace3;
                                                                            obj3 = parseFlags;
                                                                            while (true) {
                                                                                break;
                                                                            }
                                                                            throw th;
                                                                        }
                                                                    } catch (PackageManagerException e22222) {
                                                                        packageInstalledInfo.setError(e22222.error, e22222.getMessage());
                                                                        return;
                                                                    } catch (Throwable th32) {
                                                                        th = th32;
                                                                        z = forwardLocked;
                                                                        installBeginTime2 = volumeUuid2;
                                                                        installerPackageName = installerPackageName2;
                                                                        z2 = onExternal2;
                                                                        forwardLocked = installBeginTime3;
                                                                        file = tmpPackageFile2;
                                                                        str3 = oldCodePath;
                                                                        ksms = replace3;
                                                                        while (true) {
                                                                            break;
                                                                        }
                                                                        throw th;
                                                                    }
                                                                }
                                                            } catch (PackageManagerException e9) {
                                                                e22222 = e9;
                                                                packageSetting = childPs;
                                                                replace3 = onExternal;
                                                                installFlags5 = tmpPackageFile;
                                                                if (installBeginTime2.sharedUser == null) {
                                                                }
                                                                packageInstalledInfo.setError(e22222.error, e22222.getMessage());
                                                                return;
                                                            } catch (Throwable th33) {
                                                                th = th33;
                                                                replace3 = onExternal;
                                                                z = forwardLocked;
                                                                onExternal = tmpPackageFile;
                                                                installBeginTime2 = volumeUuid2;
                                                                installerPackageName = installerPackageName2;
                                                                z2 = onExternal2;
                                                                forwardLocked = installBeginTime3;
                                                                file = tmpPackageFile2;
                                                                str3 = oldCodePath;
                                                                str = volumeUuid;
                                                                replace4 = replace3;
                                                                while (true) {
                                                                    break;
                                                                }
                                                                throw th;
                                                            }
                                                        }
                                                        try {
                                                            if (ksms.checkUpgradeKeySetLocked(childPs, pp2)) {
                                                                i = parseFlags;
                                                                packageSetting = childPs;
                                                                replace3 = onExternal;
                                                                installFlags5 = tmpPackageFile;
                                                            } else {
                                                                stringBuilder6 = new StringBuilder();
                                                                i = parseFlags;
                                                                try {
                                                                    stringBuilder6.append("Package ");
                                                                    stringBuilder6.append(pp2.packageName);
                                                                    stringBuilder6.append(" upgrade keys do not match the previously installed version");
                                                                    packageInstalledInfo.setError(-7, stringBuilder6.toString());
                                                                    return;
                                                                } catch (Throwable th34) {
                                                                    th = th34;
                                                                    replace4 = onExternal;
                                                                    z = forwardLocked;
                                                                    onExternal = tmpPackageFile;
                                                                    installBeginTime2 = volumeUuid2;
                                                                    forwardLocked = installBeginTime3;
                                                                    while (true) {
                                                                        break;
                                                                    }
                                                                    throw th;
                                                                }
                                                            }
                                                        } catch (Throwable th35) {
                                                            th = th35;
                                                            i = parseFlags;
                                                            replace4 = onExternal;
                                                            z = forwardLocked;
                                                            onExternal = tmpPackageFile;
                                                            installBeginTime2 = volumeUuid2;
                                                            installerPackageName = installerPackageName2;
                                                            z2 = onExternal2;
                                                            forwardLocked = installBeginTime3;
                                                            file = tmpPackageFile2;
                                                            str3 = oldCodePath;
                                                            str = volumeUuid;
                                                            while (true) {
                                                                break;
                                                            }
                                                            throw th;
                                                        }
                                                        if (SystemProperties.get("ro.config.hw_optb", "0").equals("156") != null) {
                                                            verifyValidVerifierInstall(installerPackageName2, volumeUuid2, installArgs.user.getIdentifier(), Binder.getCallingUid());
                                                        }
                                                        oldCodePath2 = ((PackageSetting) this.mSettings.mPackages.get(volumeUuid2)).codePathString;
                                                        if (!(installBeginTime2.pkg == null || installBeginTime2.pkg.applicationInfo == null)) {
                                                            systemApp = (installBeginTime2.pkg.applicationInfo.flags & 1) != null ? true : null;
                                                        }
                                                        packageInstalledInfo.origUsers = installBeginTime2.queryInstalledUsers(sUserManager.getUserIds(), 1);
                                                        parseFlags = oldCodePath2;
                                                    }
                                                }
                                                childPs = signatureCheckPs;
                                                ksms = this.mSettings.mKeySetManagerService;
                                                if (ksms.shouldCheckUpgradeKeySetLocked(childPs, scanFlags2)) {
                                                }
                                                if (SystemProperties.get("ro.config.hw_optb", "0").equals("156") != null) {
                                                }
                                                oldCodePath2 = ((PackageSetting) this.mSettings.mPackages.get(volumeUuid2)).codePathString;
                                            } catch (Throwable th36) {
                                                th = th36;
                                                replace3 = onExternal;
                                                i = parseFlags;
                                                z = forwardLocked;
                                                onExternal = tmpPackageFile;
                                                installBeginTime2 = volumeUuid2;
                                                installerPackageName = installerPackageName2;
                                                z2 = onExternal2;
                                                forwardLocked = installBeginTime3;
                                                file = tmpPackageFile2;
                                                str3 = oldCodePath;
                                                str = volumeUuid;
                                                replace4 = replace3;
                                                while (true) {
                                                    break;
                                                }
                                                throw th;
                                            }
                                            try {
                                                if ((installBeginTime2.pkg.applicationInfo.flags & 1) != null) {
                                                }
                                                systemApp = (installBeginTime2.pkg.applicationInfo.flags & 1) != null ? true : null;
                                                packageInstalledInfo.origUsers = installBeginTime2.queryInstalledUsers(sUserManager.getUserIds(), 1);
                                                parseFlags = oldCodePath2;
                                            } catch (Throwable th37) {
                                                th = th37;
                                                z = forwardLocked;
                                                installBeginTime2 = volumeUuid2;
                                                forwardLocked = installBeginTime3;
                                                ksms = replace3;
                                                while (true) {
                                                    break;
                                                }
                                                throw th;
                                            }
                                        }
                                        replace3 = onExternal;
                                        installFlags = tmpPackageFile;
                                        i = parseFlags;
                                        parseFlags = oldCodePath;
                                    } catch (Throwable th38) {
                                        th = th38;
                                        z4 = onExternal;
                                        z = forwardLocked;
                                        i3 = tmpPackageFile;
                                        i = parseFlags;
                                        installerPackageName = installerPackageName2;
                                        z2 = onExternal2;
                                        forwardLocked = installBeginTime3;
                                        file = tmpPackageFile2;
                                        str = volumeUuid;
                                        installBeginTime2 = volumeUuid2;
                                        replace4 = z4;
                                        while (true) {
                                            break;
                                        }
                                        throw th;
                                    }
                                    try {
                                        childCount = pp2.permissions.size();
                                        installFlags3 = childCount - 1;
                                        while (installFlags3 >= 0) {
                                            try {
                                                int N;
                                                PackageSetting ps;
                                                Permission perm = (Permission) pp2.permissions.get(installFlags3);
                                                BasePermission bp = this.mPermissionManager.getPermissionTEMP(perm.info.name);
                                                if ((perm.info.protectionLevel & 4096) == null || systemApp) {
                                                    N = childCount;
                                                    ps = installBeginTime2;
                                                } else {
                                                    try {
                                                        tmpPackageFile = TAG;
                                                        N = childCount;
                                                        stringBuilder6 = new StringBuilder();
                                                        ps = installBeginTime2;
                                                        stringBuilder6.append("Non-System package ");
                                                        stringBuilder6.append(pp2.packageName);
                                                        stringBuilder6.append(" attempting to delcare ephemeral permission ");
                                                        stringBuilder6.append(perm.info.name);
                                                        stringBuilder6.append("; Removing ephemeral.");
                                                        Slog.w(tmpPackageFile, stringBuilder6.toString());
                                                        PermissionInfo permissionInfo = perm.info;
                                                        permissionInfo.protectionLevel &= -4097;
                                                    } catch (Throwable th39) {
                                                        th = th39;
                                                        z = forwardLocked;
                                                        installBeginTime2 = volumeUuid2;
                                                        installFlags3 = parseFlags;
                                                    }
                                                }
                                                if (bp != null) {
                                                    str2 = bp.getSourcePackageName();
                                                    installBeginTime2 = bp.getSourcePackageSetting();
                                                    tmpPackageFile = this.mSettings.mKeySetManagerService;
                                                    installerPackageName = installerPackageName2;
                                                    try {
                                                        File file3;
                                                        if (str2.equals(pp2.packageName) == null || tmpPackageFile.shouldCheckUpgradeKeySetLocked(installBeginTime2, scanFlags2) == null) {
                                                            String str6 = str2;
                                                            file3 = tmpPackageFile;
                                                            if (installBeginTime2.signatures.mSigningDetails.checkCapability(pp2.mSigningDetails, 4)) {
                                                                z3 = true;
                                                            } else {
                                                                if (pp2.mSigningDetails.checkCapability(installBeginTime2.signatures.mSigningDetails, 4)) {
                                                                    installBeginTime2.signatures.mSigningDetails = pp2.mSigningDetails;
                                                                    z3 = true;
                                                                } else {
                                                                    z3 = false;
                                                                }
                                                                if (!z3) {
                                                                    if (!(PLATFORM_PACKAGE_NAME.equals(pp2.packageName) || (perm.info.protectionLevel & 15) != 1 || bp == null || bp.isRuntime())) {
                                                                        str2 = TAG;
                                                                        tmpPackageFile = new StringBuilder();
                                                                        tmpPackageFile.append("Package ");
                                                                        tmpPackageFile.append(pp2.packageName);
                                                                        tmpPackageFile.append(" trying to change a non-runtime permission ");
                                                                        tmpPackageFile.append(perm.info.name);
                                                                        tmpPackageFile.append(" to runtime; keeping old protection level");
                                                                        Slog.w(str2, tmpPackageFile.toString());
                                                                        perm.info.protectionLevel = bp.getProtectionLevel();
                                                                    }
                                                                } else if (bp.getSourcePackageName().equals(PLATFORM_PACKAGE_NAME) != null) {
                                                                    str2 = TAG;
                                                                    tmpPackageFile = new StringBuilder();
                                                                    tmpPackageFile.append("Package ");
                                                                    tmpPackageFile.append(pp2.packageName);
                                                                    tmpPackageFile.append(" attempting to redeclare system permission ");
                                                                    tmpPackageFile.append(perm.info.name);
                                                                    tmpPackageFile.append("; ignoring new declaration");
                                                                    Slog.w(str2, tmpPackageFile.toString());
                                                                    pp2.permissions.remove(installFlags3);
                                                                } else if (((bp.getProtectionLevel() | perm.info.protectionLevel) & 15) == 2) {
                                                                    tmpPackageFile = new StringBuilder();
                                                                    tmpPackageFile.append("Package ");
                                                                    tmpPackageFile.append(pp2.packageName);
                                                                    tmpPackageFile.append(" attempting to redeclare permission ");
                                                                    tmpPackageFile.append(perm.info.name);
                                                                    tmpPackageFile.append(" already owned by ");
                                                                    tmpPackageFile.append(bp.getSourcePackageName());
                                                                    packageInstalledInfo.setError(-112, tmpPackageFile.toString());
                                                                    packageInstalledInfo.origPermission = perm.info.name;
                                                                    packageInstalledInfo.origPackage = bp.getSourcePackageName();
                                                                    return;
                                                                } else {
                                                                    tmpPackageFile = TAG;
                                                                    installerPackageName2 = new StringBuilder();
                                                                    installerPackageName2.append("Package ");
                                                                    installerPackageName2.append(pp2.packageName);
                                                                    installerPackageName2.append(" attempting to redeclare permission ");
                                                                    installerPackageName2.append(perm.info.name);
                                                                    installerPackageName2.append(" already owned by ");
                                                                    installerPackageName2.append(bp.getSourcePackageName());
                                                                    installerPackageName2.append("; ignoring new declaration");
                                                                    Slog.w(tmpPackageFile, installerPackageName2.toString());
                                                                    pp2.permissions.remove(installFlags3);
                                                                }
                                                            }
                                                        } else {
                                                            file3 = tmpPackageFile;
                                                            z3 = tmpPackageFile.checkUpgradeKeySetLocked(installBeginTime2, pp2);
                                                        }
                                                        if (!z3) {
                                                        }
                                                    } catch (Throwable th40) {
                                                        th = th40;
                                                        z = forwardLocked;
                                                        installBeginTime2 = volumeUuid2;
                                                        obj3 = parseFlags;
                                                        forwardLocked = installBeginTime3;
                                                        ksms = replace3;
                                                        while (true) {
                                                            break;
                                                        }
                                                        throw th;
                                                    }
                                                }
                                                installerPackageName = installerPackageName2;
                                                installFlags3--;
                                                childCount = N;
                                                installBeginTime2 = ps;
                                                installerPackageName2 = installerPackageName;
                                            } catch (Throwable th41) {
                                                th = th41;
                                                installerPackageName = installerPackageName2;
                                                z = forwardLocked;
                                                installBeginTime2 = volumeUuid2;
                                                obj3 = parseFlags;
                                                z2 = onExternal2;
                                                forwardLocked = installBeginTime3;
                                                file = tmpPackageFile2;
                                                str = volumeUuid;
                                                i3 = installFlags;
                                                replace4 = replace3;
                                                while (true) {
                                                    break;
                                                }
                                                throw th;
                                            }
                                        }
                                        installerPackageName = installerPackageName2;
                                    } catch (Throwable th42) {
                                        th = th42;
                                        z = forwardLocked;
                                        installerPackageName = installerPackageName2;
                                        z2 = onExternal2;
                                        forwardLocked = installBeginTime3;
                                        file = tmpPackageFile2;
                                        str = volumeUuid;
                                        onExternal = installFlags;
                                        installBeginTime2 = volumeUuid2;
                                        replace4 = replace3;
                                        obj3 = parseFlags;
                                        while (true) {
                                            break;
                                        }
                                        throw th;
                                    }
                                }
                            } catch (PackageManagerException e10) {
                                z = forwardLocked;
                                str = volumeUuid2;
                                i = parseFlags;
                                installerPackageName = installerPackageName2;
                                z2 = onExternal2;
                                forwardLocked = installBeginTime3;
                                file = tmpPackageFile2;
                                Slog.i(TAG, "downgrade package from preset system app, just restore the uninstalled system app");
                                return;
                            }
                        }
                    } catch (PackageParserException e11) {
                        e = e11;
                        z = forwardLocked;
                        str = volumeUuid2;
                        i = parseFlags;
                        installerPackageName = installerPackageName2;
                        z2 = onExternal2;
                        forwardLocked = installBeginTime3;
                        file = tmpPackageFile2;
                    }
                } else {
                    packageInstalledInfo.setError(-15, "installPackageLI");
                    return;
                }
                packageInstalledInfo.setError(-111, "Disallow install new apps");
                str2 = TAG;
                stringBuilder3 = new StringBuilder();
                stringBuilder3.append(installerPackageName);
                stringBuilder3.append(" is disallowed to install new app ");
                stringBuilder3.append(installBeginTime2);
                Slog.i(str2, stringBuilder3.toString());
                return;
            } catch (PackageParserException e12) {
                e = e12;
                z4 = false;
                z = forwardLocked;
                file = tmpPackageFile;
                str = volumeUuid2;
                i = parseFlags;
                packageParser = pp;
                z2 = onExternal2;
                packageInstalledInfo.setError("Failed parse during installPackageLI", e);
                Trace.traceEnd(j);
                return;
            } catch (Throwable th43) {
                th = th43;
                z4 = false;
                z = forwardLocked;
                file = tmpPackageFile;
                str = volumeUuid2;
                i = parseFlags;
                packageParser = pp;
                replace4 = installerPackageName2;
                z2 = onExternal2;
                forwardLocked = installBeginTime2;
                Trace.traceEnd(j);
                throw th;
            }
        }
        packageInstalledInfo.setReturnCode(RequestStatus.SYS_ETIMEDOUT);
        Log.w(TAG, "can not install packages before FRP unlock");
        return;
        packageInstalledInfo.setError("Failed collect during installPackageLI", e);
    }

    private void startIntentFilterVerifications(int userId, boolean replacing, Package pkg) {
        if (this.mIntentFilterVerifierComponent == null) {
            Slog.w(TAG, "No IntentFilter verification will not be done as there is no IntentFilterVerifier available!");
            return;
        }
        int i = 0;
        int verifierUid = getPackageUid(this.mIntentFilterVerifierComponent.getPackageName(), 268435456, userId == -1 ? 0 : userId);
        Message msg = this.mHandler.obtainMessage(17);
        msg.obj = new IFVerificationParams(pkg, replacing, userId, verifierUid);
        this.mHandler.sendMessage(msg);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        while (i < childCount) {
            Package childPkg = (Package) pkg.childPackages.get(i);
            msg = this.mHandler.obtainMessage(17);
            msg.obj = new IFVerificationParams(childPkg, replacing, userId, verifierUid);
            this.mHandler.sendMessage(msg);
            i++;
        }
    }

    /* JADX WARNING: Missing block: B:25:0x008a, code skipped:
            return;
     */
    /* JADX WARNING: Missing block: B:71:0x015b, code skipped:
            if (r2 <= 0) goto L_0x0196;
     */
    /* JADX WARNING: Missing block: B:73:0x015f, code skipped:
            if (DEBUG_DOMAIN_VERIFICATION == false) goto L_0x0190;
     */
    /* JADX WARNING: Missing block: B:74:0x0161, code skipped:
            r0 = TAG;
            r3 = new java.lang.StringBuilder();
            r3.append("Starting ");
            r3.append(r2);
            r3.append(" IntentFilter verification");
     */
    /* JADX WARNING: Missing block: B:75:0x0176, code skipped:
            if (r2 <= 1) goto L_0x017c;
     */
    /* JADX WARNING: Missing block: B:76:0x0178, code skipped:
            r4 = "s";
     */
    /* JADX WARNING: Missing block: B:77:0x017c, code skipped:
            r4 = com.android.server.backup.BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS;
     */
    /* JADX WARNING: Missing block: B:78:0x017e, code skipped:
            r3.append(r4);
            r3.append(" for userId:");
            r3.append(r8);
            android.util.Slog.d(r0, r3.toString());
     */
    /* JADX WARNING: Missing block: B:79:0x0190, code skipped:
            r1.mIntentFilterVerifier.startVerifications(r8);
     */
    /* JADX WARNING: Missing block: B:81:0x0198, code skipped:
            if (DEBUG_DOMAIN_VERIFICATION == false) goto L_0x01b0;
     */
    /* JADX WARNING: Missing block: B:82:0x019a, code skipped:
            r0 = TAG;
            r3 = new java.lang.StringBuilder();
            r3.append("No filters or not all autoVerify for ");
            r3.append(r12);
            android.util.Slog.d(r0, r3.toString());
     */
    /* JADX WARNING: Missing block: B:83:0x01b0, code skipped:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void verifyIntentFiltersIfNeeded(int userId, int verifierUid, boolean replacing, Package pkg) {
        Throwable th;
        int i = userId;
        Package packageR = pkg;
        int size = packageR.activities.size();
        if (size == 0) {
            if (DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(TAG, "No activity, so no need to verify any IntentFilter!");
            }
        } else if (hasDomainURLs(pkg)) {
            if (DEBUG_DOMAIN_VERIFICATION) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Checking for userId:");
                stringBuilder.append(i);
                stringBuilder.append(" if any IntentFilter from the ");
                stringBuilder.append(size);
                stringBuilder.append(" Activities needs verification ...");
                Slog.d(str, stringBuilder.toString());
            }
            int count = 0;
            String packageName = packageR.packageName;
            synchronized (this.mPackages) {
                if (!replacing) {
                    IntentFilterVerificationInfo ivi = this.mSettings.getIntentFilterVerificationLPr(packageName);
                    if (ivi != null) {
                        if (DEBUG_DOMAIN_VERIFICATION) {
                            String str2 = TAG;
                            StringBuilder stringBuilder2 = new StringBuilder();
                            stringBuilder2.append("Package ");
                            stringBuilder2.append(packageName);
                            stringBuilder2.append(" already verified: status=");
                            stringBuilder2.append(ivi.getStatusString());
                            Slog.i(str2, stringBuilder2.toString());
                        }
                    }
                }
                boolean needToVerify = false;
                Iterator it = packageR.activities.iterator();
                while (it.hasNext()) {
                    Iterator it2 = ((Activity) it.next()).intents.iterator();
                    while (it2.hasNext()) {
                        ActivityIntentInfo filter = (ActivityIntentInfo) it2.next();
                        if (filter.needsVerification() && needsNetworkVerificationLPr(filter)) {
                            if (DEBUG_DOMAIN_VERIFICATION) {
                                Slog.d(TAG, "Intent filter needs verification, so processing all filters");
                            }
                            needToVerify = true;
                        }
                    }
                }
                boolean z = true;
                if (needToVerify) {
                    int verificationId = this.mIntentFilterVerificationToken;
                    this.mIntentFilterVerificationToken = verificationId + 1;
                    Iterator it3 = packageR.activities.iterator();
                    while (it3.hasNext()) {
                        Iterator it4;
                        Activity a = (Activity) it3.next();
                        Iterator it5 = a.intents.iterator();
                        int count2 = count;
                        while (it5.hasNext()) {
                            try {
                                boolean needToVerify2;
                                Iterator it6;
                                Activity a2;
                                ActivityIntentInfo filter2 = (ActivityIntentInfo) it5.next();
                                if (filter2.handlesWebUris(z) && needsNetworkVerificationLPr(filter2)) {
                                    if (DEBUG_DOMAIN_VERIFICATION) {
                                        String str3 = TAG;
                                        StringBuilder stringBuilder3 = new StringBuilder();
                                        needToVerify2 = needToVerify;
                                        stringBuilder3.append("Verification needed for IntentFilter:");
                                        stringBuilder3.append(filter2.toString());
                                        Slog.d(str3, stringBuilder3.toString());
                                    } else {
                                        needToVerify2 = needToVerify;
                                    }
                                    it6 = it5;
                                    a2 = a;
                                    it4 = it3;
                                    this.mIntentFilterVerifier.addOneIntentFilterVerification(verifierUid, i, verificationId, filter2, packageName);
                                    count2++;
                                } else {
                                    needToVerify2 = needToVerify;
                                    it6 = it5;
                                    a2 = a;
                                    it4 = it3;
                                }
                                it5 = it6;
                                needToVerify = needToVerify2;
                                a = a2;
                                it3 = it4;
                                z = true;
                            } catch (Throwable th2) {
                                th = th2;
                                count = count2;
                                throw th;
                            }
                        }
                        it4 = it3;
                        count = count2;
                        z = true;
                    }
                }
                try {
                } catch (Throwable th3) {
                    th = th3;
                    throw th;
                }
            }
        } else {
            if (DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(TAG, "No domain URLs, so no need to verify any IntentFilter!");
            }
        }
    }

    private boolean needsNetworkVerificationLPr(ActivityIntentInfo filter) {
        IntentFilterVerificationInfo ivi = this.mSettings.getIntentFilterVerificationLPr(filter.activity.getComponentName().getPackageName());
        if (ivi == null) {
            return true;
        }
        switch (ivi.getStatus()) {
            case 0:
            case 1:
                return true;
            default:
                return false;
        }
    }

    private static boolean isMultiArch(ApplicationInfo info) {
        return (info.flags & Integer.MIN_VALUE) != 0;
    }

    private static boolean isExternal(Package pkg) {
        return (pkg.applicationInfo.flags & 262144) != 0;
    }

    private static boolean isExternal(PackageSetting ps) {
        return (ps.pkgFlags & 262144) != 0;
    }

    private static boolean isSystemApp(Package pkg) {
        return (pkg.applicationInfo.flags & 1) != 0;
    }

    private static boolean isPrivilegedApp(Package pkg) {
        return (pkg.applicationInfo.privateFlags & 8) != 0;
    }

    private static boolean isOemApp(Package pkg) {
        return (pkg.applicationInfo.privateFlags & 131072) != 0;
    }

    private static boolean isVendorApp(Package pkg) {
        return (pkg.applicationInfo.privateFlags & 262144) != 0;
    }

    private static boolean isProductApp(Package pkg) {
        return (pkg.applicationInfo.privateFlags & 524288) != 0;
    }

    private static boolean hasDomainURLs(Package pkg) {
        return (pkg.applicationInfo.privateFlags & 16) != 0;
    }

    private static boolean isSystemApp(PackageSetting ps) {
        return (ps.pkgFlags & 1) != 0;
    }

    private static boolean isUpdatedSystemApp(PackageSetting ps) {
        return (ps.pkgFlags & 128) != 0;
    }

    private int packageFlagsToInstallFlags(PackageSetting ps) {
        int installFlags = 0;
        if (isExternal(ps) && TextUtils.isEmpty(ps.volumeUuid)) {
            installFlags = 0 | 8;
        }
        if (ps.isForwardLocked()) {
            return installFlags | 1;
        }
        return installFlags;
    }

    private VersionInfo getSettingsVersionForPackage(Package pkg) {
        if (!isExternal(pkg)) {
            return this.mSettings.getInternalVersion();
        }
        if (TextUtils.isEmpty(pkg.volumeUuid)) {
            return this.mSettings.getExternalVersion();
        }
        return this.mSettings.findOrCreateVersion(pkg.volumeUuid);
    }

    private void deleteTempPackageFiles() {
        for (File file : sDrmAppPrivateInstallDir.listFiles(new FilenameFilter() {
            public boolean accept(File dir, String name) {
                return name.startsWith("vmdl") && name.endsWith(".tmp");
            }
        })) {
            file.delete();
        }
    }

    public void deletePackageAsUser(String packageName, int versionCode, IPackageDeleteObserver observer, int userId, int flags) {
        deletePackageVersioned(new VersionedPackage(packageName, versionCode), new LegacyPackageDeleteObserver(observer).getBinder(), userId, flags);
    }

    public void deletePackageVersioned(VersionedPackage versionedPackage, IPackageDeleteObserver2 observer, int userId, int deleteFlags) {
        String internalPackageName;
        String str;
        IPackageDeleteObserver2 iPackageDeleteObserver2 = observer;
        int i = userId;
        int callingUid = Binder.getCallingUid();
        this.mContext.enforceCallingOrSelfPermission("android.permission.DELETE_PACKAGES", null);
        boolean canViewInstantApps = canViewInstantApps(callingUid, i);
        Preconditions.checkNotNull(versionedPackage);
        Preconditions.checkNotNull(observer);
        Preconditions.checkArgumentInRange(versionedPackage.getLongVersionCode(), -1, JobStatus.NO_LATEST_RUNTIME, "versionCode must be >= -1");
        String packageName = versionedPackage.getPackageName();
        long versionCode = versionedPackage.getLongVersionCode();
        synchronized (this.mPackages) {
            try {
                internalPackageName = resolveInternalPackageNameLPr(packageName, versionCode);
            } catch (Throwable th) {
                long j = versionCode;
                str = packageName;
                int i2 = callingUid;
                while (true) {
                }
            }
        }
        int uid = Binder.getCallingUid();
        if (isOrphaned(internalPackageName) || isCallerAllowedToSilentlyUninstall(uid, internalPackageName)) {
            boolean deleteAllUsers = (deleteFlags & 2) != 0;
            int[] users = deleteAllUsers ? sUserManager.getUserIds() : new int[]{i};
            if (UserHandle.getUserId(uid) != i || (deleteAllUsers && users.length > 1)) {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("deletePackage for user ");
                stringBuilder.append(i);
                this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", stringBuilder.toString());
            }
            if (isUserRestricted(i, "no_uninstall_apps")) {
                try {
                    iPackageDeleteObserver2.onPackageDeleted(packageName, -3, null);
                } catch (RemoteException e) {
                }
                return;
            } else if (deleteAllUsers || !getBlockUninstallForUser(internalPackageName, i)) {
                if (DEBUG_REMOVE) {
                    String str2 = TAG;
                    StringBuilder stringBuilder2 = new StringBuilder();
                    stringBuilder2.append("deletePackageAsUser: pkg=");
                    stringBuilder2.append(internalPackageName);
                    stringBuilder2.append(" user=");
                    stringBuilder2.append(i);
                    stringBuilder2.append(" deleteAllUsers: ");
                    stringBuilder2.append(deleteAllUsers);
                    stringBuilder2.append(" version=");
                    stringBuilder2.append(versionCode == -1 ? "VERSION_CODE_HIGHEST" : Long.valueOf(versionCode));
                    Slog.d(str2, stringBuilder2.toString());
                }
                PackageHandler packageHandler = this.mHandler;
                str = internalPackageName;
                int[] users2 = users;
                final int i3 = callingUid;
                boolean deleteAllUsers2 = deleteAllUsers;
                deleteAllUsers = canViewInstantApps;
                AnonymousClass15 anonymousClass15 = r1;
                final boolean z = deleteAllUsers2;
                final long j2 = versionCode;
                final int i4 = i;
                final int i5 = deleteFlags;
                String packageName2 = packageName;
                final int[] iArr = users2;
                final IPackageDeleteObserver2 iPackageDeleteObserver22 = iPackageDeleteObserver2;
                final String str3 = packageName2;
                AnonymousClass15 anonymousClass152 = new Runnable() {
                    public void run() {
                        PackageManagerService.this.mHandler.removeCallbacks(this);
                        PackageSetting ps = (PackageSetting) PackageManagerService.this.mSettings.mPackages.get(str);
                        boolean doDeletePackage = true;
                        int i = 0;
                        if (ps != null) {
                            boolean z = !ps.getInstantApp(UserHandle.getUserId(i3)) || deleteAllUsers;
                            doDeletePackage = z;
                        }
                        if (!doDeletePackage) {
                            i = -1;
                        } else if (z) {
                            int[] blockUninstallUserIds = PackageManagerService.this.getBlockUninstallForUsers(str, iArr);
                            if (ArrayUtils.isEmpty(blockUninstallUserIds)) {
                                i = PackageManagerService.this.deletePackageX(str, j2, i4, i5);
                            } else {
                                int userFlags = i5 & -3;
                                int[] iArr = iArr;
                                int length = iArr.length;
                                while (i < length) {
                                    int userId = iArr[i];
                                    if (!ArrayUtils.contains(blockUninstallUserIds, userId)) {
                                        int returnCode = PackageManagerService.this.deletePackageX(str, j2, userId, userFlags);
                                        if (returnCode != 1) {
                                            String str = PackageManagerService.TAG;
                                            StringBuilder stringBuilder = new StringBuilder();
                                            stringBuilder.append("Package delete failed for user ");
                                            stringBuilder.append(userId);
                                            stringBuilder.append(", returnCode ");
                                            stringBuilder.append(returnCode);
                                            Slog.w(str, stringBuilder.toString());
                                        }
                                    }
                                    i++;
                                }
                                i = -4;
                            }
                        } else {
                            i = PackageManagerService.this.deletePackageX(str, j2, i4, i5);
                        }
                        try {
                            iPackageDeleteObserver22.onPackageDeleted(str3, i, null);
                        } catch (RemoteException e) {
                            Log.i(PackageManagerService.TAG, "Observer no longer exists.");
                        }
                    }
                };
                packageHandler.post(anonymousClass15);
                setNeedClearDeviceForCTS(false, packageName2);
                Log.d(TAG, "setmNeedClearDeviceForCTS:false ");
                return;
            } else {
                try {
                    iPackageDeleteObserver2.onPackageDeleted(packageName, -4, null);
                } catch (RemoteException e2) {
                }
                return;
            }
        }
        try {
            Intent intent = new Intent("android.intent.action.UNINSTALL_PACKAGE");
            intent.setData(Uri.fromParts("package", packageName, null));
            intent.putExtra("android.content.pm.extra.CALLBACK", observer.asBinder());
            iPackageDeleteObserver2.onUserActionRequired(intent);
        } catch (RemoteException e3) {
        }
    }

    private String resolveExternalPackageNameLPr(Package pkg) {
        if (pkg.staticSharedLibName != null) {
            return pkg.manifestPackageName;
        }
        return pkg.packageName;
    }

    private String resolveInternalPackageNameLPr(String packageName, long versionCode) {
        String str = packageName;
        String normalizedPackageName = this.mSettings.getRenamedPackageLPr(str);
        str = normalizedPackageName != null ? normalizedPackageName : str;
        LongSparseArray<SharedLibraryEntry> versionedLib = (LongSparseArray) this.mStaticLibsByDeclaringPackage.get(str);
        if (versionedLib == null || versionedLib.size() <= 0) {
            return str;
        }
        LongSparseLongArray versionsCallerCanSee = null;
        int callingAppId = UserHandle.getAppId(Binder.getCallingUid());
        if (!(callingAppId == 1000 || callingAppId == 2000 || callingAppId == 0)) {
            versionsCallerCanSee = new LongSparseLongArray();
            String libName = ((SharedLibraryEntry) versionedLib.valueAt(0)).info.getName();
            String[] uidPackages = getPackagesForUid(Binder.getCallingUid());
            if (uidPackages != null) {
                int length = uidPackages.length;
                int i = 0;
                while (i < length) {
                    int callingAppId2;
                    String libName2;
                    PackageSetting ps = this.mSettings.getPackageLPr(uidPackages[i]);
                    int libIdx = ArrayUtils.indexOf(ps.usesStaticLibraries, libName);
                    if (libIdx >= 0) {
                        callingAppId2 = callingAppId;
                        libName2 = libName;
                        callingAppId = ps.usesStaticLibrariesVersions[libIdx];
                        versionsCallerCanSee.append(callingAppId, callingAppId);
                    } else {
                        callingAppId2 = callingAppId;
                        libName2 = libName;
                    }
                    i++;
                    callingAppId = callingAppId2;
                    libName = libName2;
                }
            }
        }
        if (versionsCallerCanSee != null && versionsCallerCanSee.size() <= 0) {
            return str;
        }
        SharedLibraryEntry highestVersion = null;
        int versionCount = versionedLib.size();
        int i2 = 0;
        while (true) {
            int i3 = i2;
            if (i3 < versionCount) {
                SharedLibraryEntry libEntry = (SharedLibraryEntry) versionedLib.valueAt(i3);
                if (versionsCallerCanSee == null || versionsCallerCanSee.indexOfKey(libEntry.info.getLongVersion()) >= 0) {
                    long libVersionCode = libEntry.info.getDeclaringPackage().getLongVersionCode();
                    if (versionCode != -1) {
                        if (libVersionCode == versionCode) {
                            return libEntry.apk;
                        }
                    } else if (highestVersion == null) {
                        highestVersion = libEntry;
                    } else if (libVersionCode > highestVersion.info.getDeclaringPackage().getLongVersionCode()) {
                        highestVersion = libEntry;
                    }
                }
                i2 = i3 + 1;
            } else if (highestVersion != null) {
                return highestVersion.apk;
            } else {
                return str;
            }
        }
    }

    boolean isCallerVerifier(int callingUid) {
        int callingUserId = UserHandle.getUserId(callingUid);
        if (this.mRequiredVerifierPackage == null || callingUid != getPackageUid(this.mRequiredVerifierPackage, 0, callingUserId)) {
            return false;
        }
        return true;
    }

    private boolean isCallerAllowedToSilentlyUninstall(int callingUid, String pkgName) {
        if (callingUid == 2000 || callingUid == 0 || UserHandle.getAppId(callingUid) == 1000) {
            return true;
        }
        int callingUserId = UserHandle.getUserId(callingUid);
        if (callingUid == getPackageUid(getInstallerPackageName(pkgName), 0, callingUserId)) {
            return true;
        }
        if (this.mRequiredVerifierPackage != null && callingUid == getPackageUid(this.mRequiredVerifierPackage, 0, callingUserId)) {
            return true;
        }
        if (this.mRequiredUninstallerPackage != null && callingUid == getPackageUid(this.mRequiredUninstallerPackage, 0, callingUserId)) {
            return true;
        }
        if ((this.mStorageManagerPackage == null || callingUid != getPackageUid(this.mStorageManagerPackage, 0, callingUserId)) && checkUidPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS", callingUid) != 0) {
            return false;
        }
        return true;
    }

    private int[] getBlockUninstallForUsers(String packageName, int[] userIds) {
        int[] result = EMPTY_INT_ARRAY;
        for (int userId : userIds) {
            if (getBlockUninstallForUser(packageName, userId)) {
                result = ArrayUtils.appendInt(result, userId);
            }
        }
        return result;
    }

    public boolean isPackageDeviceAdminOnAnyUser(String packageName) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null || isCallerSameApp(packageName, callingUid)) {
            return isPackageDeviceAdmin(packageName, -1);
        }
        return false;
    }

    private boolean isPackageDeviceAdmin(String packageName, int userId) {
        IDevicePolicyManager dpm = IDevicePolicyManager.Stub.asInterface(ServiceManager.getService("device_policy"));
        if (dpm != null) {
            try {
                String deviceOwnerPackageName;
                ComponentName deviceOwnerComponentName = dpm.getDeviceOwnerComponent(false);
                if (deviceOwnerComponentName == null) {
                    deviceOwnerPackageName = null;
                } else {
                    deviceOwnerPackageName = deviceOwnerComponentName.getPackageName();
                }
                if (packageName.equals(deviceOwnerPackageName)) {
                    return true;
                }
                int[] users = userId == -1 ? sUserManager.getUserIds() : new int[]{userId};
                for (int packageHasActiveAdmins : users) {
                    if (dpm.packageHasActiveAdmins(packageName, packageHasActiveAdmins)) {
                        return true;
                    }
                }
            } catch (RemoteException e) {
            }
        }
        return false;
    }

    private boolean shouldKeepUninstalledPackageLPr(String packageName) {
        return this.mKeepUninstalledPackages != null && this.mKeepUninstalledPackages.contains(packageName);
    }

    /* JADX WARNING: Removed duplicated region for block: B:196:0x02f7 A:{SYNTHETIC, Splitter:B:196:0x02f7} */
    /* JADX WARNING: Removed duplicated region for block: B:174:0x02c0  */
    /* JADX WARNING: Removed duplicated region for block: B:173:0x02bd  */
    /* JADX WARNING: Missing block: B:71:0x0188, code skipped:
            if (isUpdatedSystemApp(r7) == false) goto L_0x0190;
     */
    /* JADX WARNING: Missing block: B:73:0x018c, code skipped:
            if ((r14 & 4) != 0) goto L_0x0190;
     */
    /* JADX WARNING: Missing block: B:74:0x018e, code skipped:
            r0 = -1;
     */
    /* JADX WARNING: Missing block: B:75:0x0190, code skipped:
            r0 = r8;
     */
    /* JADX WARNING: Missing block: B:76:0x0191, code skipped:
            r13 = r0;
            r4 = r10.mInstallLock;
     */
    /* JADX WARNING: Missing block: B:77:0x0194, code skipped:
            monitor-enter(r4);
     */
    /* JADX WARNING: Missing block: B:80:0x0197, code skipped:
            if (DEBUG_REMOVE == false) goto L_0x01c7;
     */
    /* JADX WARNING: Missing block: B:82:?, code skipped:
            r0 = TAG;
            r1 = new java.lang.StringBuilder();
            r1.append("deletePackageX: pkg=");
            r1.append(r11);
            r1.append(" user=");
     */
    /* JADX WARNING: Missing block: B:85:?, code skipped:
            r1.append(r30);
            android.util.Slog.d(r0, r1.toString());
     */
    /* JADX WARNING: Missing block: B:86:0x01ba, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:87:0x01bc, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:88:0x01bd, code skipped:
            r3 = r30;
     */
    /* JADX WARNING: Missing block: B:89:0x01bf, code skipped:
            r21 = r4;
            r4 = r6;
            r16 = r8;
            r6 = r9;
     */
    /* JADX WARNING: Missing block: B:90:0x01c7, code skipped:
            r3 = r30;
     */
    /* JADX WARNING: Missing block: B:93:0x01cf, code skipped:
            r2 = freezePackageForDelete(r11, r13, r14, "deletePackageX");
     */
    /* JADX WARNING: Missing block: B:96:0x01d5, code skipped:
            r12 = null;
            r15 = r2;
            r21 = r4;
            r22 = false;
            r23 = r6;
            r24 = r7;
            r16 = r8;
            r25 = r9;
     */
    /* JADX WARNING: Missing block: B:98:?, code skipped:
            r0 = deletePackageLIF(r11, android.os.UserHandle.of(r8), true, r5, r14 | Integer.MIN_VALUE, r9, true, null);
     */
    /* JADX WARNING: Missing block: B:99:0x01fd, code skipped:
            if (r15 == null) goto L_0x020c;
     */
    /* JADX WARNING: Missing block: B:101:?, code skipped:
            $closeResource(r12, r15);
     */
    /* JADX WARNING: Missing block: B:102:0x0203, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:103:0x0204, code skipped:
            r4 = r23;
            r7 = r24;
            r6 = r25;
     */
    /* JADX WARNING: Missing block: B:104:0x020c, code skipped:
            r1 = r0;
     */
    /* JADX WARNING: Missing block: B:106:?, code skipped:
            r2 = r10.mPackages;
     */
    /* JADX WARNING: Missing block: B:107:0x020f, code skipped:
            monitor-enter(r2);
     */
    /* JADX WARNING: Missing block: B:108:0x0210, code skipped:
            if (r1 == false) goto L_0x023e;
     */
    /* JADX WARNING: Missing block: B:109:0x0212, code skipped:
            r4 = r23;
     */
    /* JADX WARNING: Missing block: B:110:0x0214, code skipped:
            if (r4 == null) goto L_0x022c;
     */
    /* JADX WARNING: Missing block: B:113:0x0218, code skipped:
            r6 = r25;
     */
    /* JADX WARNING: Missing block: B:115:?, code skipped:
            r10.mInstantAppRegistry.onPackageUninstalledLPw(r4, r6.removedUsers);
     */
    /* JADX WARNING: Missing block: B:116:0x0220, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:117:0x0221, code skipped:
            r7 = r24;
     */
    /* JADX WARNING: Missing block: B:118:0x0225, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:119:0x0226, code skipped:
            r6 = r25;
            r7 = r24;
     */
    /* JADX WARNING: Missing block: B:120:0x022c, code skipped:
            r6 = r25;
     */
    /* JADX WARNING: Missing block: B:125:?, code skipped:
            updateSequenceNumberLP(r24, r6.removedUsers);
            updateInstantAppInstallerLocked(r27);
     */
    /* JADX WARNING: Missing block: B:126:0x0239, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:127:0x023a, code skipped:
            r7 = r24;
     */
    /* JADX WARNING: Missing block: B:128:0x023e, code skipped:
            r4 = r23;
            r7 = r24;
            r6 = r25;
     */
    /* JADX WARNING: Missing block: B:129:0x0244, code skipped:
            monitor-exit(r2);
     */
    /* JADX WARNING: Missing block: B:131:?, code skipped:
            monitor-exit(r21);
     */
    /* JADX WARNING: Missing block: B:132:0x0246, code skipped:
            if (r1 == false) goto L_0x0288;
     */
    /* JADX WARNING: Missing block: B:133:0x0248, code skipped:
            r2 = null;
            r3 = r6.isRemovedPackageSystemUpdate;
            r8 = r10.mPackages;
     */
    /* JADX WARNING: Missing block: B:134:0x024d, code skipped:
            monitor-enter(r8);
     */
    /* JADX WARNING: Missing block: B:135:0x024e, code skipped:
            if (r3 != false) goto L_0x025d;
     */
    /* JADX WARNING: Missing block: B:138:0x0256, code skipped:
            if (r10.mPackages.get(r11) != null) goto L_0x025d;
     */
    /* JADX WARNING: Missing block: B:139:0x0258, code skipped:
            r2 = true;
     */
    /* JADX WARNING: Missing block: B:142:0x025d, code skipped:
            monitor-exit(r8);
     */
    /* JADX WARNING: Missing block: B:143:0x025e, code skipped:
            if (r2 != null) goto L_0x0262;
     */
    /* JADX WARNING: Missing block: B:144:0x0260, code skipped:
            if (r3 == false) goto L_0x0270;
     */
    /* JADX WARNING: Missing block: B:146:?, code skipped:
            updatePackageBlackListInfo(r27);
     */
    /* JADX WARNING: Missing block: B:147:0x0266, code skipped:
            r0 = move-exception;
     */
    /* JADX WARNING: Missing block: B:148:0x0267, code skipped:
            r8 = r0;
            android.util.Slog.e(TAG, "update BlackListApp info failed");
     */
    /* JADX WARNING: Missing block: B:176:0x02c3, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:178:?, code skipped:
            monitor-exit(r2);
     */
    /* JADX WARNING: Missing block: B:180:?, code skipped:
            throw r0;
     */
    /* JADX WARNING: Missing block: B:181:0x02c6, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:182:0x02c7, code skipped:
            r4 = r23;
            r7 = r24;
            r6 = r25;
     */
    /* JADX WARNING: Missing block: B:183:0x02ce, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:184:0x02cf, code skipped:
            r4 = r23;
            r7 = r24;
            r6 = r25;
     */
    /* JADX WARNING: Missing block: B:185:0x02d6, code skipped:
            r0 = move-exception;
     */
    /* JADX WARNING: Missing block: B:186:0x02d7, code skipped:
            r4 = r23;
            r7 = r24;
            r6 = r25;
            r1 = r0;
     */
    /* JADX WARNING: Missing block: B:187:0x02df, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:188:0x02e0, code skipped:
            r12 = null;
            r15 = r2;
            r21 = r4;
            r4 = r6;
            r16 = r8;
            r6 = r9;
     */
    /* JADX WARNING: Missing block: B:189:0x02e9, code skipped:
            r0 = move-exception;
     */
    /* JADX WARNING: Missing block: B:190:0x02ea, code skipped:
            r15 = r2;
            r21 = r4;
            r4 = r6;
            r16 = r8;
            r6 = r9;
            r1 = r0;
     */
    /* JADX WARNING: Missing block: B:192:?, code skipped:
            throw r1;
     */
    /* JADX WARNING: Missing block: B:193:0x02f3, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:194:0x02f4, code skipped:
            r12 = r1;
     */
    /* JADX WARNING: Missing block: B:195:0x02f5, code skipped:
            if (r15 != null) goto L_0x02f7;
     */
    /* JADX WARNING: Missing block: B:197:?, code skipped:
            $closeResource(r12, r15);
     */
    /* JADX WARNING: Missing block: B:198:0x02fa, code skipped:
            throw r0;
     */
    /* JADX WARNING: Missing block: B:199:0x02fb, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:200:0x02fc, code skipped:
            r21 = r4;
            r4 = r6;
            r16 = r8;
            r6 = r9;
     */
    /* JADX WARNING: Missing block: B:201:0x0302, code skipped:
            monitor-exit(r21);
     */
    /* JADX WARNING: Missing block: B:202:0x0303, code skipped:
            throw r0;
     */
    /* JADX WARNING: Missing block: B:203:0x0304, code skipped:
            r0 = th;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    int deletePackageX(String packageName, long versionCode, int userId, int deleteFlags) {
        PackageRemovedInfo packageRemovedInfo;
        Throwable libEntry;
        Package packageR;
        int i;
        String str = packageName;
        long j = versionCode;
        int i2 = deleteFlags;
        int i3 = -1;
        String str2;
        StringBuilder stringBuilder;
        if (this.mHwPMSEx.isAllowUninstallApp(str)) {
            HwFrameworkFactory.getHwBehaviorCollectManager().sendEvent(2, 0, 0, str, null);
            PackageRemovedInfo info = new PackageRemovedInfo(this);
            int removeUser = (i2 & 2) != 0 ? -1 : userId;
            if (isPackageDeviceAdmin(str, removeUser)) {
                str2 = TAG;
                stringBuilder = new StringBuilder();
                stringBuilder.append("Not removing package ");
                stringBuilder.append(str);
                stringBuilder.append(": has active device admin");
                Slog.w(str2, stringBuilder.toString());
                return -2;
            }
            if (HwDeviceManager.disallowOp(5, str)) {
                packageRemovedInfo = info;
            } else if (this.mHwPMSEx == null || !this.mHwPMSEx.isDisallowUninstallApk(str)) {
                synchronized (this.mPackages) {
                    try {
                        PackageSetting uninstalledPs = (PackageSetting) this.mSettings.mPackages.get(str);
                        if (uninstalledPs == null) {
                            try {
                                str2 = TAG;
                                stringBuilder = new StringBuilder();
                                stringBuilder.append("Not removing non-existent package ");
                                stringBuilder.append(str);
                                Slog.w(str2, stringBuilder.toString());
                                return -1;
                            } catch (Throwable th) {
                                libEntry = th;
                                while (true) {
                                    try {
                                        break;
                                    } catch (Throwable th2) {
                                        libEntry = th2;
                                    }
                                }
                                throw libEntry;
                            }
                        } else if (j == -1 || uninstalledPs.versionCode == j) {
                            try {
                                Package pkg = (Package) this.mPackages.get(str);
                                try {
                                    int[] allUsers = sUserManager.getUserIds();
                                    if (pkg != null) {
                                        try {
                                            if (pkg.staticSharedLibName != null) {
                                                SharedLibraryEntry libEntry2 = getSharedLibraryEntryLPr(pkg.staticSharedLibName, pkg.staticSharedLibVersion);
                                                if (libEntry2 != null) {
                                                    int length = allUsers.length;
                                                    int i4 = 0;
                                                    while (i4 < length) {
                                                        int currUserId = allUsers[i4];
                                                        if (removeUser != i3) {
                                                            i3 = currUserId;
                                                            if (removeUser != i3) {
                                                                i4++;
                                                                j = versionCode;
                                                                i3 = -1;
                                                            }
                                                        } else {
                                                            i3 = currUserId;
                                                        }
                                                        List<VersionedPackage> libClientPackages = getPackagesUsingSharedLibraryLPr(libEntry2.info, 0, i3);
                                                        if (ArrayUtils.isEmpty(libClientPackages)) {
                                                            i4++;
                                                            j = versionCode;
                                                            i3 = -1;
                                                        } else {
                                                            String str3 = TAG;
                                                            StringBuilder stringBuilder2 = new StringBuilder();
                                                            stringBuilder2.append("Not removing package ");
                                                            stringBuilder2.append(pkg.manifestPackageName);
                                                            stringBuilder2.append(" hosting lib ");
                                                            stringBuilder2.append(libEntry2.info.getName());
                                                            stringBuilder2.append(" version ");
                                                            stringBuilder2.append(libEntry2.info.getLongVersion());
                                                            stringBuilder2.append(" used by ");
                                                            stringBuilder2.append(libClientPackages);
                                                            stringBuilder2.append(" for user ");
                                                            stringBuilder2.append(i3);
                                                            Slog.w(str3, stringBuilder2.toString());
                                                            return -6;
                                                        }
                                                    }
                                                }
                                            }
                                        } catch (Throwable th3) {
                                            libEntry = th3;
                                            packageR = pkg;
                                            while (true) {
                                                break;
                                            }
                                            throw libEntry;
                                        }
                                    }
                                    info.origUsers = uninstalledPs.queryInstalledUsers(allUsers, true);
                                } catch (Throwable th4) {
                                    libEntry = th4;
                                    Package packageR2 = pkg;
                                    i = removeUser;
                                    packageR = packageR2;
                                    PackageSetting packageSetting = uninstalledPs;
                                    while (true) {
                                        break;
                                    }
                                    throw libEntry;
                                }
                            } catch (Throwable th5) {
                                libEntry = th5;
                                i = removeUser;
                                packageRemovedInfo = info;
                                while (true) {
                                    break;
                                }
                                throw libEntry;
                            }
                        } else {
                            str2 = TAG;
                            stringBuilder = new StringBuilder();
                            stringBuilder.append("Not removing package ");
                            stringBuilder.append(str);
                            stringBuilder.append(" with versionCode ");
                            stringBuilder.append(uninstalledPs.versionCode);
                            stringBuilder.append(" != ");
                            stringBuilder.append(j);
                            Slog.w(str2, stringBuilder.toString());
                            return -1;
                        }
                    } catch (Throwable th6) {
                        libEntry = th6;
                        i = removeUser;
                        packageRemovedInfo = info;
                        while (true) {
                            break;
                        }
                        throw libEntry;
                    }
                }
            }
            stringBuilder = new StringBuilder();
            stringBuilder.append("Not removing package ");
            stringBuilder.append(str);
            stringBuilder.append(": is disallowed!");
            Flog.i(209, stringBuilder.toString());
            return -4;
        }
        str2 = TAG;
        stringBuilder = new StringBuilder();
        stringBuilder.append("Not removing package ");
        stringBuilder.append(str);
        stringBuilder.append(": limited by its own");
        Slog.w(str2, stringBuilder.toString());
        return -1;
        boolean z;
        boolean z2;
        sendIncompatibleNotificationIfNeeded(packageName);
        if ((i2 & 8) == 0) {
            z = true;
        }
        packageRemovedInfo.sendPackageRemovedBroadcasts(z);
        packageRemovedInfo.sendSystemPackageUpdatedBroadcasts();
        packageRemovedInfo.sendSystemPackageAppearedBroadcasts();
        Runtime.getRuntime().gc();
        if (packageRemovedInfo.args != null) {
            if (this.mCustPms == null || !this.mCustPms.isSdInstallEnabled()) {
                synchronized (this.mInstallLock) {
                    z2 = true;
                    packageRemovedInfo.args.doPostDeleteLI(true);
                }
                return res ? z2 : -1;
            }
            this.mHandler.postDelayed(new Runnable() {
                public void run() {
                    synchronized (PackageManagerService.this.mInstallLock) {
                        packageRemovedInfo.args.doPostDeleteLI(true);
                    }
                }
            }, 500);
        }
        z2 = true;
        if (res) {
        }
        return res ? z2 : -1;
    }

    private void removePackageDataLIF(PackageSetting ps, int[] allUserHandles, PackageRemovedInfo outInfo, int flags, boolean writeSettings) {
        Package deletedPkg;
        final PackageSetting deletedPs;
        PackageSetting packageSetting = ps;
        int[] iArr = allUserHandles;
        PackageRemovedInfo packageRemovedInfo = outInfo;
        String packageName = packageSetting.name;
        if (DEBUG_REMOVE) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("removePackageDataLI: ");
            stringBuilder.append(packageSetting);
            Slog.d(str, stringBuilder.toString());
        }
        synchronized (this.mPackages) {
            try {
                deletedPkg = (Package) this.mPackages.get(packageName);
                deletedPs = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (packageRemovedInfo != null) {
                    int[] iArr2;
                    packageRemovedInfo.removedPackage = packageName;
                    packageRemovedInfo.installerPackageName = packageSetting.installerPackageName;
                    boolean z = (deletedPkg == null || deletedPkg.staticSharedLibName == null) ? false : true;
                    packageRemovedInfo.isStaticSharedLib = z;
                    if (deletedPs == null) {
                        iArr2 = null;
                    } else {
                        iArr2 = deletedPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                    }
                    packageRemovedInfo.populateUsers(iArr2, deletedPs);
                }
            } catch (Throwable th) {
                while (true) {
                    throw th;
                }
            }
        }
        Package deletedPkg2 = deletedPkg;
        removePackageLI(packageSetting, (flags & Integer.MIN_VALUE) != 0);
        if ((flags & 1) == 0) {
            if (deletedPkg2 != null) {
                deletedPkg = deletedPkg2;
            } else {
                deletedPkg = new Package(packageSetting.name);
                deletedPkg.setVolumeUuid(packageSetting.volumeUuid);
            }
            destroyAppDataLIF(deletedPkg, -1, 3);
            destroyAppProfilesLIF(deletedPkg, -1);
            if (packageRemovedInfo != null) {
                packageRemovedInfo.dataRemoved = true;
            }
            schedulePackageCleaning(packageName, -1, true);
        } else {
            StringBuilder stringBuilder2 = new StringBuilder();
            stringBuilder2.append("removePackageDataLI : ");
            stringBuilder2.append(packageSetting.name);
            stringBuilder2.append(", keep data");
            Flog.i(206, stringBuilder2.toString());
        }
        int removedAppId = -1;
        synchronized (this.mPackages) {
            boolean installedStateChanged;
            boolean installedStateChanged2 = false;
            if (deletedPs != null) {
                if ((flags & 1) == 0) {
                    try {
                        clearIntentFilterVerificationsLPw(deletedPs.name, -1);
                        clearDefaultBrowserIfNeeded(packageName);
                        this.mSettings.mKeySetManagerService.removeAppKeySetDataLPw(packageName);
                        removedAppId = this.mSettings.removePackageLPw(packageName);
                        if (packageRemovedInfo != null) {
                            packageRemovedInfo.removedAppId = removedAppId;
                        }
                        this.mPermissionManager.updatePermissions(deletedPs.name, null, false, this.mPackages.values(), this.mPermissionCallback);
                        if (deletedPs.sharedUser != null) {
                            int[] userIds = UserManagerService.getInstance().getUserIds();
                            int length = userIds.length;
                            int i = 0;
                            while (i < length) {
                                boolean userIdToKill = this.mSettings.updateSharedUserPermsLPw(deletedPs, userIds[i]);
                                installedStateChanged = installedStateChanged2;
                                if (!userIdToKill) {
                                    if (userIdToKill >= false) {
                                        i++;
                                        installedStateChanged2 = installedStateChanged;
                                    }
                                }
                                this.mHandler.post(new Runnable() {
                                    public void run() {
                                        PackageManagerService.this.killApplication(deletedPs.name, deletedPs.appId, PackageManagerService.KILL_APP_REASON_GIDS_CHANGED);
                                    }
                                });
                                break;
                            }
                        }
                        installedStateChanged = installedStateChanged2;
                        clearPackagePreferredActivitiesLPw(deletedPs.name, -1);
                    } catch (Throwable th2) {
                        while (true) {
                            throw th2;
                        }
                    }
                }
                installedStateChanged = false;
                if (!(iArr == null || packageRemovedInfo == null || packageRemovedInfo.origUsers == null)) {
                    if (DEBUG_REMOVE) {
                        Slog.d(TAG, "Propagating install state across downgrade");
                    }
                    int i2 = 0;
                    int i3;
                    for (int length2 = iArr.length; i2 < length2; length2 = i3) {
                        int userId = iArr[i2];
                        boolean installed = ArrayUtils.contains(packageRemovedInfo.origUsers, userId);
                        if (DEBUG_REMOVE) {
                            String str2 = TAG;
                            StringBuilder stringBuilder3 = new StringBuilder();
                            i3 = length2;
                            stringBuilder3.append("    user ");
                            stringBuilder3.append(userId);
                            stringBuilder3.append(" => ");
                            stringBuilder3.append(installed);
                            Slog.d(str2, stringBuilder3.toString());
                        } else {
                            i3 = length2;
                        }
                        if (installed != packageSetting.getInstalled(userId)) {
                            installedStateChanged = true;
                        }
                        packageSetting.setInstalled(installed, userId);
                        i2++;
                    }
                }
            } else {
                installedStateChanged = false;
            }
            if (writeSettings) {
                this.mSettings.writeLPr();
                writePackagesAbi();
            }
            if (installedStateChanged) {
                this.mSettings.writeKernelMappingLPr(packageSetting);
            }
        }
        if (removedAppId != -1) {
            removeKeystoreDataIfNeeded(-1, removedAppId);
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:11:0x001a A:{Catch:{ IOException -> 0x0076 }} */
    /* JADX WARNING: Removed duplicated region for block: B:10:0x0019 A:{RETURN, Catch:{ IOException -> 0x0076 }} */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    static boolean locationIsPrivileged(String path) {
        boolean z = false;
        try {
            boolean isPrivilegedAppHw;
            File file = new File(path);
            if (!HwServiceFactory.isPrivAppNonSystemPartitionDir(file)) {
                if (!HwServiceFactory.isPrivAppInCust(file)) {
                    isPrivilegedAppHw = false;
                    if (!isPrivilegedAppHw) {
                        return isPrivilegedAppHw;
                    }
                    File privilegedAppDir = new File(Environment.getRootDirectory(), "priv-app");
                    File privilegedVendorAppDir = new File(Environment.getVendorDirectory(), "priv-app");
                    File privilegedOdmAppDir = new File(Environment.getOdmDirectory(), "priv-app");
                    File privilegedProductAppDir = new File(Environment.getProductDirectory(), "priv-app");
                    if (path.startsWith(privilegedAppDir.getCanonicalPath()) || path.startsWith(privilegedVendorAppDir.getCanonicalPath()) || path.startsWith(privilegedOdmAppDir.getCanonicalPath()) || path.startsWith(privilegedProductAppDir.getCanonicalPath())) {
                        z = true;
                    }
                    return z;
                }
            }
            isPrivilegedAppHw = true;
            if (!isPrivilegedAppHw) {
            }
        } catch (IOException e) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Unable to access code path ");
            stringBuilder.append(path);
            Slog.e(str, stringBuilder.toString());
            return false;
        }
    }

    static boolean locationIsOem(String path) {
        try {
            return path.startsWith(Environment.getOemDirectory().getCanonicalPath());
        } catch (IOException e) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Unable to access code path ");
            stringBuilder.append(path);
            Slog.e(str, stringBuilder.toString());
            return false;
        }
    }

    static boolean locationIsVendor(String path) {
        boolean z = false;
        try {
            if (path.startsWith(Environment.getVendorDirectory().getCanonicalPath()) || path.startsWith(Environment.getOdmDirectory().getCanonicalPath()) || HwPackageManagerServiceUtils.hwlocationIsVendor(path)) {
                z = true;
            }
            return z;
        } catch (IOException e) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Unable to access code path ");
            stringBuilder.append(path);
            Slog.e(str, stringBuilder.toString());
            return false;
        }
    }

    static boolean locationIsProduct(String path) {
        boolean z = false;
        try {
            if (path.startsWith(Environment.getProductDirectory().getCanonicalPath()) || HwPackageManagerServiceUtils.hwlocationIsProduct(path)) {
                z = true;
            }
            return z;
        } catch (IOException e) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Unable to access code path ");
            stringBuilder.append(path);
            Slog.e(str, stringBuilder.toString());
            return false;
        }
    }

    /* JADX WARNING: Missing block: B:36:0x0098, code skipped:
            if (isPreRemovableApp(r8.codePath.toString()) == false) goto L_0x00a6;
     */
    /* JADX WARNING: Missing block: B:43:0x00a9, code skipped:
            if (DEBUG_REMOVE == false) goto L_0x00e1;
     */
    /* JADX WARNING: Missing block: B:44:0x00ab, code skipped:
            if (r16 == false) goto L_0x00e1;
     */
    /* JADX WARNING: Missing block: B:45:0x00ad, code skipped:
            android.util.Slog.d(TAG, "Remembering install states:");
            r0 = r12.length;
            r2 = 0;
     */
    /* JADX WARNING: Missing block: B:46:0x00b6, code skipped:
            if (r2 >= r0) goto L_0x00e1;
     */
    /* JADX WARNING: Missing block: B:47:0x00b8, code skipped:
            r3 = r12[r2];
            r4 = com.android.internal.util.ArrayUtils.contains(r13.origUsers, r3);
            r5 = TAG;
            r6 = new java.lang.StringBuilder();
            r6.append("   u=");
            r6.append(r3);
            r6.append(" inst=");
            r6.append(r4);
            android.util.Slog.d(r5, r6.toString());
            r2 = r2 + 1;
     */
    /* JADX WARNING: Missing block: B:48:0x00e1, code skipped:
            if (r13 == null) goto L_0x00e5;
     */
    /* JADX WARNING: Missing block: B:49:0x00e3, code skipped:
            r13.isRemovedPackageSystemUpdate = true;
     */
    /* JADX WARNING: Missing block: B:50:0x00e5, code skipped:
            if (r13 == null) goto L_0x011d;
     */
    /* JADX WARNING: Missing block: B:52:0x00e9, code skipped:
            if (r13.removedChildPackages == null) goto L_0x011d;
     */
    /* JADX WARNING: Missing block: B:54:0x00ed, code skipped:
            if (r11.childPackageNames == null) goto L_0x00f6;
     */
    /* JADX WARNING: Missing block: B:55:0x00ef, code skipped:
            r0 = r11.childPackageNames.size();
     */
    /* JADX WARNING: Missing block: B:56:0x00f6, code skipped:
            r0 = 0;
     */
    /* JADX WARNING: Missing block: B:57:0x00f7, code skipped:
            r2 = 0;
     */
    /* JADX WARNING: Missing block: B:58:0x00f8, code skipped:
            if (r2 >= r0) goto L_0x011d;
     */
    /* JADX WARNING: Missing block: B:59:0x00fa, code skipped:
            r3 = (java.lang.String) r11.childPackageNames.get(r2);
     */
    /* JADX WARNING: Missing block: B:60:0x0104, code skipped:
            if (r8.childPackageNames == null) goto L_0x011a;
     */
    /* JADX WARNING: Missing block: B:62:0x010c, code skipped:
            if (r8.childPackageNames.contains(r3) == false) goto L_0x011a;
     */
    /* JADX WARNING: Missing block: B:63:0x010e, code skipped:
            r4 = (com.android.server.pm.PackageManagerService.PackageRemovedInfo) r13.removedChildPackages.get(r3);
     */
    /* JADX WARNING: Missing block: B:64:0x0116, code skipped:
            if (r4 == null) goto L_0x011a;
     */
    /* JADX WARNING: Missing block: B:65:0x0118, code skipped:
            r4.isRemovedPackageSystemUpdate = true;
     */
    /* JADX WARNING: Missing block: B:66:0x011a, code skipped:
            r2 = r2 + 1;
     */
    /* JADX WARNING: Missing block: B:68:0x0123, code skipped:
            if (r8.versionCode >= r11.versionCode) goto L_0x012a;
     */
    /* JADX WARNING: Missing block: B:69:0x0125, code skipped:
            r0 = r24 & -2;
     */
    /* JADX WARNING: Missing block: B:72:0x012e, code skipped:
            if (isDelapp(r8) != false) goto L_0x0148;
     */
    /* JADX WARNING: Missing block: B:74:0x0134, code skipped:
            if (isDelappInData(r8) != false) goto L_0x0148;
     */
    /* JADX WARNING: Missing block: B:76:0x013a, code skipped:
            if (isDelappInCust(r8) != false) goto L_0x0148;
     */
    /* JADX WARNING: Missing block: B:78:0x0146, code skipped:
            if (isPreRemovableApp(r8.codePath.toString()) == false) goto L_0x0153;
     */
    /* JADX WARNING: Missing block: B:80:0x014e, code skipped:
            if (r8.versionCode != r11.versionCode) goto L_0x0153;
     */
    /* JADX WARNING: Missing block: B:81:0x0150, code skipped:
            r0 = r24 & -2;
     */
    /* JADX WARNING: Missing block: B:82:0x0153, code skipped:
            r0 = r24 | 1;
     */
    /* JADX WARNING: Missing block: B:83:0x0156, code skipped:
            r15 = r8;
     */
    /* JADX WARNING: Missing block: B:84:0x0167, code skipped:
            if (deleteInstalledPackageLIF(r11, true, r0, r12, r13, r26, r8.pkg) != null) goto L_0x016a;
     */
    /* JADX WARNING: Missing block: B:85:0x0169, code skipped:
            return false;
     */
    /* JADX WARNING: Missing block: B:86:0x016a, code skipped:
            r3 = r9.mPackages;
     */
    /* JADX WARNING: Missing block: B:87:0x016c, code skipped:
            monitor-enter(r3);
     */
    /* JADX WARNING: Missing block: B:89:?, code skipped:
            enableSystemPackageLPw(r15.pkg);
            removeNativeBinariesLI(r11);
     */
    /* JADX WARNING: Missing block: B:90:0x0175, code skipped:
            monitor-exit(r3);
     */
    /* JADX WARNING: Missing block: B:92:0x0178, code skipped:
            if (DEBUG_REMOVE == false) goto L_0x0190;
     */
    /* JADX WARNING: Missing block: B:93:0x017a, code skipped:
            r0 = TAG;
            r1 = new java.lang.StringBuilder();
            r1.append("Re-installing system package: ");
            r1.append(r15);
            android.util.Slog.d(r0, r1.toString());
     */
    /* JADX WARNING: Missing block: B:94:0x0190, code skipped:
            r0 = null;
            r18 = false;
     */
    /* JADX WARNING: Missing block: B:96:?, code skipped:
            r7 = new com.android.server.pm.PackageManagerService.PackageRemovedInfo(r9);
     */
    /* JADX WARNING: Missing block: B:97:0x019d, code skipped:
            if (isDelapp(r15) != false) goto L_0x01cd;
     */
    /* JADX WARNING: Missing block: B:99:0x01a3, code skipped:
            if (isDelappInData(r15) != false) goto L_0x01cd;
     */
    /* JADX WARNING: Missing block: B:101:0x01a9, code skipped:
            if (isDelappInCust(r15) != false) goto L_0x01cd;
     */
    /* JADX WARNING: Missing block: B:103:0x01b5, code skipped:
            if (isPreRemovableApp(r15.codePath.toString()) == false) goto L_0x01b9;
     */
    /* JADX WARNING: Missing block: B:104:0x01b7, code skipped:
            r14 = r7;
     */
    /* JADX WARNING: Missing block: B:105:0x01b9, code skipped:
            r14 = r7;
            r0 = installPackageFromSystemLIF(r15.codePathString, false, r12, r13.origUsers, r22.getPermissionsState(), r26);
     */
    /* JADX WARNING: Missing block: B:106:0x01cd, code skipped:
            r14 = r7;
     */
    /* JADX WARNING: Missing block: B:107:0x01ce, code skipped:
            recordUninstalledDelapp(r10.packageName, r15.codePathString);
            r14.removedPackage = r10.packageName;
     */
    /* JADX WARNING: Missing block: B:108:0x01d9, code skipped:
            if (r13 == null) goto L_0x01de;
     */
    /* JADX WARNING: Missing block: B:109:0x01db, code skipped:
            r13.isRemovedPackageSystemUpdate = false;
     */
    /* JADX WARNING: Missing block: B:110:0x01de, code skipped:
            r14.sendPackageRemovedBroadcasts(true);
     */
    /* JADX WARNING: Missing block: B:111:0x01e2, code skipped:
            r18 = true;
     */
    /* JADX WARNING: Missing block: B:112:0x01e4, code skipped:
            if (r0 != null) goto L_0x020b;
     */
    /* JADX WARNING: Missing block: B:113:0x01e6, code skipped:
            if (r18 == false) goto L_0x01fb;
     */
    /* JADX WARNING: Missing block: B:115:0x01ee, code skipped:
            if (r15.pkg.isStub == false) goto L_0x01f9;
     */
    /* JADX WARNING: Missing block: B:116:0x01f0, code skipped:
            r4 = true;
            r9.mSettings.disableSystemPackageLPw(r15.name, true);
     */
    /* JADX WARNING: Missing block: B:117:0x01f9, code skipped:
            r4 = true;
     */
    /* JADX WARNING: Missing block: B:118:0x01fa, code skipped:
            return r4;
     */
    /* JADX WARNING: Missing block: B:120:0x0200, code skipped:
            if (r15.pkg.isStub == false) goto L_0x0209;
     */
    /* JADX WARNING: Missing block: B:121:0x0202, code skipped:
            r9.mSettings.disableSystemPackageLPw(r15.name, true);
     */
    /* JADX WARNING: Missing block: B:123:0x020a, code skipped:
            return false;
     */
    /* JADX WARNING: Missing block: B:125:0x020f, code skipped:
            if (r15.pkg.isStub == false) goto L_0x021a;
     */
    /* JADX WARNING: Missing block: B:126:0x0211, code skipped:
            r2 = true;
            r9.mSettings.disableSystemPackageLPw(r15.name, true);
     */
    /* JADX WARNING: Missing block: B:127:0x021a, code skipped:
            r2 = true;
     */
    /* JADX WARNING: Missing block: B:128:0x021b, code skipped:
            return r2;
     */
    /* JADX WARNING: Missing block: B:130:0x021e, code skipped:
            r0 = move-exception;
     */
    /* JADX WARNING: Missing block: B:132:?, code skipped:
            r1 = TAG;
            r2 = new java.lang.StringBuilder();
            r2.append("Failed to restore system package:");
            r2.append(r10.packageName);
            r2.append(": ");
            r2.append(r0.getMessage());
            android.util.Slog.w(r1, r2.toString());
     */
    /* JADX WARNING: Missing block: B:134:0x0253, code skipped:
            return false;
     */
    /* JADX WARNING: Missing block: B:136:0x0258, code skipped:
            if (r15.pkg.isStub != false) goto L_0x025a;
     */
    /* JADX WARNING: Missing block: B:137:0x025a, code skipped:
            r9.mSettings.disableSystemPackageLPw(r15.name, true);
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private boolean deleteSystemPackageLIF(Package deletedPkg, PackageSetting deletedPs, int[] allUserHandles, int flags, PackageRemovedInfo outInfo, boolean writeSettings) {
        Throwable th;
        Package packageR = deletedPkg;
        PackageSetting packageSetting = deletedPs;
        int[] iArr = allUserHandles;
        PackageRemovedInfo packageRemovedInfo = outInfo;
        String str;
        StringBuilder stringBuilder;
        if (packageSetting.parentPackageName != null) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("Attempt to delete child system package ");
            stringBuilder.append(packageR.packageName);
            Slog.w(str, stringBuilder.toString());
            return false;
        }
        PackageSetting disabledPs;
        boolean z = (iArr == null || packageRemovedInfo.origUsers == null) ? false : true;
        boolean applyUserRestrictions = z;
        synchronized (this.mPackages) {
            disabledPs = this.mSettings.getDisabledSystemPkgLPr(packageSetting.name);
        }
        if (DEBUG_REMOVE) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("deleteSystemPackageLI: newPs=");
            stringBuilder.append(packageR.packageName);
            stringBuilder.append(" disabledPs=");
            stringBuilder.append(disabledPs);
            Slog.d(str, stringBuilder.toString());
        }
        PackageSetting packageSetting2;
        if (disabledPs == null) {
        } else if (disabledPs.pkg == null) {
            packageSetting2 = disabledPs;
        } else {
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "Deleting system pkg from data partition");
            }
            synchronized (this.mPackages) {
                try {
                    if (!isDelapp(disabledPs)) {
                        try {
                            if (!isDelappInData(disabledPs)) {
                                if (!isDelappInCust(disabledPs)) {
                                }
                            }
                        } catch (Throwable th2) {
                            th = th2;
                            packageSetting2 = disabledPs;
                            while (true) {
                                try {
                                    break;
                                } catch (Throwable th3) {
                                    th = th3;
                                }
                            }
                            throw th;
                        }
                    }
                    this.mSettings.removeDisabledSystemPackageLPw(packageSetting.name);
                } catch (Throwable th4) {
                    th = th4;
                    packageSetting2 = disabledPs;
                    while (true) {
                        break;
                    }
                    throw th;
                }
            }
        }
        str = TAG;
        stringBuilder = new StringBuilder();
        stringBuilder.append("Attempt to delete unknown system package ");
        stringBuilder.append(packageR.packageName);
        Slog.w(str, stringBuilder.toString());
        return false;
    }

    /* JADX WARNING: Missing block: B:60:0x0136, code skipped:
            return r1;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private Package installPackageFromSystemLIF(String codePathString, boolean isPrivileged, int[] allUserHandles, int[] origUserHandles, PermissionsState origPermissionState, boolean writeSettings) throws PackageManagerException {
        Throwable th;
        int[] iArr = allUserHandles;
        int[] iArr2 = origUserHandles;
        PermissionsState permissionsState = origPermissionState;
        boolean z = true;
        int parseFlags = (this.mDefParseFlags | 1) | 16;
        int scanFlags = 131072;
        if (isPrivileged || locationIsPrivileged(codePathString)) {
            scanFlags = 131072 | 262144;
        }
        if (locationIsOem(codePathString)) {
            scanFlags |= 524288;
        }
        if (locationIsVendor(codePathString)) {
            scanFlags |= 1048576;
        }
        if (locationIsProduct(codePathString)) {
            scanFlags |= 2097152;
        }
        int scanFlags2 = scanFlags;
        File codePath = new File(codePathString);
        Package pkg = scanPackageTracedLI(codePath, parseFlags, scanFlags2 | 8192, 0, null);
        try {
            updateSharedLibrariesLPr(pkg, null);
        } catch (PackageManagerException e) {
            PackageManagerException packageManagerException = e;
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("updateAllSharedLibrariesLPw failed: ");
            stringBuilder.append(e.getMessage());
            Slog.e(str, stringBuilder.toString());
        }
        prepareAppDataAfterInstallLIF(pkg);
        synchronized (this.mPackages) {
            File file;
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(pkg.packageName);
            if (permissionsState != null) {
                try {
                    ps.getPermissionsState().copyFrom(permissionsState);
                } catch (Throwable th2) {
                    th = th2;
                    file = codePath;
                }
            }
            try {
                PermissionManagerInternal permissionManagerInternal = this.mPermissionManager;
                permissionManagerInternal.updatePermissions(pkg.packageName, pkg, true, this.mPackages.values(), this.mPermissionCallback);
                if (iArr == null || iArr2 == null) {
                    z = false;
                }
                boolean applyUserRestrictions = z;
                boolean applyUserRestrictions2;
                if (applyUserRestrictions) {
                    if (DEBUG_REMOVE) {
                        Slog.d(TAG, "Propagating install state across reinstall");
                    }
                    z = false;
                    int installedStateChanged = 0;
                    int i;
                    for (int length = iArr.length; installedStateChanged < length; length = i) {
                        boolean installed;
                        int userId = iArr[installedStateChanged];
                        boolean installed2 = ArrayUtils.contains(iArr2, userId);
                        if (DEBUG_REMOVE) {
                            file = codePath;
                            codePath = TAG;
                            applyUserRestrictions2 = applyUserRestrictions;
                            StringBuilder stringBuilder2 = new StringBuilder();
                            i = length;
                            stringBuilder2.append("    user ");
                            stringBuilder2.append(userId);
                            stringBuilder2.append(" => ");
                            installed = installed2;
                            stringBuilder2.append(installed);
                            Slog.d(codePath, stringBuilder2.toString());
                        } else {
                            file = codePath;
                            applyUserRestrictions2 = applyUserRestrictions;
                            i = length;
                            installed = installed2;
                        }
                        if (installed != ps.getInstalled(userId)) {
                            z = true;
                        }
                        ps.setInstalled(installed, userId);
                        this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
                        installedStateChanged++;
                        codePath = file;
                        applyUserRestrictions = applyUserRestrictions2;
                    }
                    applyUserRestrictions2 = applyUserRestrictions;
                    this.mSettings.writeAllUsersPackageRestrictionsLPr();
                    if (z) {
                        this.mSettings.writeKernelMappingLPr(ps);
                    }
                } else {
                    applyUserRestrictions2 = applyUserRestrictions;
                }
                if (writeSettings) {
                    this.mSettings.writeLPr();
                }
            } catch (Throwable th3) {
                th = th3;
                throw th;
            }
        }
    }

    /* JADX WARNING: Missing block: B:26:0x0051, code skipped:
            removePackageDataLIF(r8, r17, r9, r16, r19);
     */
    /* JADX WARNING: Missing block: B:27:0x005f, code skipped:
            if (r8.childPackageNames == null) goto L_0x0068;
     */
    /* JADX WARNING: Missing block: B:28:0x0061, code skipped:
            r1 = r8.childPackageNames.size();
     */
    /* JADX WARNING: Missing block: B:29:0x0068, code skipped:
            r1 = 0;
     */
    /* JADX WARNING: Missing block: B:30:0x0069, code skipped:
            r11 = r1;
     */
    /* JADX WARNING: Missing block: B:31:0x006b, code skipped:
            r12 = r0;
     */
    /* JADX WARNING: Missing block: B:32:0x006c, code skipped:
            if (r12 >= r11) goto L_0x00b8;
     */
    /* JADX WARNING: Missing block: B:33:0x006e, code skipped:
            r1 = r7.mPackages;
     */
    /* JADX WARNING: Missing block: B:34:0x0070, code skipped:
            monitor-enter(r1);
     */
    /* JADX WARNING: Missing block: B:36:?, code skipped:
            r0 = r7.mSettings.getPackageLPr((java.lang.String) r8.childPackageNames.get(r12));
     */
    /* JADX WARNING: Missing block: B:37:0x007f, code skipped:
            monitor-exit(r1);
     */
    /* JADX WARNING: Missing block: B:38:0x0080, code skipped:
            if (r0 == null) goto L_0x00b2;
     */
    /* JADX WARNING: Missing block: B:39:0x0082, code skipped:
            if (r9 == null) goto L_0x0093;
     */
    /* JADX WARNING: Missing block: B:41:0x0086, code skipped:
            if (r9.removedChildPackages == null) goto L_0x0093;
     */
    /* JADX WARNING: Missing block: B:42:0x0088, code skipped:
            r1 = (com.android.server.pm.PackageManagerService.PackageRemovedInfo) r9.removedChildPackages.get(r0.name);
     */
    /* JADX WARNING: Missing block: B:43:0x0093, code skipped:
            r1 = null;
     */
    /* JADX WARNING: Missing block: B:44:0x0094, code skipped:
            r4 = r1;
     */
    /* JADX WARNING: Missing block: B:45:0x0097, code skipped:
            if ((r16 & 1) == 0) goto L_0x00a7;
     */
    /* JADX WARNING: Missing block: B:46:0x0099, code skipped:
            if (r10 == null) goto L_0x00a7;
     */
    /* JADX WARNING: Missing block: B:48:0x00a1, code skipped:
            if (r10.hasChildPackage(r0.name) != false) goto L_0x00a7;
     */
    /* JADX WARNING: Missing block: B:49:0x00a3, code skipped:
            r5 = r16 & -2;
     */
    /* JADX WARNING: Missing block: B:50:0x00a7, code skipped:
            r5 = r16;
     */
    /* JADX WARNING: Missing block: B:51:0x00a9, code skipped:
            removePackageDataLIF(r0, r17, r4, r5, r19);
     */
    /* JADX WARNING: Missing block: B:52:0x00b2, code skipped:
            r0 = r12 + 1;
     */
    /* JADX WARNING: Missing block: B:58:0x00ba, code skipped:
            if (r8.parentPackageName != null) goto L_0x00d2;
     */
    /* JADX WARNING: Missing block: B:59:0x00bc, code skipped:
            if (r15 == false) goto L_0x00d2;
     */
    /* JADX WARNING: Missing block: B:60:0x00be, code skipped:
            if (r9 == null) goto L_0x00d2;
     */
    /* JADX WARNING: Missing block: B:61:0x00c0, code skipped:
            r9.args = createInstallArgsForExisting(packageFlagsToInstallFlags(r8), r8.codePathString, r8.resourcePathString, com.android.server.pm.InstructionSets.getAppDexInstructionSets(r8));
     */
    /* JADX WARNING: Missing block: B:63:0x00d3, code skipped:
            return true;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private boolean deleteInstalledPackageLIF(PackageSetting ps, boolean deleteCodeAndResources, int flags, int[] allUserHandles, PackageRemovedInfo outInfo, boolean writeSettings, Package replacingPackage) {
        PackageSetting packageSetting = ps;
        PackageRemovedInfo packageRemovedInfo = outInfo;
        Package packageR = replacingPackage;
        synchronized (this.mPackages) {
            if (packageRemovedInfo != null) {
                try {
                    packageRemovedInfo.uid = packageSetting.appId;
                } catch (Throwable th) {
                    while (true) {
                    }
                }
            }
            int i = 0;
            if (!(packageRemovedInfo == null || packageRemovedInfo.removedChildPackages == null)) {
                int childCount = packageSetting.childPackageNames != null ? packageSetting.childPackageNames.size() : 0;
                for (int i2 = 0; i2 < childCount; i2++) {
                    String childPackageName = (String) packageSetting.childPackageNames.get(i2);
                    PackageSetting childPs = (PackageSetting) this.mSettings.mPackages.get(childPackageName);
                    if (childPs == null) {
                        return false;
                    }
                    PackageRemovedInfo childInfo = (PackageRemovedInfo) packageRemovedInfo.removedChildPackages.get(childPackageName);
                    if (childInfo != null) {
                        childInfo.uid = childPs.appId;
                    }
                }
            }
        }
    }

    public boolean setBlockUninstallForUser(String packageName, boolean blockUninstall, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.DELETE_PACKAGES", null);
        synchronized (this.mPackages) {
            Package pkg = (Package) this.mPackages.get(packageName);
            if (pkg == null || pkg.staticSharedLibName == null) {
                this.mSettings.setBlockUninstallLPw(userId, packageName, blockUninstall);
                this.mSettings.writePackageRestrictionsLPr(userId);
                return true;
            }
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Cannot block uninstall of package: ");
            stringBuilder.append(packageName);
            stringBuilder.append(" providing static shared library: ");
            stringBuilder.append(pkg.staticSharedLibName);
            Slog.w(str, stringBuilder.toString());
            return false;
        }
    }

    public boolean getBlockUninstallForUser(String packageName, int userId) {
        synchronized (this.mPackages) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (ps != null) {
                if (!filterAppAccessLPr(ps, Binder.getCallingUid(), userId)) {
                    boolean blockUninstallLPr = this.mSettings.getBlockUninstallLPr(userId, packageName);
                    return blockUninstallLPr;
                }
            }
            return false;
        }
    }

    public boolean setRequiredForSystemUser(String packageName, boolean systemUserApp) {
        enforceSystemOrRoot("setRequiredForSystemUser can only be run by the system or root");
        synchronized (this.mPackages) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Package doesn't exist: ");
                stringBuilder.append(packageName);
                Log.w(str, stringBuilder.toString());
                return false;
            }
            if (systemUserApp) {
                ps.pkgPrivateFlags |= 512;
            } else {
                ps.pkgPrivateFlags &= -513;
            }
            this.mSettings.writeLPr();
            return true;
        }
    }

    /* JADX WARNING: Missing block: B:39:0x00c3, code skipped:
            if (DEBUG_REMOVE == false) goto L_0x00f5;
     */
    /* JADX WARNING: Missing block: B:40:0x00c5, code skipped:
            r3 = new java.lang.StringBuilder();
            r3.append("deletePackageLI: pkg ");
            r3.append(r10);
            r3.append(" isSysApp: ");
            r3.append(isSystemApp(r14));
            r3.append(" hwflag: ");
            r3.append(r14.pkg.applicationInfo.hwFlags);
            android.util.Flog.i(209, r3.toString());
     */
    /* JADX WARNING: Missing block: B:42:0x00fd, code skipped:
            if (isSystemApp(r14) == false) goto L_0x0113;
     */
    /* JADX WARNING: Missing block: B:44:0x0106, code skipped:
            if ((r14.pkg.applicationInfo.hwFlags & com.android.server.pm.DumpState.DUMP_HANDLE) != 0) goto L_0x0111;
     */
    /* JADX WARNING: Missing block: B:46:0x010f, code skipped:
            if ((r14.pkg.applicationInfo.hwFlags & 67108864) == 0) goto L_0x0113;
     */
    /* JADX WARNING: Missing block: B:47:0x0111, code skipped:
            r2 = true;
     */
    /* JADX WARNING: Missing block: B:48:0x0113, code skipped:
            r2 = false;
     */
    /* JADX WARNING: Missing block: B:50:0x0116, code skipped:
            if (r2 == false) goto L_0x0149;
     */
    /* JADX WARNING: Missing block: B:51:0x0118, code skipped:
            if (r11 == null) goto L_0x0149;
     */
    /* JADX WARNING: Missing block: B:53:0x011e, code skipped:
            if (r23.getIdentifier() == -1) goto L_0x0149;
     */
    /* JADX WARNING: Missing block: B:55:0x0127, code skipped:
            if (sUserManager.getUserIds().length <= 1) goto L_0x0149;
     */
    /* JADX WARNING: Missing block: B:56:0x0129, code skipped:
            r2 = r14.queryInstalledUsers(sUserManager.getUserIds(), true);
     */
    /* JADX WARNING: Missing block: B:57:0x0134, code skipped:
            if (r2.length == 0) goto L_0x0144;
     */
    /* JADX WARNING: Missing block: B:59:0x0137, code skipped:
            if (r2.length != 1) goto L_0x0142;
     */
    /* JADX WARNING: Missing block: B:61:0x013f, code skipped:
            if (r2[0] != r23.getIdentifier()) goto L_0x0142;
     */
    /* JADX WARNING: Missing block: B:62:0x0142, code skipped:
            r6 = false;
     */
    /* JADX WARNING: Missing block: B:63:0x0144, code skipped:
            r6 = true;
     */
    /* JADX WARNING: Missing block: B:64:0x0145, code skipped:
            if (r6 != false) goto L_0x0149;
     */
    /* JADX WARNING: Missing block: B:65:0x0147, code skipped:
            r1 = r1 | 4;
     */
    /* JADX WARNING: Missing block: B:66:0x0149, code skipped:
            r17 = r1;
     */
    /* JADX WARNING: Missing block: B:67:0x014b, code skipped:
            if (r11 != null) goto L_0x014f;
     */
    /* JADX WARNING: Missing block: B:68:0x014d, code skipped:
            r1 = -1;
     */
    /* JADX WARNING: Missing block: B:69:0x014f, code skipped:
            r1 = r23.getIdentifier();
     */
    /* JADX WARNING: Missing block: B:70:0x0153, code skipped:
            r8 = r1;
     */
    /* JADX WARNING: Missing block: B:71:0x015e, code skipped:
            if (r14.getPermissionsState().hasPermission("android.permission.SUSPEND_APPS", r8) == false) goto L_0x0163;
     */
    /* JADX WARNING: Missing block: B:72:0x0160, code skipped:
            unsuspendForSuspendingPackage(r10, r8);
     */
    /* JADX WARNING: Missing block: B:74:0x0167, code skipped:
            if (isSystemApp(r14) == false) goto L_0x016d;
     */
    /* JADX WARNING: Missing block: B:76:0x016b, code skipped:
            if ((r17 & 4) == 0) goto L_0x0221;
     */
    /* JADX WARNING: Missing block: B:77:0x016d, code skipped:
            if (r11 == null) goto L_0x0221;
     */
    /* JADX WARNING: Missing block: B:79:0x0173, code skipped:
            if (r23.getIdentifier() == -1) goto L_0x0221;
     */
    /* JADX WARNING: Missing block: B:80:0x0175, code skipped:
            markPackageUninstalledForUserLPw(r14, r11);
     */
    /* JADX WARNING: Missing block: B:81:0x017c, code skipped:
            if (isSystemApp(r14) != false) goto L_0x01c4;
     */
    /* JADX WARNING: Missing block: B:82:0x017e, code skipped:
            r1 = shouldKeepUninstalledPackageLPr(r22);
     */
    /* JADX WARNING: Missing block: B:83:0x018c, code skipped:
            if (r14.isAnyInstalled(sUserManager.getUserIds()) != false) goto L_0x01aa;
     */
    /* JADX WARNING: Missing block: B:84:0x018e, code skipped:
            if (r1 == false) goto L_0x0191;
     */
    /* JADX WARNING: Missing block: B:86:0x0193, code skipped:
            if (DEBUG_REMOVE == false) goto L_0x019c;
     */
    /* JADX WARNING: Missing block: B:87:0x0195, code skipped:
            android.util.Slog.d(TAG, "Not installed by other users, full delete");
     */
    /* JADX WARNING: Missing block: B:88:0x019c, code skipped:
            r14.setInstalled(true, r23.getIdentifier());
            r9.mSettings.writeKernelMappingLPr(r14);
     */
    /* JADX WARNING: Missing block: B:90:0x01ac, code skipped:
            if (DEBUG_REMOVE == false) goto L_0x01b5;
     */
    /* JADX WARNING: Missing block: B:91:0x01ae, code skipped:
            android.util.Slog.d(TAG, "Still installed by other users");
     */
    /* JADX WARNING: Missing block: B:93:0x01bd, code skipped:
            if (clearPackageStateForUserLIF(r14, r23.getIdentifier(), r13) != false) goto L_0x01c0;
     */
    /* JADX WARNING: Missing block: B:94:0x01bf, code skipped:
            return false;
     */
    /* JADX WARNING: Missing block: B:95:0x01c0, code skipped:
            scheduleWritePackageRestrictionsLocked(r11);
     */
    /* JADX WARNING: Missing block: B:96:0x01c3, code skipped:
            return true;
     */
    /* JADX WARNING: Missing block: B:98:0x01c6, code skipped:
            if (DEBUG_REMOVE == false) goto L_0x01cf;
     */
    /* JADX WARNING: Missing block: B:99:0x01c8, code skipped:
            android.util.Slog.d(TAG, "Deleting system app");
     */
    /* JADX WARNING: Missing block: B:101:0x01d7, code skipped:
            if (clearPackageStateForUserLIF(r14, r23.getIdentifier(), r13) != false) goto L_0x01da;
     */
    /* JADX WARNING: Missing block: B:102:0x01d9, code skipped:
            return false;
     */
    /* JADX WARNING: Missing block: B:104:0x01e1, code skipped:
            if ((r14.pkg.applicationInfo.hwFlags & com.android.server.pm.DumpState.DUMP_HANDLE) == 0) goto L_0x01e5;
     */
    /* JADX WARNING: Missing block: B:105:0x01e3, code skipped:
            r1 = true;
     */
    /* JADX WARNING: Missing block: B:106:0x01e5, code skipped:
            r1 = false;
     */
    /* JADX WARNING: Missing block: B:108:0x01ed, code skipped:
            if ((r14.pkg.applicationInfo.hwFlags & 67108864) == 0) goto L_0x01f1;
     */
    /* JADX WARNING: Missing block: B:109:0x01ef, code skipped:
            r0 = true;
     */
    /* JADX WARNING: Missing block: B:110:0x01f1, code skipped:
            r2 = r0;
     */
    /* JADX WARNING: Missing block: B:111:0x01f2, code skipped:
            if (r1 == false) goto L_0x0200;
     */
    /* JADX WARNING: Missing block: B:112:0x01f4, code skipped:
            recordUninstalledDelapp(r14.pkg.packageName, r14.pkg.codePath);
     */
    /* JADX WARNING: Missing block: B:113:0x0200, code skipped:
            if (r2 == false) goto L_0x021d;
     */
    /* JADX WARNING: Missing block: B:114:0x0202, code skipped:
            r3 = r9.mPackages;
     */
    /* JADX WARNING: Missing block: B:115:0x0204, code skipped:
            monitor-enter(r3);
     */
    /* JADX WARNING: Missing block: B:117:?, code skipped:
            r0 = r9.mSettings.getDisabledSystemPkgLPr(r14.pkg.packageName);
     */
    /* JADX WARNING: Missing block: B:118:0x020f, code skipped:
            monitor-exit(r3);
     */
    /* JADX WARNING: Missing block: B:119:0x0210, code skipped:
            recordUninstalledDelapp(r14.pkg.packageName, r0.codePathString);
     */
    /* JADX WARNING: Missing block: B:124:0x021d, code skipped:
            scheduleWritePackageRestrictionsLocked(r11);
     */
    /* JADX WARNING: Missing block: B:125:0x0220, code skipped:
            return true;
     */
    /* JADX WARNING: Missing block: B:127:0x0223, code skipped:
            if (r14.childPackageNames == null) goto L_0x0269;
     */
    /* JADX WARNING: Missing block: B:128:0x0225, code skipped:
            if (r13 == null) goto L_0x0269;
     */
    /* JADX WARNING: Missing block: B:129:0x0227, code skipped:
            r1 = r9.mPackages;
     */
    /* JADX WARNING: Missing block: B:130:0x0229, code skipped:
            monitor-enter(r1);
     */
    /* JADX WARNING: Missing block: B:132:?, code skipped:
            r2 = r14.childPackageNames.size();
            r13.removedChildPackages = new android.util.ArrayMap(r2);
            r3 = 0;
     */
    /* JADX WARNING: Missing block: B:133:0x0238, code skipped:
            if (r3 >= r2) goto L_0x0264;
     */
    /* JADX WARNING: Missing block: B:134:0x023a, code skipped:
            r4 = (java.lang.String) r14.childPackageNames.get(r3);
            r6 = new com.android.server.pm.PackageManagerService.PackageRemovedInfo(r9);
            r6.removedPackage = r4;
            r6.installerPackageName = r14.installerPackageName;
            r13.removedChildPackages.put(r4, r6);
            r7 = r9.mSettings.getPackageLPr(r4);
     */
    /* JADX WARNING: Missing block: B:135:0x0258, code skipped:
            if (r7 == null) goto L_0x0260;
     */
    /* JADX WARNING: Missing block: B:136:0x025a, code skipped:
            r6.origUsers = r7.queryInstalledUsers(r12, true);
     */
    /* JADX WARNING: Missing block: B:137:0x0260, code skipped:
            r3 = r3 + 1;
     */
    /* JADX WARNING: Missing block: B:138:0x0264, code skipped:
            monitor-exit(r1);
     */
    /* JADX WARNING: Missing block: B:144:0x026c, code skipped:
            if (r14.pkg != null) goto L_0x0277;
     */
    /* JADX WARNING: Missing block: B:145:0x026e, code skipped:
            android.util.Slog.w(TAG, "ps.pkg is null!");
     */
    /* JADX WARNING: Missing block: B:146:0x0276, code skipped:
            return false;
     */
    /* JADX WARNING: Missing block: B:148:0x027b, code skipped:
            if (r14.pkg.applicationInfo != null) goto L_0x0286;
     */
    /* JADX WARNING: Missing block: B:149:0x027d, code skipped:
            android.util.Slog.w(TAG, "ps.pkg.applicationInfo is null!");
     */
    /* JADX WARNING: Missing block: B:150:0x0285, code skipped:
            return false;
     */
    /* JADX WARNING: Missing block: B:152:0x028a, code skipped:
            if (isSystemApp(r14) == false) goto L_0x02c4;
     */
    /* JADX WARNING: Missing block: B:154:0x0293, code skipped:
            if ((r14.pkg.applicationInfo.hwFlags & com.android.server.pm.DumpState.DUMP_HANDLE) != 0) goto L_0x02c4;
     */
    /* JADX WARNING: Missing block: B:156:0x0297, code skipped:
            if (DEBUG_REMOVE == false) goto L_0x02b1;
     */
    /* JADX WARNING: Missing block: B:157:0x0299, code skipped:
            r1 = TAG;
            r2 = new java.lang.StringBuilder();
            r2.append("Removing system package: ");
            r2.append(r14.name);
            android.util.Slog.d(r1, r2.toString());
     */
    /* JADX WARNING: Missing block: B:158:0x02b1, code skipped:
            r1 = deleteSystemPackageLIF(r14.pkg, r14, r12, r17, r13, r28);
            r20 = r8;
     */
    /* JADX WARNING: Missing block: B:160:0x02c6, code skipped:
            if (DEBUG_REMOVE == false) goto L_0x02e0;
     */
    /* JADX WARNING: Missing block: B:161:0x02c8, code skipped:
            r1 = TAG;
            r2 = new java.lang.StringBuilder();
            r2.append("Removing non-system package: ");
            r2.append(r14.name);
            android.util.Slog.d(r1, r2.toString());
     */
    /* JADX WARNING: Missing block: B:162:0x02e0, code skipped:
            r1 = false;
     */
    /* JADX WARNING: Missing block: B:163:0x02e8, code skipped:
            if ((r14.pkg.applicationInfo.hwFlags & com.android.server.pm.DumpState.DUMP_HANDLE) == 0) goto L_0x02eb;
     */
    /* JADX WARNING: Missing block: B:164:0x02ea, code skipped:
            r1 = true;
     */
    /* JADX WARNING: Missing block: B:165:0x02eb, code skipped:
            r18 = r1;
     */
    /* JADX WARNING: Missing block: B:166:0x02ef, code skipped:
            if ((r17 & 8) != 0) goto L_0x02f3;
     */
    /* JADX WARNING: Missing block: B:167:0x02f1, code skipped:
            r1 = true;
     */
    /* JADX WARNING: Missing block: B:168:0x02f3, code skipped:
            r1 = false;
     */
    /* JADX WARNING: Missing block: B:170:0x02f6, code skipped:
            if (r1 == false) goto L_0x0300;
     */
    /* JADX WARNING: Missing block: B:171:0x02f8, code skipped:
            killApplication(r10, r14.appId, "uninstall pkg");
     */
    /* JADX WARNING: Missing block: B:172:0x0300, code skipped:
            r20 = r8;
            r1 = deleteInstalledPackageLIF(r14, r24, r17, r12, r13, r28, r29);
     */
    /* JADX WARNING: Missing block: B:173:0x0312, code skipped:
            if (r18 == false) goto L_0x0321;
     */
    /* JADX WARNING: Missing block: B:174:0x0314, code skipped:
            if (r1 == false) goto L_0x0321;
     */
    /* JADX WARNING: Missing block: B:175:0x0316, code skipped:
            recordUninstalledDelapp(r14.pkg.packageName, r14.pkg.codePath);
     */
    /* JADX WARNING: Missing block: B:176:0x0321, code skipped:
            if (r1 == false) goto L_0x0331;
     */
    /* JADX WARNING: Missing block: B:177:0x0323, code skipped:
            r2 = r9.mPackages;
     */
    /* JADX WARNING: Missing block: B:178:0x0325, code skipped:
            monitor-enter(r2);
     */
    /* JADX WARNING: Missing block: B:180:?, code skipped:
            updateCertCompatPackage(r14.pkg, null);
     */
    /* JADX WARNING: Missing block: B:181:0x032c, code skipped:
            monitor-exit(r2);
     */
    /* JADX WARNING: Missing block: B:186:0x0331, code skipped:
            if (r1 == false) goto L_0x033f;
     */
    /* JADX WARNING: Missing block: B:187:0x0333, code skipped:
            r2 = r9.mPackages;
     */
    /* JADX WARNING: Missing block: B:188:0x0335, code skipped:
            monitor-enter(r2);
     */
    /* JADX WARNING: Missing block: B:189:0x0336, code skipped:
            r0 = false;
     */
    /* JADX WARNING: Missing block: B:191:?, code skipped:
            writeCertCompatPackages(false);
     */
    /* JADX WARNING: Missing block: B:192:0x033a, code skipped:
            monitor-exit(r2);
     */
    /* JADX WARNING: Missing block: B:197:0x033f, code skipped:
            r0 = false;
     */
    /* JADX WARNING: Missing block: B:198:0x0340, code skipped:
            if (r13 == null) goto L_0x03f8;
     */
    /* JADX WARNING: Missing block: B:200:0x034a, code skipped:
            if (r9.mPackages.get(r14.name) != null) goto L_0x034e;
     */
    /* JADX WARNING: Missing block: B:201:0x034c, code skipped:
            r2 = true;
     */
    /* JADX WARNING: Missing block: B:202:0x034e, code skipped:
            r2 = r0;
     */
    /* JADX WARNING: Missing block: B:203:0x034f, code skipped:
            r13.removedForAllUsers = r2;
     */
    /* JADX WARNING: Missing block: B:204:0x0353, code skipped:
            if (r13.removedChildPackages == null) goto L_0x0382;
     */
    /* JADX WARNING: Missing block: B:205:0x0355, code skipped:
            r2 = r9.mPackages;
     */
    /* JADX WARNING: Missing block: B:206:0x0357, code skipped:
            monitor-enter(r2);
     */
    /* JADX WARNING: Missing block: B:208:?, code skipped:
            r3 = r13.removedChildPackages.size();
            r4 = r0;
     */
    /* JADX WARNING: Missing block: B:209:0x035f, code skipped:
            if (r4 >= r3) goto L_0x037d;
     */
    /* JADX WARNING: Missing block: B:210:0x0361, code skipped:
            r5 = (com.android.server.pm.PackageManagerService.PackageRemovedInfo) r13.removedChildPackages.valueAt(r4);
     */
    /* JADX WARNING: Missing block: B:211:0x0369, code skipped:
            if (r5 == null) goto L_0x037a;
     */
    /* JADX WARNING: Missing block: B:213:0x0373, code skipped:
            if (r9.mPackages.get(r5.removedPackage) != null) goto L_0x0377;
     */
    /* JADX WARNING: Missing block: B:214:0x0375, code skipped:
            r6 = true;
     */
    /* JADX WARNING: Missing block: B:215:0x0377, code skipped:
            r6 = r0;
     */
    /* JADX WARNING: Missing block: B:216:0x0378, code skipped:
            r5.removedForAllUsers = r6;
     */
    /* JADX WARNING: Missing block: B:217:0x037a, code skipped:
            r4 = r4 + 1;
     */
    /* JADX WARNING: Missing block: B:218:0x037d, code skipped:
            monitor-exit(r2);
     */
    /* JADX WARNING: Missing block: B:224:0x0386, code skipped:
            if (isSystemApp(r14) == false) goto L_0x03f8;
     */
    /* JADX WARNING: Missing block: B:225:0x0388, code skipped:
            r2 = r9.mPackages;
     */
    /* JADX WARNING: Missing block: B:226:0x038a, code skipped:
            monitor-enter(r2);
     */
    /* JADX WARNING: Missing block: B:228:?, code skipped:
            r3 = r9.mSettings.getPackageLPr(r14.name);
     */
    /* JADX WARNING: Missing block: B:229:0x0393, code skipped:
            if (r3 == null) goto L_0x03a0;
     */
    /* JADX WARNING: Missing block: B:231:0x0397, code skipped:
            if (r3.childPackageNames == null) goto L_0x03a0;
     */
    /* JADX WARNING: Missing block: B:232:0x0399, code skipped:
            r4 = r3.childPackageNames.size();
     */
    /* JADX WARNING: Missing block: B:233:0x03a0, code skipped:
            r4 = r0;
     */
    /* JADX WARNING: Missing block: B:235:0x03a2, code skipped:
            if (r0 >= r4) goto L_0x03f3;
     */
    /* JADX WARNING: Missing block: B:236:0x03a4, code skipped:
            r5 = (java.lang.String) r3.childPackageNames.get(r0);
     */
    /* JADX WARNING: Missing block: B:237:0x03ae, code skipped:
            if (r13.removedChildPackages == null) goto L_0x03b8;
     */
    /* JADX WARNING: Missing block: B:239:0x03b6, code skipped:
            if (r13.removedChildPackages.indexOfKey(r5) >= 0) goto L_0x03f0;
     */
    /* JADX WARNING: Missing block: B:240:0x03b8, code skipped:
            r6 = r9.mSettings.getPackageLPr(r5);
     */
    /* JADX WARNING: Missing block: B:241:0x03be, code skipped:
            if (r6 != null) goto L_0x03c1;
     */
    /* JADX WARNING: Missing block: B:243:0x03c1, code skipped:
            r7 = new com.android.server.pm.PackageManagerService.PackageInstalledInfo();
            r7.name = r5;
            r7.newUsers = r6.queryInstalledUsers(r12, true);
            r7.pkg = (android.content.pm.PackageParser.Package) r9.mPackages.get(r5);
            r7.uid = r6.pkg.applicationInfo.uid;
     */
    /* JADX WARNING: Missing block: B:244:0x03e2, code skipped:
            if (r13.appearedChildPackages != null) goto L_0x03eb;
     */
    /* JADX WARNING: Missing block: B:245:0x03e4, code skipped:
            r13.appearedChildPackages = new android.util.ArrayMap();
     */
    /* JADX WARNING: Missing block: B:246:0x03eb, code skipped:
            r13.appearedChildPackages.put(r5, r7);
     */
    /* JADX WARNING: Missing block: B:247:0x03f0, code skipped:
            r0 = r0 + 1;
     */
    /* JADX WARNING: Missing block: B:248:0x03f3, code skipped:
            monitor-exit(r2);
     */
    /* JADX WARNING: Missing block: B:253:0x03f8, code skipped:
            return r1;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private boolean deletePackageLIF(String packageName, UserHandle user, boolean deleteCodeAndResources, int[] allUserHandles, int flags, PackageRemovedInfo outInfo, boolean writeSettings, Package replacingPackage) {
        String str = packageName;
        UserHandle userHandle = user;
        int[] iArr = allUserHandles;
        int i = flags;
        PackageRemovedInfo packageRemovedInfo = outInfo;
        boolean z = false;
        if (str == null) {
            Slog.w(TAG, "Attempt to delete null packageName.");
            return false;
        }
        if (DEBUG_REMOVE) {
            String str2 = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("deletePackageLI: ");
            stringBuilder.append(str);
            stringBuilder.append(" user ");
            stringBuilder.append(userHandle);
            stringBuilder.append(" flags ");
            stringBuilder.append(i);
            Slog.d(str2, stringBuilder.toString());
        }
        synchronized (this.mPackages) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(str);
            String str3;
            if (ps == null) {
                str3 = TAG;
                StringBuilder stringBuilder2 = new StringBuilder();
                stringBuilder2.append("Package named '");
                stringBuilder2.append(str);
                stringBuilder2.append("' doesn't exist.");
                Slog.w(str3, stringBuilder2.toString());
                return false;
            }
            int i2 = -1;
            if (ps.parentPackageName == null || (isSystemApp(ps) && (i & 4) == 0)) {
            } else {
                if (DEBUG_REMOVE) {
                    str3 = TAG;
                    StringBuilder stringBuilder3 = new StringBuilder();
                    stringBuilder3.append("Uninstalled child package:");
                    stringBuilder3.append(str);
                    stringBuilder3.append(" for user:");
                    stringBuilder3.append(userHandle == null ? Integer.valueOf(-1) : userHandle);
                    Slog.d(str3, stringBuilder3.toString());
                }
                if (userHandle != null) {
                    i2 = user.getIdentifier();
                }
                if (clearPackageStateForUserLIF(ps, i2, packageRemovedInfo)) {
                    markPackageUninstalledForUserLPw(ps, userHandle);
                    scheduleWritePackageRestrictionsLocked(userHandle);
                    return true;
                }
                return false;
            }
        }
    }

    private void markPackageUninstalledForUserLPw(PackageSetting ps, UserHandle user) {
        PackageSetting packageSetting = ps;
        int[] userIds = (user == null || user.getIdentifier() == -1) ? sUserManager.getUserIds() : new int[]{user.getIdentifier()};
        int[] userIds2 = userIds;
        int length = userIds2.length;
        int i = 0;
        while (i < length) {
            int nextUserId = userIds2[i];
            if (DEBUG_REMOVE) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Marking package:");
                stringBuilder.append(packageSetting.name);
                stringBuilder.append(" uninstalled for user:");
                stringBuilder.append(nextUserId);
                Slog.d(str, stringBuilder.toString());
            }
            int i2 = i;
            int i3 = length;
            int[] userIds3 = userIds2;
            packageSetting.setUserState(nextUserId, 0, 0, false, true, true, false, false, null, null, null, null, false, false, null, null, null, packageSetting.readUserState(nextUserId).domainVerificationStatus, 0, 0, null);
            i = i2 + 1;
            length = i3;
            userIds2 = userIds3;
            packageSetting = ps;
        }
        this.mSettings.writeKernelMappingLPr(ps);
    }

    private boolean clearPackageStateForUserLIF(PackageSetting ps, int userId, PackageRemovedInfo outInfo) {
        Package pkg;
        synchronized (this.mPackages) {
            pkg = (Package) this.mPackages.get(ps.name);
        }
        boolean z = false;
        int[] userIds = userId == -1 ? sUserManager.getUserIds() : new int[]{userId};
        for (int nextUserId : userIds) {
            if (DEBUG_REMOVE) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Updating package:");
                stringBuilder.append(ps.name);
                stringBuilder.append(" install state for user:");
                stringBuilder.append(nextUserId);
                Slog.d(str, stringBuilder.toString());
            }
            destroyAppDataLIF(pkg, userId, 3);
            destroyAppProfilesLIF(pkg, userId);
            clearDefaultBrowserIfNeededForUser(ps.name, userId);
            removeKeystoreDataIfNeeded(nextUserId, ps.appId);
            schedulePackageCleaning(ps.name, nextUserId, false);
            synchronized (this.mPackages) {
                if (clearPackagePreferredActivitiesLPw(ps.name, nextUserId)) {
                    scheduleWritePackageRestrictionsLocked(nextUserId);
                }
                resetUserChangesToRuntimePermissionsAndFlagsLPw(ps, nextUserId);
            }
        }
        if (outInfo != null) {
            outInfo.removedPackage = ps.name;
            outInfo.installerPackageName = ps.installerPackageName;
            if (!(pkg == null || pkg.staticSharedLibName == null)) {
                z = true;
            }
            outInfo.isStaticSharedLib = z;
            outInfo.removedAppId = ps.appId;
            outInfo.removedUsers = userIds;
            outInfo.broadcastUsers = userIds;
        }
        return true;
    }

    private void clearExternalStorageDataSync(String packageName, int userId, boolean allData) {
        String str = packageName;
        int i = userId;
        if (str == null) {
            Slog.w(TAG, "clearExternalStorageDataSync packageName is null!");
        } else if (!DEFAULT_CONTAINER_PACKAGE.equals(str)) {
            boolean mounted;
            int i2 = 0;
            if (Environment.isExternalStorageEmulated()) {
                mounted = true;
            } else {
                String status = Environment.getExternalStorageState();
                boolean z = status.equals("mounted") || status.equals("mounted_ro");
                mounted = z;
            }
            if (mounted) {
                Intent containerIntent = new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT);
                int[] users = i == -1 ? sUserManager.getUserIds() : new int[]{i};
                ClearStorageConnection conn = new ClearStorageConnection(this, null);
                if (this.mContext.bindServiceAsUser(containerIntent, conn, 1, UserHandle.SYSTEM)) {
                    try {
                        int length = users.length;
                        while (i2 < length) {
                            int curUser = users[i2];
                            long timeout = SystemClock.uptimeMillis() + ((WATCHDOG_TIMEOUT * 4) / 5);
                            synchronized (conn) {
                                while (conn.mContainerService == null) {
                                    long uptimeMillis = SystemClock.uptimeMillis();
                                    long now = uptimeMillis;
                                    if (uptimeMillis >= timeout) {
                                        break;
                                    }
                                    try {
                                        conn.wait(timeout - now);
                                    } catch (InterruptedException e) {
                                    }
                                    uptimeMillis = SystemClock.uptimeMillis();
                                }
                            }
                            if (conn.mContainerService == null) {
                                Slog.w(TAG, "clearExternalStorageDataSync fail reason: Bind ContainerService Timeout");
                                this.mContext.unbindService(conn);
                                return;
                            }
                            UserEnvironment userEnv = new UserEnvironment(curUser);
                            clearDirectory(conn.mContainerService, userEnv.buildExternalStorageAppCacheDirs(str));
                            if (allData) {
                                clearDirectory(conn.mContainerService, userEnv.buildExternalStorageAppDataDirs(str));
                                clearDirectory(conn.mContainerService, userEnv.buildExternalStorageAppMediaDirs(str));
                            }
                            i2++;
                        }
                        this.mContext.unbindService(conn);
                    } catch (Throwable th) {
                        this.mContext.unbindService(conn);
                    }
                }
            }
        }
    }

    /* JADX WARNING: Missing block: B:24:0x002d, code skipped:
            if (r0 != null) goto L_0x002f;
     */
    /* JADX WARNING: Missing block: B:25:0x002f, code skipped:
            $closeResource(r2, r0);
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void clearApplicationProfileData(String packageName) {
        Package pkg;
        enforceSystemOrRoot("Only the system can clear all profile data");
        synchronized (this.mPackages) {
            pkg = (Package) this.mPackages.get(packageName);
        }
        PackageFreezer freezer = freezePackage(packageName, "clearApplicationProfileData");
        synchronized (this.mInstallLock) {
            clearAppProfilesLIF(pkg, -1);
        }
        if (freezer != null) {
            $closeResource(null, freezer);
        }
    }

    public void clearApplicationUserData(String packageName, IPackageDataObserver observer, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_USER_DATA", null);
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "clear application data");
        PackageSetting ps = this.mSettings.getPackageLPr(packageName);
        boolean filterApp = ps != null && filterAppAccessLPr(ps, callingUid, userId);
        if (filterApp || !this.mProtectedPackages.isPackageDataProtected(userId, packageName)) {
            final boolean z = filterApp;
            final String str = packageName;
            final int i = userId;
            final IPackageDataObserver iPackageDataObserver = observer;
            this.mHandler.post(new Runnable() {
                /* JADX WARNING: Missing block: B:44:0x00c4, code skipped:
            if (r0 != null) goto L_0x00c6;
     */
                /* JADX WARNING: Missing block: B:45:0x00c6, code skipped:
            if (r1 != null) goto L_0x00c8;
     */
                /* JADX WARNING: Missing block: B:47:?, code skipped:
            r0.close();
     */
                /* JADX WARNING: Missing block: B:48:0x00cc, code skipped:
            r3 = move-exception;
     */
                /* JADX WARNING: Missing block: B:49:0x00cd, code skipped:
            r1.addSuppressed(r3);
     */
                /* JADX WARNING: Missing block: B:50:0x00d1, code skipped:
            r0.close();
     */
                /* Code decompiled incorrectly, please refer to instructions dump. */
                public void run() {
                    boolean succeeded;
                    PackageManagerService.this.mHandler.removeCallbacks(this);
                    if (z) {
                        succeeded = false;
                    } else {
                        boolean succeeded2;
                        PackageFreezer freezer = PackageManagerService.this.freezePackage(str, "clearApplicationUserData");
                        long start = SystemClock.uptimeMillis();
                        synchronized (PackageManagerService.this.mInstallLock) {
                            succeeded2 = PackageManagerService.this.clearApplicationUserDataLIF(str, i);
                        }
                        start = PackageManagerService.this.printClearDataTimeoutLogs("UserData", start, str);
                        PackageManagerService.this.clearExternalStorageDataSync(str, i, true);
                        start = PackageManagerService.this.printClearDataTimeoutLogs("ExternalStorageData", start, str);
                        synchronized (PackageManagerService.this.mPackages) {
                            PackageManagerService.this.mInstantAppRegistry.deleteInstantApplicationMetadataLPw(str, i);
                        }
                        start = PackageManagerService.this.printClearDataTimeoutLogs("Metadata", start, str);
                        String str = PackageManagerService.TAG;
                        StringBuilder stringBuilder = new StringBuilder();
                        stringBuilder.append("clearApplicationUserData, finish freeze package:");
                        stringBuilder.append(str);
                        Slog.i(str, stringBuilder.toString());
                        if (freezer != null) {
                            freezer.close();
                        }
                        succeeded = succeeded2;
                        if (succeeded) {
                            DeviceStorageMonitorInternal dsm = (DeviceStorageMonitorInternal) LocalServices.getService(DeviceStorageMonitorInternal.class);
                            if (dsm != null) {
                                dsm.checkMemory();
                            }
                            start = HwFrameworkFactory.getIndexClearManager();
                            if (start != null) {
                                start.clearUserIndexSearchData(str, i);
                            }
                            if (PackageManagerService.this.checkPermission("android.permission.SUSPEND_APPS", str, i) == 0) {
                                PackageManagerService.this.unsuspendForSuspendingPackage(str, i);
                            }
                        }
                    }
                    if (iPackageDataObserver != null) {
                        try {
                            iPackageDataObserver.onRemoveCompleted(str, succeeded);
                        } catch (RemoteException e) {
                            Log.i(PackageManagerService.TAG, "Observer no longer exists.");
                        }
                    }
                }
            });
            return;
        }
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("Cannot clear data for a protected package: ");
        stringBuilder.append(packageName);
        throw new SecurityException(stringBuilder.toString());
    }

    /* JADX WARNING: Missing block: B:18:0x004e, code skipped:
            r1 = r2;
            clearAppDataLIF(r1, r8, 3);
            removeKeystoreDataIfNeeded(r8, android.os.UserHandle.getAppId(r1.applicationInfo.uid));
            r3 = getUserManagerInternal();
     */
    /* JADX WARNING: Missing block: B:19:0x0066, code skipped:
            if (r3.isUserUnlockingOrUnlocked(r8) == false) goto L_0x006a;
     */
    /* JADX WARNING: Missing block: B:20:0x0068, code skipped:
            r0 = 3;
     */
    /* JADX WARNING: Missing block: B:22:0x006e, code skipped:
            if (r3.isUserRunning(r8) == false) goto L_0x0073;
     */
    /* JADX WARNING: Missing block: B:23:0x0070, code skipped:
            r0 = 1;
     */
    /* JADX WARNING: Missing block: B:24:0x0073, code skipped:
            prepareAppDataContentsLIF(r1, r8, r0);
     */
    /* JADX WARNING: Missing block: B:25:0x0077, code skipped:
            return true;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private boolean clearApplicationUserDataLIF(String packageName, int userId) {
        int flags = 0;
        if (packageName == null) {
            Slog.w(TAG, "Attempt to delete null packageName.");
            return false;
        }
        synchronized (this.mPackages) {
            Package pkg = (Package) this.mPackages.get(packageName);
            if (pkg == null) {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (ps != null) {
                    pkg = ps.pkg;
                }
            }
            if (pkg == null) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Package named '");
                stringBuilder.append(packageName);
                stringBuilder.append("' doesn't exist.");
                Slog.w(str, stringBuilder.toString());
                return false;
            }
            resetUserChangesToRuntimePermissionsAndFlagsLPw((PackageSetting) pkg.mExtras, userId);
        }
    }

    private void resetUserChangesToRuntimePermissionsAndFlagsLPw(int userId) {
        int packageCount = this.mPackages.size();
        for (int i = 0; i < packageCount; i++) {
            resetUserChangesToRuntimePermissionsAndFlagsLPw(((Package) this.mPackages.valueAt(i)).mExtras, userId);
        }
    }

    private void resetNetworkPolicies(int userId) {
        ((NetworkPolicyManagerInternal) LocalServices.getService(NetworkPolicyManagerInternal.class)).resetUserState(userId);
    }

    /* JADX WARNING: Removed duplicated region for block: B:65:0x00e9 A:{SYNTHETIC} */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void resetUserChangesToRuntimePermissionsAndFlagsLPw(PackageSetting ps, int userId) {
        PackageSetting packageSetting = ps;
        final int i = userId;
        if (packageSetting.pkg != null) {
            int userSettableMask = 75;
            boolean writeRuntimePermissions = false;
            int permissionCount = packageSetting.pkg.requestedPermissions.size();
            boolean writeInstallPermissions = false;
            int i2 = 0;
            while (i2 < permissionCount) {
                int userSettableMask2;
                String permName = (String) packageSetting.pkg.requestedPermissions.get(i2);
                BasePermission bp = this.mPermissionManager.getPermissionTEMP(permName);
                if (bp == null) {
                    userSettableMask2 = userSettableMask;
                } else {
                    int j;
                    if (packageSetting.sharedUser != null) {
                        boolean used = false;
                        int packageCount = packageSetting.sharedUser.packages.size();
                        j = 0;
                        while (j < packageCount) {
                            PackageSetting pkg = (PackageSetting) packageSetting.sharedUser.packages.valueAt(j);
                            if (pkg.pkg != null) {
                                userSettableMask2 = userSettableMask;
                                if (pkg.pkg.packageName.equals(packageSetting.pkg.packageName) == 0 && pkg.pkg.requestedPermissions.contains(permName) != 0) {
                                    used = true;
                                    if (used) {
                                    }
                                }
                            } else {
                                userSettableMask2 = userSettableMask;
                            }
                            j++;
                            userSettableMask = userSettableMask2;
                        }
                        userSettableMask2 = userSettableMask;
                        if (used) {
                        }
                    } else {
                        userSettableMask2 = userSettableMask;
                    }
                    userSettableMask = ps.getPermissionsState();
                    int oldFlags = userSettableMask.getPermissionFlags(permName, i);
                    boolean hasInstallState = userSettableMask.getInstallPermissionState(permName) != null;
                    int flags = 0;
                    if (this.mSettings.mPermissions.mPermissionReviewRequired && packageSetting.pkg.applicationInfo.targetSdkVersion < 23) {
                        flags = 0 | 64;
                    }
                    if (userSettableMask.updatePermissionFlags(bp, i, 75, flags)) {
                        if (hasInstallState) {
                            writeInstallPermissions = true;
                        } else {
                            writeRuntimePermissions = true;
                        }
                    }
                    if (bp.isRuntime() && (oldFlags & 20) == 0) {
                        if ((oldFlags & 32) != 0) {
                            if (userSettableMask.grantRuntimePermission(bp, i) != -1) {
                                writeRuntimePermissions = true;
                            }
                        } else if ((flags & 64) == 0) {
                            switch (userSettableMask.revokeRuntimePermission(bp, i)) {
                                case 0:
                                case 1:
                                    writeRuntimePermissions = true;
                                    j = packageSetting.appId;
                                    PermissionsState permissionsState = userSettableMask;
                                    this.mHandler.post(new Runnable() {
                                        public void run() {
                                            PackageManagerService.this.killUid(j, i, PackageManagerService.KILL_APP_REASON_PERMISSIONS_REVOKED);
                                        }
                                    });
                                    break;
                                default:
                                    break;
                            }
                        }
                    }
                }
                i2++;
                userSettableMask = userSettableMask2;
                packageSetting = ps;
            }
            if (writeRuntimePermissions) {
                this.mSettings.writeRuntimePermissionsForUserLPr(i, true);
            }
            if (writeInstallPermissions) {
                this.mSettings.writeLPr();
            }
        }
    }

    private static void removeKeystoreDataIfNeeded(int userId, int appId) {
        if (appId >= 0) {
            KeyStore keyStore = KeyStore.getInstance();
            if (keyStore == null) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Could not contact keystore to clear entries for app id ");
                stringBuilder.append(appId);
                Slog.w(str, stringBuilder.toString());
            } else if (userId == -1) {
                for (int individual : sUserManager.getUserIds()) {
                    keyStore.clearUid(UserHandle.getUid(individual, appId));
                }
            } else {
                keyStore.clearUid(UserHandle.getUid(userId, appId));
            }
        }
    }

    public void deleteApplicationCacheFiles(String packageName, IPackageDataObserver observer) {
        if (packageName == null) {
            Slog.w(TAG, "Failed to delete cache files, for packageName is null!");
        } else {
            deleteApplicationCacheFilesAsUser(packageName, UserHandle.getCallingUserId(), observer);
        }
    }

    public void deleteApplicationCacheFilesAsUser(String packageName, int userId, IPackageDataObserver observer) {
        final Package pkg;
        int callingUid = Binder.getCallingUid();
        if (this.mContext.checkCallingOrSelfPermission("android.permission.INTERNAL_DELETE_CACHE_FILES") != 0) {
            if (this.mContext.checkCallingOrSelfPermission("android.permission.DELETE_CACHE_FILES") == 0) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Calling uid ");
                stringBuilder.append(callingUid);
                stringBuilder.append(" does not have ");
                stringBuilder.append("android.permission.INTERNAL_DELETE_CACHE_FILES");
                stringBuilder.append(", silently ignoring");
                Slog.w(str, stringBuilder.toString());
                return;
            }
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERNAL_DELETE_CACHE_FILES", null);
        }
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "delete application cache files");
        int hasAccessInstantApps = this.mContext.checkCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS");
        synchronized (this.mPackages) {
            pkg = (Package) this.mPackages.get(packageName);
        }
        final int i = callingUid;
        final int i2 = hasAccessInstantApps;
        final int i3 = userId;
        final String str2 = packageName;
        final IPackageDataObserver iPackageDataObserver = observer;
        this.mHandler.post(new Runnable() {
            public void run() {
                PackageSetting ps = pkg == null ? null : pkg.mExtras;
                boolean doClearData = true;
                if (ps != null) {
                    boolean z = !ps.getInstantApp(UserHandle.getUserId(i)) || i2 == 0;
                    doClearData = z;
                }
                if (doClearData) {
                    synchronized (PackageManagerService.this.mInstallLock) {
                        PackageManagerService.this.clearAppDataLIF(pkg, i3, LightsManager.LIGHT_ID_MANUALCUSTOMBACKLIGHT);
                        PackageManagerService.this.clearAppDataLIF(pkg, i3, UsbTerminalTypes.TERMINAL_IN_PERSONAL_MIC);
                    }
                    PackageManagerService.this.clearExternalStorageDataSync(str2, i3, false);
                }
                if (iPackageDataObserver != null) {
                    try {
                        iPackageDataObserver.onRemoveCompleted(str2, true);
                    } catch (RemoteException e) {
                        Log.i(PackageManagerService.TAG, "Observer no longer exists.");
                    }
                }
            }
        });
    }

    public void getPackageSizeInfo(String packageName, int userHandle, IPackageStatsObserver observer) {
        throw new UnsupportedOperationException("Shame on you for calling the hidden API getPackageSizeInfo(). Shame!");
    }

    /* JADX WARNING: Missing block: B:11:?, code skipped:
            r12.mInstaller.getAppSize(r1.volumeUuid, new java.lang.String[]{r13}, r14, 0, r1.appId, new long[]{r1.getCeDataInode(r14)}, new java.lang.String[]{r1.codePathString}, r15);
     */
    /* JADX WARNING: Missing block: B:12:0x004c, code skipped:
            if (isSystemApp(r1) == false) goto L_0x0063;
     */
    /* JADX WARNING: Missing block: B:14:0x0052, code skipped:
            if (isUpdatedSystemApp(r1) != false) goto L_0x0063;
     */
    /* JADX WARNING: Missing block: B:16:0x005d, code skipped:
            if ((r1.pkg.applicationInfo.hwFlags & com.android.server.pm.DumpState.DUMP_HANDLE) != 0) goto L_0x0063;
     */
    /* JADX WARNING: Missing block: B:17:0x005f, code skipped:
            r15.codeSize = 0;
     */
    /* JADX WARNING: Missing block: B:18:0x0063, code skipped:
            r15.dataSize -= r15.cacheSize;
     */
    /* JADX WARNING: Missing block: B:19:0x006b, code skipped:
            return true;
     */
    /* JADX WARNING: Missing block: B:20:0x006c, code skipped:
            r0 = move-exception;
     */
    /* JADX WARNING: Missing block: B:21:0x006d, code skipped:
            android.util.Slog.w(TAG, java.lang.String.valueOf(r0));
     */
    /* JADX WARNING: Missing block: B:22:0x0076, code skipped:
            return false;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private boolean getPackageSizeInfoLI(String packageName, int userId, PackageStats stats) {
        synchronized (this.mPackages) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Failed to find settings for ");
                stringBuilder.append(packageName);
                Slog.w(str, stringBuilder.toString());
                return false;
            }
        }
    }

    private int getUidTargetSdkVersionLockedLPr(int uid) {
        SettingBase obj = this.mSettings.getUserIdLPr(uid);
        if (obj instanceof SharedUserSetting) {
            int vers = 10000;
            Iterator<PackageSetting> it = ((SharedUserSetting) obj).packages.iterator();
            while (it.hasNext()) {
                PackageSetting ps = (PackageSetting) it.next();
                if (ps.pkg != null) {
                    int v = ps.pkg.applicationInfo.targetSdkVersion;
                    if (v < vers) {
                        vers = v;
                    }
                }
            }
            return vers;
        }
        if (obj instanceof PackageSetting) {
            PackageSetting ps2 = (PackageSetting) obj;
            if (ps2.pkg != null) {
                return ps2.pkg.applicationInfo.targetSdkVersion;
            }
        }
        return 10000;
    }

    private int getPackageTargetSdkVersionLockedLPr(String packageName) {
        Package p = (Package) this.mPackages.get(packageName);
        if (p != null) {
            return p.applicationInfo.targetSdkVersion;
        }
        return 10000;
    }

    public void addPreferredActivity(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, int userId) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(BehaviorId.PACKAGEMANAGER_ADDPREFERREDACTIVITY);
        addPreferredActivityInternal(filter, match, set, activity, true, userId, "Adding preferred");
    }

    protected void addPreferredActivityInternal(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, boolean always, int userId, String opname) {
        String str;
        StringBuilder stringBuilder;
        IntentFilter intentFilter = filter;
        int i = userId;
        String str2 = opname;
        int callingUid = Binder.getCallingUid();
        if (activity != null) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append(str2);
            stringBuilder.append("add pref activity ");
            stringBuilder.append(activity.flattenToShortString());
            stringBuilder.append(" from uid ");
            stringBuilder.append(Binder.getCallingUid());
            Slog.d(str, stringBuilder.toString());
        }
        this.mPermissionManager.enforceCrossUserPermission(callingUid, i, true, false, "add preferred activity");
        if (intentFilter.countActions() == 0) {
            Slog.w(TAG, "Cannot set a preferred activity with no filter actions");
            return;
        }
        if (intentFilter.hasCategory("android.intent.category.HOME") && activity != null) {
            if (intentFilter.hasAction("android.intent.action.MDM_SET_DEFAULT_LAUNCHER_FOR_ANTIMAL")) {
                Global.putInt(this.mContext.getContentResolver(), "hwMdmActionForAntimalFlag", 1);
            } else if (!this.mHwPMSEx.isAllowedSetHomeActivityForAntiMal(getPackageInfo(activity.getPackageName(), 0, i), i)) {
                Slog.i(TAG, "NOT ALLOWED TO add preferred activity current time!");
                return;
            }
        }
        synchronized (this.mPackages) {
            if (this.mContext.checkCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS") != 0) {
                if (getUidTargetSdkVersionLockedLPr(callingUid) < 8) {
                    str = TAG;
                    stringBuilder = new StringBuilder();
                    stringBuilder.append("Ignoring addPreferredActivity() from uid ");
                    stringBuilder.append(callingUid);
                    Slog.w(str, stringBuilder.toString());
                    return;
                }
                this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
            }
            PreferredIntentResolver pir = this.mSettings.editPreferredActivitiesLPw(i);
            if (activity == null) {
                Slog.w(TAG, "Cannot set a preferred activity with activity is null");
                return;
            }
            String str3 = TAG;
            StringBuilder stringBuilder2 = new StringBuilder();
            stringBuilder2.append(str2);
            stringBuilder2.append(" activity ");
            stringBuilder2.append(activity.flattenToShortString());
            stringBuilder2.append(" for user ");
            stringBuilder2.append(i);
            stringBuilder2.append(":");
            Slog.i(str3, stringBuilder2.toString());
            intentFilter.dump(new LogPrinter(4, TAG), "  ");
            pir.addFilter(new PreferredActivity(intentFilter, match, set, activity, always));
            scheduleWritePackageRestrictionsLocked(i);
            postPreferredActivityChangedBroadcast(i);
        }
    }

    private void postPreferredActivityChangedBroadcast(int userId) {
        this.mHandler.post(new -$$Lambda$PackageManagerService$pG5M8N0ge8cs9_1xCnV9yYuSdCw(userId));
    }

    static /* synthetic */ void lambda$postPreferredActivityChangedBroadcast$7(int userId) {
        IActivityManager am = ActivityManager.getService();
        if (am != null) {
            Intent intent = new Intent("android.intent.action.ACTION_PREFERRED_ACTIVITY_CHANGED");
            intent.putExtra("android.intent.extra.user_handle", userId);
            try {
                am.broadcastIntent(null, intent, null, null, 0, null, null, null, -1, null, false, false, userId);
            } catch (RemoteException e) {
            }
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:61:0x0209 A:{Catch:{ all -> 0x028c }} */
    /* JADX WARNING: Missing block: B:58:0x0204, code skipped:
            return;
     */
    /* JADX WARNING: Missing block: B:73:0x0279, code skipped:
            addPreferredActivityInternal(r10, r17, r14, r11, true, r12, "Replacing preferred");
     */
    /* JADX WARNING: Missing block: B:74:0x0286, code skipped:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void replacePreferredActivity(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, int userId) {
        Throwable th;
        IntentFilter intentFilter = filter;
        ComponentName componentName = activity;
        int i = userId;
        ComponentName[] componentNameArr;
        if (filter.countActions() != 1) {
            componentNameArr = set;
            throw new IllegalArgumentException("replacePreferredActivity expects filter to have only 1 action.");
        } else if (filter.countDataAuthorities() == 0 && filter.countDataPaths() == 0 && filter.countDataSchemes() <= 1 && filter.countDataTypes() == 0) {
            int i2 = 0;
            if (intentFilter.hasCategory("android.intent.category.HOME") && componentName != null) {
                if (intentFilter.hasAction("android.intent.action.MDM_SET_DEFAULT_LAUNCHER_FOR_ANTIMAL")) {
                    Global.putInt(this.mContext.getContentResolver(), "hwMdmActionForAntimalFlag", 1);
                } else if (!this.mHwPMSEx.isAllowedSetHomeActivityForAntiMal(getPackageInfo(activity.getPackageName(), 0, i), i)) {
                    Slog.i(TAG, "NOT ALLOWED TO replace preferred activity current time!");
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("Component ");
                    stringBuilder.append(componentName);
                    stringBuilder.append(" not allowed to be home on user ");
                    stringBuilder.append(i);
                    throw new IllegalArgumentException(stringBuilder.toString());
                }
            }
            int callingUid = Binder.getCallingUid();
            this.mPermissionManager.enforceCrossUserPermission(callingUid, i, true, false, "replace preferred activity");
            synchronized (this.mPackages) {
                try {
                    if (this.mContext.checkCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS") != 0) {
                        if (getUidTargetSdkVersionLockedLPr(callingUid) < 8) {
                            String str = TAG;
                            StringBuilder stringBuilder2 = new StringBuilder();
                            stringBuilder2.append("Ignoring replacePreferredActivity() from uid ");
                            stringBuilder2.append(Binder.getCallingUid());
                            Slog.w(str, stringBuilder2.toString());
                            return;
                        }
                        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
                    }
                    PreferredIntentResolver pir = (PreferredIntentResolver) this.mSettings.mPreferredActivities.get(i);
                    if (pir != null) {
                        ArrayList<PreferredActivity> existing = pir.findFilters(intentFilter);
                        if (existing != null && existing.size() == 1) {
                            String str2;
                            StringBuilder stringBuilder3;
                            PreferredActivity cur = (PreferredActivity) existing.get(0);
                            if (DEBUG_PREFERRED) {
                                Slog.i(TAG, "Checking replace of preferred:");
                                intentFilter.dump(new LogPrinter(4, TAG), "  ");
                                if (cur.mPref.mAlways) {
                                    str2 = TAG;
                                    stringBuilder3 = new StringBuilder();
                                    stringBuilder3.append("  -- CUR: mMatch=");
                                    stringBuilder3.append(cur.mPref.mMatch);
                                    Slog.i(str2, stringBuilder3.toString());
                                    str2 = TAG;
                                    stringBuilder3 = new StringBuilder();
                                    stringBuilder3.append("  -- CUR: mSet=");
                                    stringBuilder3.append(Arrays.toString(cur.mPref.mSetComponents));
                                    Slog.i(str2, stringBuilder3.toString());
                                    str2 = TAG;
                                    stringBuilder3 = new StringBuilder();
                                    stringBuilder3.append("  -- CUR: mComponent=");
                                    stringBuilder3.append(cur.mPref.mShortComponent);
                                    Slog.i(str2, stringBuilder3.toString());
                                    str2 = TAG;
                                    stringBuilder3 = new StringBuilder();
                                    stringBuilder3.append("  -- NEW: mMatch=");
                                    stringBuilder3.append(match & 268369920);
                                    Slog.i(str2, stringBuilder3.toString());
                                    str2 = TAG;
                                    stringBuilder3 = new StringBuilder();
                                    stringBuilder3.append("  -- CUR: mSet=");
                                    stringBuilder3.append(Arrays.toString(set));
                                    Slog.i(str2, stringBuilder3.toString());
                                    str2 = TAG;
                                    stringBuilder3 = new StringBuilder();
                                    stringBuilder3.append("  -- CUR: mComponent=");
                                    stringBuilder3.append(activity.flattenToShortString());
                                    Slog.i(str2, stringBuilder3.toString());
                                } else {
                                    Slog.i(TAG, "  -- CUR; not mAlways!");
                                }
                            }
                            if (cur.mPref.mAlways && cur.mPref.mComponent.equals(componentName) && cur.mPref.mMatch == (match & 268369920)) {
                                componentNameArr = set;
                                try {
                                    if (cur.mPref.sameSet(componentNameArr)) {
                                        if (DEBUG_PREFERRED) {
                                            str2 = TAG;
                                            StringBuilder stringBuilder4 = new StringBuilder();
                                            stringBuilder4.append("Replacing with same preferred activity ");
                                            stringBuilder4.append(cur.mPref.mShortComponent);
                                            stringBuilder4.append(" for user ");
                                            stringBuilder4.append(i);
                                            stringBuilder4.append(":");
                                            Slog.i(str2, stringBuilder4.toString());
                                            intentFilter.dump(new LogPrinter(4, TAG), "  ");
                                        }
                                    }
                                    if (existing != null) {
                                        if (DEBUG_PREFERRED) {
                                            String str3 = TAG;
                                            StringBuilder stringBuilder5 = new StringBuilder();
                                            stringBuilder5.append(existing.size());
                                            stringBuilder5.append(" existing preferred matches for:");
                                            Slog.i(str3, stringBuilder5.toString());
                                            intentFilter.dump(new LogPrinter(4, TAG), "  ");
                                        }
                                        while (true) {
                                            int i3 = i2;
                                            if (i3 >= existing.size()) {
                                                break;
                                            }
                                            PreferredActivity pa = (PreferredActivity) existing.get(i3);
                                            if (DEBUG_PREFERRED) {
                                                String str4 = TAG;
                                                stringBuilder3 = new StringBuilder();
                                                stringBuilder3.append("Removing existing preferred activity ");
                                                stringBuilder3.append(pa.mPref.mComponent);
                                                stringBuilder3.append(":");
                                                Slog.i(str4, stringBuilder3.toString());
                                                pa.dump(new LogPrinter(4, TAG), "  ");
                                            }
                                            pir.removeFilter(pa);
                                            i2 = i3 + 1;
                                        }
                                    }
                                } catch (Throwable th2) {
                                    th = th2;
                                    throw th;
                                }
                            }
                        }
                        componentNameArr = set;
                        if (existing != null) {
                        }
                    } else {
                        componentNameArr = set;
                    }
                } catch (Throwable th3) {
                    th = th3;
                    componentNameArr = set;
                    throw th;
                }
            }
        } else {
            componentNameArr = set;
            throw new IllegalArgumentException("replacePreferredActivity expects filter to have no data authorities, paths, or types; and at most one scheme.");
        }
    }

    /* JADX WARNING: Missing block: B:28:0x007b, code skipped:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void clearPackagePreferredActivities(String packageName) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(BehaviorId.PACKAGEMANAGER_CLEARPACKAGEPREFERREDACTIVITIES);
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null) {
            synchronized (this.mPackages) {
                Package pkg = (Package) this.mPackages.get(packageName);
                if ((pkg == null || pkg.applicationInfo.uid != callingUid) && this.mContext.checkCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS") != 0) {
                    if (getUidTargetSdkVersionLockedLPr(callingUid) < 8) {
                        String str = TAG;
                        StringBuilder stringBuilder = new StringBuilder();
                        stringBuilder.append("Ignoring clearPackagePreferredActivities() from uid ");
                        stringBuilder.append(callingUid);
                        Slog.w(str, stringBuilder.toString());
                        return;
                    }
                    this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
                }
                PackageSetting ps = this.mSettings.getPackageLPr(packageName);
                if (ps == null || !filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    int user = UserHandle.getCallingUserId();
                    if (clearPackagePreferredActivitiesLPw(packageName, user)) {
                        scheduleWritePackageRestrictionsLocked(user);
                    }
                }
            }
        }
    }

    boolean clearPackagePreferredActivitiesLPw(String packageName, int userId) {
        String str = TAG;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("clear pref activity ");
        stringBuilder.append(packageName);
        stringBuilder.append(" from uid ");
        stringBuilder.append(Binder.getCallingUid());
        Slog.d(str, stringBuilder.toString());
        boolean changed = false;
        ArrayList<PreferredActivity> removed = null;
        for (int i = 0; i < this.mSettings.mPreferredActivities.size(); i++) {
            int thisUserId = this.mSettings.mPreferredActivities.keyAt(i);
            PreferredIntentResolver pir = (PreferredIntentResolver) this.mSettings.mPreferredActivities.valueAt(i);
            if (userId == -1 || userId == thisUserId) {
                Iterator<PreferredActivity> it = pir.filterIterator();
                while (it.hasNext()) {
                    PreferredActivity pa = (PreferredActivity) it.next();
                    if (packageName == null || (pa.mPref.mComponent.getPackageName().equals(packageName) && pa.mPref.mAlways)) {
                        if (!HwDeviceManager.disallowOp(17) || !pa.hasAction("android.intent.action.MAIN") || !pa.hasCategory("android.intent.category.HOME") || !pa.hasCategory("android.intent.category.DEFAULT")) {
                            if (removed == null) {
                                removed = new ArrayList();
                            }
                            removed.add(pa);
                        }
                    }
                }
                if (removed != null) {
                    for (int j = 0; j < removed.size(); j++) {
                        pir.removeFilter((PreferredActivity) removed.get(j));
                    }
                    changed = true;
                }
            }
        }
        if (changed) {
            postPreferredActivityChangedBroadcast(userId);
        }
        return changed;
    }

    private void clearIntentFilterVerificationsLPw(int userId) {
        int packageCount = this.mPackages.size();
        for (int i = 0; i < packageCount; i++) {
            clearIntentFilterVerificationsLPw(((Package) this.mPackages.valueAt(i)).packageName, userId);
        }
    }

    void clearIntentFilterVerificationsLPw(String packageName, int userId) {
        if (userId == -1) {
            if (this.mSettings.removeIntentFilterVerificationLPw(packageName, sUserManager.getUserIds())) {
                for (int oneUserId : sUserManager.getUserIds()) {
                    scheduleWritePackageRestrictionsLocked(oneUserId);
                }
            }
        } else if (this.mSettings.removeIntentFilterVerificationLPw(packageName, userId)) {
            scheduleWritePackageRestrictionsLocked(userId);
        }
    }

    void clearDefaultBrowserIfNeeded(String packageName) {
        for (int oneUserId : sUserManager.getUserIds()) {
            clearDefaultBrowserIfNeededForUser(packageName, oneUserId);
        }
    }

    private void clearDefaultBrowserIfNeededForUser(String packageName, int userId) {
        String defaultBrowserPackageName = getDefaultBrowserPackageName(userId);
        if (!TextUtils.isEmpty(defaultBrowserPackageName) && packageName.equals(defaultBrowserPackageName)) {
            setDefaultBrowserPackageName(null, userId);
        }
    }

    public void resetApplicationPreferences(int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        long identity = Binder.clearCallingIdentity();
        try {
            synchronized (this.mPackages) {
                clearPackagePreferredActivitiesLPw(null, userId);
                this.mSettings.applyDefaultPreferredAppsLPw(this, userId);
                applyFactoryDefaultBrowserLPw(userId);
                clearIntentFilterVerificationsLPw(userId);
                primeDomainVerificationsLPw(userId);
                resetUserChangesToRuntimePermissionsAndFlagsLPw(userId);
                scheduleWritePackageRestrictionsLocked(userId);
            }
            resetNetworkPolicies(userId);
            Binder.restoreCallingIdentity(identity);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(identity);
        }
    }

    public int getPreferredActivities(List<IntentFilter> outFilters, List<ComponentName> outActivities, String packageName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return 0;
        }
        int userId = UserHandle.getCallingUserId();
        synchronized (this.mPackages) {
            PreferredIntentResolver pir = (PreferredIntentResolver) this.mSettings.mPreferredActivities.get(userId);
            if (pir != null) {
                Iterator<PreferredActivity> it = pir.filterIterator();
                while (it.hasNext()) {
                    PreferredActivity pa = (PreferredActivity) it.next();
                    if (packageName == null || (pa.mPref.mComponent.getPackageName().equals(packageName) && pa.mPref.mAlways)) {
                        if (outFilters != null) {
                            outFilters.add(new IntentFilter(pa));
                        }
                        if (outActivities != null) {
                            outActivities.add(pa.mPref.mComponent);
                        }
                    }
                }
            }
        }
        return 0;
    }

    public void addPersistentPreferredActivity(IntentFilter filter, ComponentName activity, int userId) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("addPersistentPreferredActivity can only be run by the system");
        } else if (filter.countActions() == 0) {
            Slog.w(TAG, "Cannot set a preferred activity with no filter actions");
        } else {
            if (filter.hasCategory("android.intent.category.HOME") && activity != null) {
                if (filter.hasAction("android.intent.action.MDM_SET_DEFAULT_LAUNCHER_FOR_ANTIMAL")) {
                    Global.putInt(this.mContext.getContentResolver(), "hwMdmActionForAntimalFlag", 1);
                } else if (!this.mHwPMSEx.isAllowedSetHomeActivityForAntiMal(getPackageInfo(activity.getPackageName(), 0, userId), userId)) {
                    Slog.i(TAG, "NOT ALLOWED TO add persistent preferred activity current time!");
                    return;
                }
            }
            synchronized (this.mPackages) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Adding persistent preferred activity ");
                stringBuilder.append(activity);
                stringBuilder.append(" for user ");
                stringBuilder.append(userId);
                stringBuilder.append(":");
                Slog.i(str, stringBuilder.toString());
                filter.dump(new LogPrinter(4, TAG), "  ");
                this.mSettings.editPersistentPreferredActivitiesLPw(userId).addFilter(new PersistentPreferredActivity(filter, activity));
                scheduleWritePackageRestrictionsLocked(userId);
                postPreferredActivityChangedBroadcast(userId);
            }
        }
    }

    public void clearPackagePersistentPreferredActivities(String packageName, int userId) {
        if (Binder.getCallingUid() == 1000) {
            boolean changed = false;
            synchronized (this.mPackages) {
                ArrayList<PersistentPreferredActivity> removed = null;
                for (int i = 0; i < this.mSettings.mPersistentPreferredActivities.size(); i++) {
                    PersistentPreferredIntentResolver ppir = (PersistentPreferredIntentResolver) this.mSettings.mPersistentPreferredActivities.valueAt(i);
                    if (userId == this.mSettings.mPersistentPreferredActivities.keyAt(i)) {
                        Iterator<PersistentPreferredActivity> it = ppir.filterIterator();
                        while (it.hasNext()) {
                            PersistentPreferredActivity ppa = (PersistentPreferredActivity) it.next();
                            if (ppa.mComponent.getPackageName().equals(packageName)) {
                                if (removed == null) {
                                    removed = new ArrayList();
                                }
                                removed.add(ppa);
                            }
                        }
                        if (removed != null) {
                            for (int j = 0; j < removed.size(); j++) {
                                ppir.removeFilter((PersistentPreferredActivity) removed.get(j));
                            }
                            changed = true;
                        }
                    }
                }
                if (changed) {
                    scheduleWritePackageRestrictionsLocked(userId);
                    postPreferredActivityChangedBroadcast(userId);
                }
            }
            return;
        }
        throw new SecurityException("clearPackagePersistentPreferredActivities can only be run by the system");
    }

    /* JADX WARNING: Removed duplicated region for block: B:10:0x001a  */
    /* JADX WARNING: Removed duplicated region for block: B:6:0x000e  */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void restoreFromXml(XmlPullParser parser, int userId, String expectedStartTag, BlobXmlRestorer functor) throws IOException, XmlPullParserException {
        int type;
        while (true) {
            int next = parser.next();
            type = next;
            if (next == 2 || type == 1) {
                if (type == 2) {
                    if (DEBUG_BACKUP) {
                        Slog.e(TAG, "Didn't find start tag during restore");
                    }
                    return;
                }
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(":: restoreFromXml() : got to tag ");
                stringBuilder.append(parser.getName());
                Slog.v(str, stringBuilder.toString());
                if (expectedStartTag.equals(parser.getName())) {
                    while (true) {
                        next = parser.next();
                        type = next;
                        if (next != 4) {
                            str = TAG;
                            stringBuilder = new StringBuilder();
                            stringBuilder.append(":: stepped forward, applying functor at tag ");
                            stringBuilder.append(parser.getName());
                            Slog.v(str, stringBuilder.toString());
                            functor.apply(parser, userId);
                            return;
                        }
                    }
                } else {
                    if (DEBUG_BACKUP) {
                        str = TAG;
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("Found unexpected tag ");
                        stringBuilder.append(parser.getName());
                        Slog.e(str, stringBuilder.toString());
                    }
                    return;
                }
            }
        }
        if (type == 2) {
        }
    }

    public byte[] getPreferredActivityBackup(int userId) {
        if (Binder.getCallingUid() == 1000) {
            ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
            try {
                XmlSerializer serializer = new FastXmlSerializer();
                serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, Boolean.valueOf(true));
                serializer.startTag(null, TAG_PREFERRED_BACKUP);
                synchronized (this.mPackages) {
                    this.mSettings.writePreferredActivitiesLPr(serializer, userId, true);
                }
                serializer.endTag(null, TAG_PREFERRED_BACKUP);
                serializer.endDocument();
                serializer.flush();
                return dataStream.toByteArray();
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Unable to write preferred activities for backup", e);
                }
                return null;
            }
        }
        throw new SecurityException("Only the system may call getPreferredActivityBackup()");
    }

    public void restorePreferredActivities(byte[] backup, int userId) {
        if (Binder.getCallingUid() == 1000) {
            try {
                XmlPullParser parser = Xml.newPullParser();
                parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
                restoreFromXml(parser, userId, TAG_PREFERRED_BACKUP, new BlobXmlRestorer() {
                    public void apply(XmlPullParser parser, int userId) throws XmlPullParserException, IOException {
                        synchronized (PackageManagerService.this.mPackages) {
                            PackageManagerService.this.mSettings.readPreferredActivitiesLPw(parser, userId);
                        }
                    }
                });
                return;
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    String str = TAG;
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("Exception restoring preferred activities: ");
                    stringBuilder.append(e.getMessage());
                    Slog.e(str, stringBuilder.toString());
                    return;
                }
                return;
            }
        }
        throw new SecurityException("Only the system may call restorePreferredActivities()");
    }

    public byte[] getDefaultAppsBackup(int userId) {
        if (Binder.getCallingUid() == 1000) {
            ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
            try {
                XmlSerializer serializer = new FastXmlSerializer();
                serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, Boolean.valueOf(true));
                serializer.startTag(null, TAG_DEFAULT_APPS);
                synchronized (this.mPackages) {
                    this.mSettings.writeDefaultAppsLPr(serializer, userId);
                }
                serializer.endTag(null, TAG_DEFAULT_APPS);
                serializer.endDocument();
                serializer.flush();
                return dataStream.toByteArray();
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Unable to write default apps for backup", e);
                }
                return null;
            }
        }
        throw new SecurityException("Only the system may call getDefaultAppsBackup()");
    }

    public void restoreDefaultApps(byte[] backup, int userId) {
        if (Binder.getCallingUid() == 1000) {
            try {
                XmlPullParser parser = Xml.newPullParser();
                parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
                restoreFromXml(parser, userId, TAG_DEFAULT_APPS, new BlobXmlRestorer() {
                    public void apply(XmlPullParser parser, int userId) throws XmlPullParserException, IOException {
                        synchronized (PackageManagerService.this.mPackages) {
                            PackageManagerService.this.mSettings.readDefaultAppsLPw(parser, userId);
                        }
                    }
                });
                return;
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    String str = TAG;
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("Exception restoring default apps: ");
                    stringBuilder.append(e.getMessage());
                    Slog.e(str, stringBuilder.toString());
                    return;
                }
                return;
            }
        }
        throw new SecurityException("Only the system may call restoreDefaultApps()");
    }

    public byte[] getIntentFilterVerificationBackup(int userId) {
        if (Binder.getCallingUid() == 1000) {
            ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
            try {
                XmlSerializer serializer = new FastXmlSerializer();
                serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, Boolean.valueOf(true));
                serializer.startTag(null, TAG_INTENT_FILTER_VERIFICATION);
                synchronized (this.mPackages) {
                    this.mSettings.writeAllDomainVerificationsLPr(serializer, userId);
                }
                serializer.endTag(null, TAG_INTENT_FILTER_VERIFICATION);
                serializer.endDocument();
                serializer.flush();
                return dataStream.toByteArray();
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Unable to write default apps for backup", e);
                }
                return null;
            }
        }
        throw new SecurityException("Only the system may call getIntentFilterVerificationBackup()");
    }

    public void restoreIntentFilterVerification(byte[] backup, int userId) {
        if (Binder.getCallingUid() == 1000) {
            try {
                XmlPullParser parser = Xml.newPullParser();
                parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
                restoreFromXml(parser, userId, TAG_INTENT_FILTER_VERIFICATION, new BlobXmlRestorer() {
                    public void apply(XmlPullParser parser, int userId) throws XmlPullParserException, IOException {
                        synchronized (PackageManagerService.this.mPackages) {
                            PackageManagerService.this.mSettings.readAllDomainVerificationsLPr(parser, userId);
                            PackageManagerService.this.mSettings.writeLPr();
                        }
                    }
                });
                return;
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    String str = TAG;
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("Exception restoring preferred activities: ");
                    stringBuilder.append(e.getMessage());
                    Slog.e(str, stringBuilder.toString());
                    return;
                }
                return;
            }
        }
        throw new SecurityException("Only the system may call restorePreferredActivities()");
    }

    public byte[] getPermissionGrantBackup(int userId) {
        if (Binder.getCallingUid() == 1000) {
            ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
            try {
                XmlSerializer serializer = new FastXmlSerializer();
                serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, Boolean.valueOf(true));
                serializer.startTag(null, TAG_PERMISSION_BACKUP);
                synchronized (this.mPackages) {
                    serializeRuntimePermissionGrantsLPr(serializer, userId);
                }
                serializer.endTag(null, TAG_PERMISSION_BACKUP);
                serializer.endDocument();
                serializer.flush();
                return dataStream.toByteArray();
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Unable to write default apps for backup", e);
                }
                return null;
            }
        }
        throw new SecurityException("Only the system may call getPermissionGrantBackup()");
    }

    public void restorePermissionGrants(byte[] backup, int userId) {
        if (Binder.getCallingUid() == 1000) {
            try {
                XmlPullParser parser = Xml.newPullParser();
                parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
                restoreFromXml(parser, userId, TAG_PERMISSION_BACKUP, new BlobXmlRestorer() {
                    public void apply(XmlPullParser parser, int userId) throws XmlPullParserException, IOException {
                        synchronized (PackageManagerService.this.mPackages) {
                            PackageManagerService.this.processRestoredPermissionGrantsLPr(parser, userId);
                        }
                    }
                });
                return;
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    String str = TAG;
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("Exception restoring preferred activities: ");
                    stringBuilder.append(e.getMessage());
                    Slog.e(str, stringBuilder.toString());
                    return;
                }
                return;
            }
        }
        throw new SecurityException("Only the system may call restorePermissionGrants()");
    }

    private void serializeRuntimePermissionGrantsLPr(XmlSerializer serializer, int userId) throws IOException {
        PackageManagerService packageManagerService = this;
        XmlSerializer xmlSerializer = serializer;
        xmlSerializer.startTag(null, TAG_ALL_GRANTS);
        int N = packageManagerService.mSettings.mPackages.size();
        int i = 0;
        while (i < N) {
            boolean pkgGrantsKnown = false;
            for (PermissionState state : ((PackageSetting) r0.mSettings.mPackages.valueAt(i)).getPermissionsState().getRuntimePermissionStates(userId)) {
                int grantFlags = state.getFlags();
                if ((grantFlags & 52) == 0) {
                    boolean isGranted = state.isGranted();
                    if (isGranted || (grantFlags & 11) != 0) {
                        String packageName = (String) packageManagerService.mSettings.mPackages.keyAt(i);
                        if (!pkgGrantsKnown) {
                            xmlSerializer.startTag(null, TAG_GRANT);
                            xmlSerializer.attribute(null, "pkg", packageName);
                            pkgGrantsKnown = true;
                        }
                        boolean revoke = true;
                        boolean userSet = (grantFlags & 1) != 0;
                        boolean userFixed = (grantFlags & 2) != 0;
                        if ((grantFlags & 8) == 0) {
                            revoke = false;
                        }
                        xmlSerializer.startTag(null, TAG_PERMISSION);
                        xmlSerializer.attribute(null, "name", state.getName());
                        if (isGranted) {
                            xmlSerializer.attribute(null, ATTR_IS_GRANTED, "true");
                        }
                        if (userSet) {
                            xmlSerializer.attribute(null, ATTR_USER_SET, "true");
                        }
                        if (userFixed) {
                            xmlSerializer.attribute(null, ATTR_USER_FIXED, "true");
                        }
                        if (revoke) {
                            xmlSerializer.attribute(null, ATTR_REVOKE_ON_UPGRADE, "true");
                        }
                        xmlSerializer.endTag(null, TAG_PERMISSION);
                    }
                }
                packageManagerService = this;
            }
            if (pkgGrantsKnown) {
                xmlSerializer.endTag(null, TAG_GRANT);
            }
            i++;
            packageManagerService = this;
        }
        int i2 = userId;
        xmlSerializer.endTag(null, TAG_ALL_GRANTS);
    }

    private void processRestoredPermissionGrantsLPr(XmlPullParser parser, int userId) throws XmlPullParserException, IOException {
        XmlPullParser xmlPullParser = parser;
        int i = userId;
        int outerDepth = parser.getDepth();
        String pkgName = null;
        while (true) {
            int outerDepth2 = outerDepth;
            int next = parser.next();
            int type = next;
            if (next == 1 || (type == 3 && parser.getDepth() <= outerDepth2)) {
                scheduleWriteSettingsLocked();
                this.mSettings.writeRuntimePermissionsForUserLPr(i, false);
            } else {
                if (!(type == 3 || type == 4)) {
                    String tagName = parser.getName();
                    String str;
                    StringBuilder stringBuilder;
                    if (tagName.equals(TAG_GRANT)) {
                        pkgName = xmlPullParser.getAttributeValue(null, "pkg");
                        if (DEBUG_BACKUP) {
                            str = TAG;
                            stringBuilder = new StringBuilder();
                            stringBuilder.append("+++ Restoring grants for package ");
                            stringBuilder.append(pkgName);
                            Slog.v(str, stringBuilder.toString());
                        }
                    } else if (tagName.equals(TAG_PERMISSION)) {
                        boolean isGranted = "true".equals(xmlPullParser.getAttributeValue(null, ATTR_IS_GRANTED));
                        String permName = xmlPullParser.getAttributeValue(null, "name");
                        next = 0;
                        if ("true".equals(xmlPullParser.getAttributeValue(null, ATTR_USER_SET))) {
                            next = 0 | 1;
                        }
                        if ("true".equals(xmlPullParser.getAttributeValue(null, ATTR_USER_FIXED))) {
                            next |= 2;
                        }
                        if ("true".equals(xmlPullParser.getAttributeValue(null, ATTR_REVOKE_ON_UPGRADE))) {
                            next |= 8;
                        }
                        int newFlagSet = next;
                        if (DEBUG_BACKUP) {
                            str = TAG;
                            stringBuilder = new StringBuilder();
                            stringBuilder.append("  + Restoring grant: pkg=");
                            stringBuilder.append(pkgName);
                            stringBuilder.append(" perm=");
                            stringBuilder.append(permName);
                            stringBuilder.append(" granted=");
                            stringBuilder.append(isGranted);
                            stringBuilder.append(" bits=0x");
                            stringBuilder.append(Integer.toHexString(newFlagSet));
                            Slog.v(str, stringBuilder.toString());
                        }
                        PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(pkgName);
                        if (ps != null) {
                            if (DEBUG_BACKUP) {
                                Slog.v(TAG, "        + already installed; applying");
                            }
                            PermissionsState perms = ps.getPermissionsState();
                            BasePermission bp = this.mPermissionManager.getPermissionTEMP(permName);
                            if (bp != null) {
                                if (isGranted) {
                                    perms.grantRuntimePermission(bp, i);
                                }
                                if (newFlagSet != 0) {
                                    perms.updatePermissionFlags(bp, i, 11, newFlagSet);
                                }
                            }
                        } else {
                            if (DEBUG_BACKUP) {
                                Slog.v(TAG, "        - not yet installed; saving for later");
                            }
                            this.mSettings.processRestoredPermissionGrantLPr(pkgName, permName, isGranted, newFlagSet, i);
                        }
                    } else {
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("Unknown element under <perm-grant-backup>: ");
                        stringBuilder.append(tagName);
                        reportSettingsProblem(5, stringBuilder.toString());
                        XmlUtils.skipCurrentTag(parser);
                    }
                }
                outerDepth = outerDepth2;
            }
        }
        scheduleWriteSettingsLocked();
        this.mSettings.writeRuntimePermissionsForUserLPr(i, false);
    }

    public void addCrossProfileIntentFilter(IntentFilter intentFilter, String ownerPackage, int sourceUserId, int targetUserId, int flags) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        int callingUid = Binder.getCallingUid();
        enforceOwnerRights(ownerPackage, callingUid);
        PackageManagerServiceUtils.enforceShellRestriction("no_debugging_features", callingUid, sourceUserId);
        if (intentFilter.countActions() == 0) {
            Slog.w(TAG, "Cannot set a crossProfile intent filter with no filter actions");
            return;
        }
        synchronized (this.mPackages) {
            CrossProfileIntentFilter newFilter = new CrossProfileIntentFilter(intentFilter, ownerPackage, targetUserId, flags);
            CrossProfileIntentResolver resolver = this.mSettings.editCrossProfileIntentResolverLPw(sourceUserId);
            ArrayList<CrossProfileIntentFilter> existing = resolver.findFilters(intentFilter);
            if (existing != null) {
                int size = existing.size();
                for (int i = 0; i < size; i++) {
                    if (newFilter.equalsIgnoreFilter((CrossProfileIntentFilter) existing.get(i))) {
                        return;
                    }
                }
            }
            resolver.addFilter(newFilter);
            scheduleWritePackageRestrictionsLocked(sourceUserId);
        }
    }

    public void clearCrossProfileIntentFilters(int sourceUserId, String ownerPackage) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        int callingUid = Binder.getCallingUid();
        enforceOwnerRights(ownerPackage, callingUid);
        PackageManagerServiceUtils.enforceShellRestriction("no_debugging_features", callingUid, sourceUserId);
        synchronized (this.mPackages) {
            CrossProfileIntentResolver resolver = this.mSettings.editCrossProfileIntentResolverLPw(sourceUserId);
            Iterator it = new ArraySet(resolver.filterSet()).iterator();
            while (it.hasNext()) {
                CrossProfileIntentFilter filter = (CrossProfileIntentFilter) it.next();
                if (filter.getOwnerPackage().equals(ownerPackage)) {
                    resolver.removeFilter(filter);
                }
            }
            scheduleWritePackageRestrictionsLocked(sourceUserId);
        }
    }

    private void enforceOwnerRights(String pkg, int callingUid) {
        if (UserHandle.getAppId(callingUid) != 1000) {
            int callingUserId = UserHandle.getUserId(callingUid);
            PackageInfo pi = getPackageInfo(pkg, null, callingUserId);
            StringBuilder stringBuilder;
            if (pi == null) {
                stringBuilder = new StringBuilder();
                stringBuilder.append("Unknown package ");
                stringBuilder.append(pkg);
                stringBuilder.append(" on user ");
                stringBuilder.append(callingUserId);
                throw new IllegalArgumentException(stringBuilder.toString());
            } else if (!UserHandle.isSameApp(pi.applicationInfo.uid, callingUid)) {
                stringBuilder = new StringBuilder();
                stringBuilder.append("Calling uid ");
                stringBuilder.append(callingUid);
                stringBuilder.append(" does not own package ");
                stringBuilder.append(pkg);
                throw new SecurityException(stringBuilder.toString());
            }
        }
    }

    public ComponentName getHomeActivities(List<ResolveInfo> allHomeCandidates) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        return getHomeActivitiesAsUser(allHomeCandidates, UserHandle.getCallingUserId());
    }

    public void sendSessionCommitBroadcast(SessionInfo sessionInfo, int userId) {
        UserManagerService ums = UserManagerService.getInstance();
        if (ums != null) {
            UserInfo parent = ums.getProfileParent(userId);
            int launcherUid = parent != null ? parent.id : userId;
            ComponentName launcherComponent = getDefaultHomeActivity(launcherUid);
            if (launcherComponent != null) {
                this.mContext.sendBroadcastAsUser(new Intent("android.content.pm.action.SESSION_COMMITTED").putExtra("android.content.pm.extra.SESSION", sessionInfo).putExtra("android.intent.extra.USER", UserHandle.of(userId)).setPackage(launcherComponent.getPackageName()), UserHandle.of(launcherUid));
            }
        }
    }

    private ComponentName getDefaultHomeActivity(int userId) {
        List<ResolveInfo> allHomeCandidates = new ArrayList();
        ComponentName cn = getHomeActivitiesAsUser(allHomeCandidates, userId);
        if (cn != null) {
            return cn;
        }
        int lastPriority = Integer.MIN_VALUE;
        ComponentName lastComponent = null;
        int size = allHomeCandidates.size();
        for (int i = 0; i < size; i++) {
            ResolveInfo ri = (ResolveInfo) allHomeCandidates.get(i);
            if (ri.priority > lastPriority) {
                lastComponent = ri.activityInfo.getComponentName();
                lastPriority = ri.priority;
            } else if (ri.priority == lastPriority) {
                lastComponent = null;
            }
        }
        return lastComponent;
    }

    private Intent getHomeIntent() {
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory("android.intent.category.HOME");
        intent.addCategory("android.intent.category.DEFAULT");
        return intent;
    }

    private IntentFilter getHomeFilter() {
        IntentFilter filter = new IntentFilter("android.intent.action.MAIN");
        filter.addCategory("android.intent.category.HOME");
        filter.addCategory("android.intent.category.DEFAULT");
        return filter;
    }

    ComponentName getHomeActivitiesAsUser(List<ResolveInfo> allHomeCandidates, int userId) {
        Intent intent = getHomeIntent();
        List<ResolveInfo> list = queryIntentActivitiesInternal(intent, null, 128, userId);
        ResolveInfo preferred = findPreferredActivity(intent, null, 0, list, 0, true, false, false, userId);
        allHomeCandidates.clear();
        if (list != null) {
            for (ResolveInfo ri : list) {
                allHomeCandidates.add(ri);
            }
        }
        if (preferred == null || preferred.activityInfo == null) {
            return null;
        }
        return new ComponentName(preferred.activityInfo.packageName, preferred.activityInfo.name);
    }

    public void setHomeActivity(ComponentName comp, int userId) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            ArrayList<ResolveInfo> homeActivities = new ArrayList();
            getHomeActivitiesAsUser(homeActivities, userId);
            boolean found = false;
            int size = homeActivities.size();
            ComponentName[] set = new ComponentName[size];
            for (int i = 0; i < size; i++) {
                ActivityInfo info = ((ResolveInfo) homeActivities.get(i)).activityInfo;
                ComponentName activityName = new ComponentName(info.packageName, info.name);
                set[i] = activityName;
                if (!found && activityName.equals(comp)) {
                    found = true;
                }
            }
            if (found) {
                replacePreferredActivity(getHomeFilter(), 1048576, set, comp, userId);
                return;
            }
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Component ");
            stringBuilder.append(comp);
            stringBuilder.append(" cannot be home on user ");
            stringBuilder.append(userId);
            throw new IllegalArgumentException(stringBuilder.toString());
        }
    }

    private String getSetupWizardPackageName() {
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory("android.intent.category.SETUP_WIZARD");
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, null, 1835520, UserHandle.myUserId());
        if (matches.size() == 1) {
            return ((ResolveInfo) matches.get(0)).getComponentInfo().packageName;
        }
        String str = TAG;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("There should probably be exactly one setup wizard; found ");
        stringBuilder.append(matches.size());
        stringBuilder.append(": matches=");
        stringBuilder.append(matches);
        Slog.e(str, stringBuilder.toString());
        return null;
    }

    private String getStorageManagerPackageName() {
        List<ResolveInfo> matches = queryIntentActivitiesInternal(new Intent("android.os.storage.action.MANAGE_STORAGE"), null, 1835520, UserHandle.myUserId());
        if (matches.size() == 1) {
            return ((ResolveInfo) matches.get(0)).getComponentInfo().packageName;
        }
        String str = TAG;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("There should probably be exactly one storage manager; found ");
        stringBuilder.append(matches.size());
        stringBuilder.append(": matches=");
        stringBuilder.append(matches);
        Slog.e(str, stringBuilder.toString());
        return null;
    }

    public String getSystemTextClassifierPackageName() {
        return this.mContext.getString(17039791);
    }

    public void setApplicationEnabledSetting(String appPackageName, int newState, int flags, int userId, String callingPackage) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(BehaviorId.PACKAGEMANAGER_SETAPPLICATIONENABLEDSETTING);
        if (sUserManager.exists(userId)) {
            if (callingPackage == null) {
                callingPackage = Integer.toString(Binder.getCallingUid());
            }
            setEnabledSetting(appPackageName, null, newState, flags, userId, callingPackage);
        }
    }

    public void setUpdateAvailable(String packageName, boolean updateAvailable) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INSTALL_PACKAGES", null);
        synchronized (this.mPackages) {
            PackageSetting pkgSetting = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (pkgSetting != null) {
                pkgSetting.setUpdateAvailable(updateAvailable);
            }
        }
    }

    public void setComponentEnabledSetting(ComponentName componentName, int newState, int flags, int userId) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(BehaviorId.PACKAGEMANAGER_SETCOMPONENTENABLEDSETTING, new Object[]{Integer.valueOf(newState)});
        if (sUserManager.exists(userId) && componentName != null) {
            setEnabledSetting(componentName.getPackageName(), componentName.getClassName(), newState, flags, userId, null);
        }
    }

    /* JADX WARNING: Unknown top exception splitter block from list: {B:283:0x04a1=Splitter:B:283:0x04a1, B:307:0x04e2=Splitter:B:307:0x04e2, B:290:0x04a7=Splitter:B:290:0x04a7, B:238:0x042d=Splitter:B:238:0x042d} */
    /* JADX WARNING: Removed duplicated region for block: B:179:0x037f A:{SYNTHETIC, Splitter:B:179:0x037f} */
    /* JADX WARNING: Removed duplicated region for block: B:280:0x0492 A:{SYNTHETIC, Splitter:B:280:0x0492} */
    /* JADX WARNING: Removed duplicated region for block: B:293:0x04aa A:{SYNTHETIC, Splitter:B:293:0x04aa} */
    /* JADX WARNING: Removed duplicated region for block: B:206:0x03df A:{SYNTHETIC, Splitter:B:206:0x03df} */
    /* JADX WARNING: Removed duplicated region for block: B:216:0x0403  */
    /* JADX WARNING: Removed duplicated region for block: B:226:0x0415 A:{SYNTHETIC, Splitter:B:226:0x0415} */
    /* JADX WARNING: Removed duplicated region for block: B:266:0x0465 A:{SYNTHETIC, Splitter:B:266:0x0465} */
    /* JADX WARNING: Removed duplicated region for block: B:293:0x04aa A:{SYNTHETIC, Splitter:B:293:0x04aa} */
    /* JADX WARNING: Removed duplicated region for block: B:266:0x0465 A:{SYNTHETIC, Splitter:B:266:0x0465} */
    /* JADX WARNING: Missing block: B:54:0x0174, code skipped:
            if (android.os.UserHandle.isSameApp(r15, r5.appId) != false) goto L_0x01f2;
     */
    /* JADX WARNING: Missing block: B:55:0x0176, code skipped:
            if (r18 == false) goto L_0x019f;
     */
    /* JADX WARNING: Missing block: B:57:0x017c, code skipped:
            if (filterAppAccessLPr(r5, r15, r13) == false) goto L_0x017f;
     */
    /* JADX WARNING: Missing block: B:59:0x0185, code skipped:
            if (r8.mProtectedPackages.isPackageStateProtected(r13, r9) != false) goto L_0x0188;
     */
    /* JADX WARNING: Missing block: B:60:0x0188, code skipped:
            r1 = new java.lang.StringBuilder();
            r1.append("Cannot disable a protected package: ");
            r1.append(r9);
     */
    /* JADX WARNING: Missing block: B:61:0x019e, code skipped:
            throw new java.lang.SecurityException(r1.toString());
     */
    /* JADX WARNING: Missing block: B:62:0x019f, code skipped:
            r1 = new java.lang.StringBuilder();
            r1.append("Attempt to change component state; pid=");
            r1.append(android.os.Binder.getCallingPid());
            r1.append(", uid=");
            r1.append(r15);
     */
    /* JADX WARNING: Missing block: B:63:0x01ba, code skipped:
            if (r10 != null) goto L_0x01ce;
     */
    /* JADX WARNING: Missing block: B:64:0x01bc, code skipped:
            r2 = new java.lang.StringBuilder();
            r2.append(", package=");
            r2.append(r9);
            r2 = r2.toString();
     */
    /* JADX WARNING: Missing block: B:65:0x01ce, code skipped:
            r2 = new java.lang.StringBuilder();
            r2.append(", component=");
            r2.append(r9);
            r2.append(com.android.server.slice.SliceClientPermissions.SliceAuthority.DELIMITER);
            r2.append(r10);
            r2 = r2.toString();
     */
    /* JADX WARNING: Missing block: B:66:0x01e7, code skipped:
            r1.append(r2);
     */
    /* JADX WARNING: Missing block: B:67:0x01f1, code skipped:
            throw new java.lang.SecurityException(r1.toString());
     */
    /* JADX WARNING: Missing block: B:68:0x01f2, code skipped:
            r2 = r8.mPackages;
     */
    /* JADX WARNING: Missing block: B:69:0x01f4, code skipped:
            monitor-enter(r2);
     */
    /* JADX WARNING: Missing block: B:71:0x01f7, code skipped:
            if (r15 != 2000) goto L_0x0241;
     */
    /* JADX WARNING: Missing block: B:74:0x01fd, code skipped:
            if ((r5.pkgFlags & 256) != 0) goto L_0x0241;
     */
    /* JADX WARNING: Missing block: B:75:0x01ff, code skipped:
            r1 = r5.getEnabled(r13);
     */
    /* JADX WARNING: Missing block: B:76:0x0203, code skipped:
            if (r10 != null) goto L_0x0212;
     */
    /* JADX WARNING: Missing block: B:77:0x0205, code skipped:
            if (r1 == 3) goto L_0x020b;
     */
    /* JADX WARNING: Missing block: B:78:0x0207, code skipped:
            if (r1 == 0) goto L_0x020b;
     */
    /* JADX WARNING: Missing block: B:79:0x0209, code skipped:
            if (r1 != 1) goto L_0x0212;
     */
    /* JADX WARNING: Missing block: B:80:0x020b, code skipped:
            if (r11 == 3) goto L_0x0241;
     */
    /* JADX WARNING: Missing block: B:81:0x020d, code skipped:
            if (r11 == 0) goto L_0x0241;
     */
    /* JADX WARNING: Missing block: B:82:0x020f, code skipped:
            if (r11 != 1) goto L_0x0212;
     */
    /* JADX WARNING: Missing block: B:84:0x0212, code skipped:
            r3 = new java.lang.StringBuilder();
            r3.append("Shell cannot change component state for ");
            r3.append(r9);
            r3.append(com.android.server.slice.SliceClientPermissions.SliceAuthority.DELIMITER);
            r3.append(r10);
            r3.append(" to ");
            r3.append(r11);
     */
    /* JADX WARNING: Missing block: B:85:0x0238, code skipped:
            throw new java.lang.SecurityException(r3.toString());
     */
    /* JADX WARNING: Missing block: B:86:0x0239, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:87:0x023a, code skipped:
            r6 = r12;
            r34 = r15;
            r15 = r7;
            r7 = r5;
     */
    /* JADX WARNING: Missing block: B:89:?, code skipped:
            monitor-exit(r2);
     */
    /* JADX WARNING: Missing block: B:91:0x0244, code skipped:
            if (r10 != null) goto L_0x0540;
     */
    /* JADX WARNING: Missing block: B:92:0x0246, code skipped:
            r1 = r8.mPackages;
     */
    /* JADX WARNING: Missing block: B:93:0x0248, code skipped:
            monitor-enter(r1);
     */
    /* JADX WARNING: Missing block: B:96:0x024d, code skipped:
            if (r5.getEnabled(r13) != r11) goto L_0x0258;
     */
    /* JADX WARNING: Missing block: B:98:?, code skipped:
            monitor-exit(r1);
     */
    /* JADX WARNING: Missing block: B:99:0x0250, code skipped:
            return;
     */
    /* JADX WARNING: Missing block: B:100:0x0251, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:101:0x0252, code skipped:
            r12 = r5;
            r34 = r15;
            r15 = r7;
     */
    /* JADX WARNING: Missing block: B:103:?, code skipped:
            monitor-exit(r1);
     */
    /* JADX WARNING: Missing block: B:104:0x0259, code skipped:
            r6 = r5.pkg;
     */
    /* JADX WARNING: Missing block: B:105:0x025d, code skipped:
            if (r6.isStub == false) goto L_0x0267;
     */
    /* JADX WARNING: Missing block: B:107:0x0263, code skipped:
            if (r6.isSystem() == false) goto L_0x0267;
     */
    /* JADX WARNING: Missing block: B:108:0x0265, code skipped:
            r1 = true;
     */
    /* JADX WARNING: Missing block: B:109:0x0267, code skipped:
            r1 = false;
     */
    /* JADX WARNING: Missing block: B:111:0x026b, code skipped:
            if (r1 == false) goto L_0x051b;
     */
    /* JADX WARNING: Missing block: B:112:0x026d, code skipped:
            if (r11 == 0) goto L_0x0279;
     */
    /* JADX WARNING: Missing block: B:113:0x026f, code skipped:
            if (r11 != 1) goto L_0x0272;
     */
    /* JADX WARNING: Missing block: B:114:0x0272, code skipped:
            r12 = r5;
            r4 = r6;
            r34 = r15;
            r15 = r7;
     */
    /* JADX WARNING: Missing block: B:115:0x0279, code skipped:
            r4 = decompressPackage(r6);
     */
    /* JADX WARNING: Missing block: B:116:0x027d, code skipped:
            if (r4 != null) goto L_0x0298;
     */
    /* JADX WARNING: Missing block: B:117:0x027f, code skipped:
            r0 = TAG;
            r1 = new java.lang.StringBuilder();
            r1.append("couldn't decompress pkg: ");
            r1.append(r5.name);
            android.util.Slog.e(r0, r1.toString());
     */
    /* JADX WARNING: Missing block: B:118:0x0297, code skipped:
            return;
     */
    /* JADX WARNING: Missing block: B:119:0x0298, code skipped:
            r3 = new android.content.pm.PackageParser();
            r3.setSeparateProcesses(r8.mSeparateProcesses);
            r3.setDisplayMetrics(r8.mMetrics);
            r3.setCallback(r8.mPackageParserCallback);
     */
    /* JADX WARNING: Missing block: B:122:0x02b5, code skipped:
            r2 = r3.parsePackage(r4, 16 | (r8.mDefParseFlags | 1));
            r1 = r8.mInstallLock;
     */
    /* JADX WARNING: Missing block: B:123:0x02ba, code skipped:
            monitor-enter(r1);
     */
    /* JADX WARNING: Missing block: B:125:?, code skipped:
            removePackageLI(r6, true);
            r14 = r8.mPackages;
     */
    /* JADX WARNING: Missing block: B:126:0x02c0, code skipped:
            monitor-enter(r14);
     */
    /* JADX WARNING: Missing block: B:128:?, code skipped:
            disableSystemPackageLPw(r6, r2);
     */
    /* JADX WARNING: Missing block: B:129:0x02c4, code skipped:
            monitor-exit(r14);
     */
    /* JADX WARNING: Missing block: B:132:0x02ce, code skipped:
            r14 = freezePackage(r6.packageName, "setEnabledSetting");
     */
    /* JADX WARNING: Missing block: B:135:0x02d2, code skipped:
            r28 = r1;
            r29 = r2;
            r30 = r3;
            r31 = r4;
            r32 = r5;
            r33 = r6;
            r34 = r15;
            r15 = r7;
     */
    /* JADX WARNING: Missing block: B:137:?, code skipped:
            r7 = scanPackageTracedLI(r4, (r8.mDefParseFlags | Integer.MIN_VALUE) | 64, 0, 0, (android.os.UserHandle) null);
            prepareAppDataAfterInstallLIF(r7);
            r6 = r8.mPackages;
     */
    /* JADX WARNING: Missing block: B:138:0x02ff, code skipped:
            monitor-enter(r6);
     */
    /* JADX WARNING: Missing block: B:141:?, code skipped:
            updateSharedLibrariesLPr(r7, null);
     */
    /* JADX WARNING: Missing block: B:142:0x0305, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:143:0x0306, code skipped:
            r25 = r6;
     */
    /* JADX WARNING: Missing block: B:144:0x0309, code skipped:
            r0 = move-exception;
     */
    /* JADX WARNING: Missing block: B:145:0x030a, code skipped:
            r1 = r0;
     */
    /* JADX WARNING: Missing block: B:147:?, code skipped:
            android.util.Slog.e(TAG, "updateAllSharedLibrariesLPw failed: ", r0);
     */
    /* JADX WARNING: Missing block: B:167:0x0352, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:168:0x0353, code skipped:
            r1 = null;
     */
    /* JADX WARNING: Missing block: B:169:0x0355, code skipped:
            r0 = move-exception;
     */
    /* JADX WARNING: Missing block: B:170:0x0356, code skipped:
            r1 = r0;
     */
    /* JADX WARNING: Missing block: B:171:0x0358, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:172:0x0359, code skipped:
            r28 = r1;
            r29 = r2;
            r30 = r3;
            r31 = r4;
            r32 = r5;
            r33 = r6;
            r34 = r15;
            r15 = r7;
            r1 = null;
     */
    /* JADX WARNING: Missing block: B:173:0x036a, code skipped:
            r0 = move-exception;
     */
    /* JADX WARNING: Missing block: B:174:0x036b, code skipped:
            r28 = r1;
            r29 = r2;
            r30 = r3;
            r31 = r4;
            r32 = r5;
            r33 = r6;
            r34 = r15;
            r15 = r7;
            r1 = r0;
     */
    /* JADX WARNING: Missing block: B:176:?, code skipped:
            throw r1;
     */
    /* JADX WARNING: Missing block: B:177:0x037c, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:178:0x037d, code skipped:
            if (r14 != null) goto L_0x037f;
     */
    /* JADX WARNING: Missing block: B:180:?, code skipped:
            $closeResource(r1, r14);
     */
    /* JADX WARNING: Missing block: B:185:0x038e, code skipped:
            throw r0;
     */
    /* JADX WARNING: Missing block: B:186:0x038f, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:187:0x0390, code skipped:
            r28 = r1;
            r29 = r2;
            r30 = r3;
            r34 = r15;
            r15 = r7;
            r17 = r4;
            r12 = r5;
            r4 = r6;
     */
    /* JADX WARNING: Missing block: B:188:0x039f, code skipped:
            r0 = e;
     */
    /* JADX WARNING: Missing block: B:189:0x03a0, code skipped:
            r28 = r1;
            r29 = r2;
            r30 = r3;
            r31 = r4;
            r32 = r5;
            r33 = r6;
            r34 = r15;
            r15 = r7;
     */
    /* JADX WARNING: Missing block: B:207:?, code skipped:
            enableSystemPackageLPw(r5);
     */
    /* JADX WARNING: Missing block: B:218:?, code skipped:
            $closeResource(null, r2);
     */
    /* JADX WARNING: Missing block: B:219:0x0408, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:220:0x0409, code skipped:
            r4 = r36;
     */
    /* JADX WARNING: Missing block: B:221:0x040d, code skipped:
            r0 = e;
     */
    /* JADX WARNING: Missing block: B:222:0x040e, code skipped:
            r4 = r36;
     */
    /* JADX WARNING: Missing block: B:230:?, code skipped:
            r8.mSettings.disableSystemPackageLPw(r36.packageName, true);
            r8.mSettings.writeLPr();
     */
    /* JADX WARNING: Missing block: B:233:0x0427, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:235:0x0429, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:236:0x042a, code skipped:
            r4 = r36;
     */
    /* JADX WARNING: Missing block: B:247:0x0442, code skipped:
            r2 = r4;
            r4 = r5;
            r17 = r6;
            r12 = r7;
            r3 = null;
     */
    /* JADX WARNING: Missing block: B:252:0x044a, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:253:0x044c, code skipped:
            r0 = move-exception;
     */
    /* JADX WARNING: Missing block: B:254:0x044d, code skipped:
            r1 = r0;
     */
    /* JADX WARNING: Missing block: B:306:0x04d5, code skipped:
            r28 = r1;
            r29 = r2;
            r30 = r3;
            r17 = r4;
            r12 = r5;
            r4 = r6;
            r34 = r15;
            r15 = r7;
     */
    /* JADX WARNING: Missing block: B:313:0x04e6, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:314:0x04e7, code skipped:
            r28 = r1;
            r29 = r2;
            r30 = r3;
            r17 = r4;
            r12 = r5;
            r4 = r6;
            r34 = r15;
            r15 = r7;
     */
    /* JADX WARNING: Missing block: B:317:0x04f6, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:318:0x04f8, code skipped:
            r0 = move-exception;
     */
    /* JADX WARNING: Missing block: B:319:0x04f9, code skipped:
            r30 = r3;
            r17 = r4;
            r12 = r5;
            r4 = r6;
            r34 = r15;
            r15 = r7;
            r1 = TAG;
            r2 = new java.lang.StringBuilder();
            r2.append("Failed to parse compressed system package:");
            r2.append(r12.name);
            android.util.Slog.w(r1, r2.toString(), r0);
     */
    /* JADX WARNING: Missing block: B:320:0x051a, code skipped:
            return;
     */
    /* JADX WARNING: Missing block: B:321:0x051b, code skipped:
            r12 = r5;
            r4 = r6;
            r34 = r15;
            r15 = r7;
     */
    /* JADX WARNING: Missing block: B:336:0x0537, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:337:0x0538, code skipped:
            r12 = r5;
            r34 = r15;
            r15 = r7;
     */
    /* JADX WARNING: Missing block: B:339:?, code skipped:
            monitor-exit(r1);
     */
    /* JADX WARNING: Missing block: B:340:0x053d, code skipped:
            throw r0;
     */
    /* JADX WARNING: Missing block: B:341:0x053e, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:343:0x0540, code skipped:
            r12 = r5;
            r34 = r15;
            r15 = r7;
            r1 = r8.mPackages;
     */
    /* JADX WARNING: Missing block: B:344:0x0546, code skipped:
            monitor-enter(r1);
     */
    /* JADX WARNING: Missing block: B:346:?, code skipped:
            r2 = r12.pkg;
     */
    /* JADX WARNING: Missing block: B:347:0x0549, code skipped:
            if (r2 == null) goto L_0x0558;
     */
    /* JADX WARNING: Missing block: B:350:0x054f, code skipped:
            if (r2.hasComponentClassName(r10) != false) goto L_0x059e;
     */
    /* JADX WARNING: Missing block: B:352:0x0552, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:353:0x0553, code skipped:
            r7 = r12;
            r6 = r43;
     */
    /* JADX WARNING: Missing block: B:354:0x0558, code skipped:
            if (r2 == null) goto L_0x0580;
     */
    /* JADX WARNING: Missing block: B:356:0x055e, code skipped:
            if (r2.applicationInfo.targetSdkVersion >= 16) goto L_0x0561;
     */
    /* JADX WARNING: Missing block: B:358:0x0561, code skipped:
            r3 = new java.lang.StringBuilder();
            r3.append("Component class ");
            r3.append(r10);
            r3.append(" does not exist in ");
            r3.append(r9);
     */
    /* JADX WARNING: Missing block: B:359:0x057f, code skipped:
            throw new java.lang.IllegalArgumentException(r3.toString());
     */
    /* JADX WARNING: Missing block: B:361:?, code skipped:
            r0 = TAG;
            r3 = new java.lang.StringBuilder();
            r3.append("Failed setComponentEnabledSetting: component class ");
            r3.append(r10);
            r3.append(" does not exist in ");
            r3.append(r9);
            android.util.Slog.w(r0, r3.toString());
     */
    /* JADX WARNING: Missing block: B:362:0x059e, code skipped:
            switch(r11) {
                case 0: goto L_0x05b8;
                case 1: goto L_0x05b0;
                case 2: goto L_0x05a8;
                default: goto L_0x05a1;
            };
     */
    /* JADX WARNING: Missing block: B:363:0x05a1, code skipped:
            r7 = r12;
            r6 = r43;
     */
    /* JADX WARNING: Missing block: B:365:?, code skipped:
            r0 = TAG;
     */
    /* JADX WARNING: Missing block: B:368:0x05ac, code skipped:
            if (r12.disableComponentLPw(r10, r13) != false) goto L_0x05c0;
     */
    /* JADX WARNING: Missing block: B:369:0x05ae, code skipped:
            monitor-exit(r1);
     */
    /* JADX WARNING: Missing block: B:370:0x05af, code skipped:
            return;
     */
    /* JADX WARNING: Missing block: B:372:0x05b4, code skipped:
            if (r12.enableComponentLPw(r10, r13) != false) goto L_0x05c0;
     */
    /* JADX WARNING: Missing block: B:373:0x05b6, code skipped:
            monitor-exit(r1);
     */
    /* JADX WARNING: Missing block: B:374:0x05b7, code skipped:
            return;
     */
    /* JADX WARNING: Missing block: B:377:0x05bc, code skipped:
            if (r12.restoreComponentLPw(r10, r13) != false) goto L_0x05c0;
     */
    /* JADX WARNING: Missing block: B:379:?, code skipped:
            monitor-exit(r1);
     */
    /* JADX WARNING: Missing block: B:380:0x05bf, code skipped:
            return;
     */
    /* JADX WARNING: Missing block: B:382:?, code skipped:
            monitor-exit(r1);
     */
    /* JADX WARNING: Missing block: B:383:0x05c1, code skipped:
            r2 = r45;
     */
    /* JADX WARNING: Missing block: B:425:0x0639, code skipped:
            r1 = r0;
            r2 = android.os.Binder.clearCallingIdentity();
     */
    /* JADX WARNING: Missing block: B:426:0x063e, code skipped:
            if (r19 == false) goto L_0x065b;
     */
    /* JADX WARNING: Missing block: B:429:0x0646, code skipped:
            r4 = android.os.UserHandle.getUid(r13, r7.appId);
     */
    /* JADX WARNING: Missing block: B:430:0x0649, code skipped:
            if ((r6 & 1) == 0) goto L_0x064c;
     */
    /* JADX WARNING: Missing block: B:431:0x064c, code skipped:
            r14 = false;
     */
    /* JADX WARNING: Missing block: B:433:?, code skipped:
            sendPackageChangedBroadcast(r9, r14, r1, r4);
     */
    /* JADX WARNING: Missing block: B:434:0x0652, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:435:0x0653, code skipped:
            r22 = r4;
     */
    /* JADX WARNING: Missing block: B:436:0x0656, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:437:0x0657, code skipped:
            android.os.Binder.restoreCallingIdentity(r2);
     */
    /* JADX WARNING: Missing block: B:438:0x065a, code skipped:
            throw r0;
     */
    /* JADX WARNING: Missing block: B:439:0x065b, code skipped:
            r4 = -1;
     */
    /* JADX WARNING: Missing block: B:440:0x065d, code skipped:
            android.os.Binder.restoreCallingIdentity(r2);
     */
    /* JADX WARNING: Missing block: B:441:0x0661, code skipped:
            return;
     */
    /* JADX WARNING: Missing block: B:455:?, code skipped:
            r3 = new java.lang.StringBuilder();
            r3.append("Invalid new component state: ");
            r3.append(r11);
            android.util.Slog.e(r0, r3.toString());
     */
    /* JADX WARNING: Missing block: B:456:0x068f, code skipped:
            monitor-exit(r1);
     */
    /* JADX WARNING: Missing block: B:457:0x0690, code skipped:
            return;
     */
    /* JADX WARNING: Missing block: B:458:0x0691, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:459:0x0692, code skipped:
            r7 = r12;
            r6 = r43;
     */
    /* JADX WARNING: Missing block: B:460:0x0695, code skipped:
            monitor-exit(r1);
     */
    /* JADX WARNING: Missing block: B:461:0x0696, code skipped:
            throw r0;
     */
    /* JADX WARNING: Missing block: B:462:0x0697, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:463:0x0699, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:464:0x069a, code skipped:
            r6 = r12;
            r34 = r15;
            r15 = r7;
            r7 = r5;
     */
    /* JADX WARNING: Missing block: B:466:?, code skipped:
            monitor-exit(r2);
     */
    /* JADX WARNING: Missing block: B:467:0x06a0, code skipped:
            throw r0;
     */
    /* JADX WARNING: Missing block: B:468:0x06a1, code skipped:
            r0 = th;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void setEnabledSetting(String packageName, String className, int newState, int flags, int userId, String callingPackage) {
        StringBuilder stringBuilder;
        int callingUid;
        boolean sendNow;
        Throwable th;
        int i;
        int i2;
        StringBuilder stringBuilder2;
        PackageSetting componentName;
        File deletedPkg;
        File file;
        Package packageR;
        Package deletedPkg2;
        Throwable th2;
        Throwable th3;
        String str;
        Package packageR2;
        String str2 = packageName;
        String str3 = className;
        int i3 = newState;
        int i4 = flags;
        int i5 = userId;
        if (i3 == 0 || i3 == 1 || i3 == 2 || i3 == 3 || i3 == 4) {
            int permission;
            stringBuilder = new StringBuilder();
            stringBuilder.append("setEnabledSetting pkg:");
            stringBuilder.append(str2);
            stringBuilder.append(", className:");
            stringBuilder.append(str3);
            stringBuilder.append(", newState:");
            stringBuilder.append(i3);
            stringBuilder.append(", flags:");
            stringBuilder.append(i4);
            stringBuilder.append(", userId:");
            stringBuilder.append(i5);
            stringBuilder.append(", CallingPid:");
            stringBuilder.append(Binder.getCallingPid());
            stringBuilder.append(", CallingUid:");
            stringBuilder.append(Binder.getCallingUid());
            Flog.i(206, stringBuilder.toString());
            callingUid = Binder.getCallingUid();
            if (callingUid == 1000) {
                permission = 0;
            } else {
                permission = this.mContext.checkCallingOrSelfPermission("android.permission.CHANGE_COMPONENT_ENABLED_STATE");
            }
            int permission2 = permission;
            this.mPermissionManager.enforceCrossUserPermission(callingUid, i5, false, true, "set enabled");
            boolean allowedByPermission = permission2 == 0;
            sendNow = false;
            boolean isApp = str3 == null;
            boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
            String componentName2 = isApp ? str2 : str3;
            synchronized (this.mPackages) {
                try {
                    PackageSetting pkgSetting = (PackageSetting) this.mSettings.mPackages.get(str2);
                    if (pkgSetting == null) {
                        if (isCallerInstantApp) {
                            String stringBuilder3;
                            stringBuilder = new StringBuilder();
                            stringBuilder.append("Attempt to change component state; pid=");
                            stringBuilder.append(Binder.getCallingPid());
                            stringBuilder.append(", uid=");
                            stringBuilder.append(callingUid);
                            StringBuilder stringBuilder4;
                            if (str3 == null) {
                                stringBuilder4 = new StringBuilder();
                                stringBuilder4.append(", package=");
                                stringBuilder4.append(str2);
                                stringBuilder3 = stringBuilder4.toString();
                            } else {
                                stringBuilder4 = new StringBuilder();
                                stringBuilder4.append(", component=");
                                stringBuilder4.append(str2);
                                stringBuilder4.append(SliceAuthority.DELIMITER);
                                stringBuilder4.append(str3);
                                stringBuilder3 = stringBuilder4.toString();
                            }
                            stringBuilder.append(stringBuilder3);
                            throw new SecurityException(stringBuilder.toString());
                        } else if (str3 == null) {
                            try {
                                stringBuilder = new StringBuilder();
                                stringBuilder.append("Unknown package: ");
                                stringBuilder.append(str2);
                                throw new IllegalArgumentException(stringBuilder.toString());
                            } catch (Throwable th4) {
                                th = th4;
                                i = i4;
                                i2 = callingUid;
                                callingUid = componentName2;
                                while (true) {
                                    try {
                                        break;
                                    } catch (Throwable th5) {
                                        th = th5;
                                    }
                                }
                                throw th;
                            }
                        } else {
                            stringBuilder = new StringBuilder();
                            stringBuilder.append("Unknown component: ");
                            stringBuilder.append(str2);
                            stringBuilder.append(SliceAuthority.DELIMITER);
                            stringBuilder.append(str3);
                            throw new IllegalArgumentException(stringBuilder.toString());
                        }
                    }
                } catch (Throwable th6) {
                    th = th6;
                    i = i4;
                    i2 = callingUid;
                    while (true) {
                        break;
                    }
                    throw th;
                }
            }
        }
        stringBuilder2 = new StringBuilder();
        stringBuilder2.append("Invalid new component state: ");
        stringBuilder2.append(i3);
        throw new IllegalArgumentException(stringBuilder2.toString());
        return;
        ArrayMap arrayMap = r6;
        try {
            PackageSetting packageSetting;
            this.mPermissionManager.updatePermissions(componentName.packageName, componentName, true, this.mPackages.values(), this.mPermissionCallback);
            this.mSettings.writeLPr();
            if (freezer != null) {
                try {
                    $closeResource(null, freezer);
                } catch (PackageManagerException e) {
                    PackageManagerException e2 = e;
                    PackageManagerException e3 = e2;
                    try {
                        String str4 = TAG;
                        stringBuilder2 = new StringBuilder();
                        stringBuilder2.append("Failed to install compressed system package:");
                        componentName = pkgSetting;
                        try {
                            stringBuilder2.append(componentName.name);
                            Slog.w(str4, stringBuilder2.toString(), e3);
                            deletedPkg = codePath;
                        } catch (Throwable th7) {
                            th = th7;
                            packageSetting = componentName;
                            file = codePath;
                            packageR = deletedPkg;
                            throw th;
                        }
                    } catch (Throwable th8) {
                        th = th8;
                        file = codePath;
                        packageSetting = pkgSetting;
                        packageR = deletedPkg;
                        throw th;
                    }
                    try {
                        removeCodePathLI(deletedPkg);
                        Package deletedPkg3 = deletedPkg;
                        try {
                            PackageFreezer freezer = freezePackage(deletedPkg3.packageName, "setEnabledSetting");
                            PackageFreezer freezer2;
                            try {
                                synchronized (this.mPackages) {
                                }
                                PackageFreezer freezer3 = freezer;
                                deletedPkg2 = deletedPkg3;
                                file = deletedPkg;
                                packageSetting = componentName;
                                try {
                                    installPackageFromSystemLIF(deletedPkg3.codePath, false, null, null, null, 1);
                                    freezer2 = freezer3;
                                    if (freezer2 != null) {
                                    }
                                } catch (Throwable th9) {
                                    th = th9;
                                    freezer2 = freezer3;
                                    packageR = deletedPkg2;
                                    th3 = null;
                                    if (freezer2 != null) {
                                    }
                                    throw th;
                                }
                            } catch (Throwable th10) {
                                th = th10;
                                freezer2 = freezer;
                                packageR = deletedPkg3;
                                file = deletedPkg;
                                packageSetting = componentName;
                                th3 = null;
                                if (freezer2 != null) {
                                    try {
                                        $closeResource(th3, freezer2);
                                    } catch (PackageManagerException e4) {
                                        e2 = e4;
                                        try {
                                            str = TAG;
                                            stringBuilder = new StringBuilder();
                                            stringBuilder.append("Failed to restore system package:");
                                            stringBuilder.append(packageR.packageName);
                                            Slog.w(str, stringBuilder.toString(), e2);
                                            synchronized (this.mPackages) {
                                                try {
                                                    this.mSettings.disableSystemPackageLPw(packageR.packageName, true);
                                                    this.mSettings.writeLPr();
                                                } catch (Throwable th11) {
                                                    while (true) {
                                                        th = th11;
                                                    }
                                                    throw th;
                                                }
                                            }
                                            return;
                                        } catch (Throwable th12) {
                                            th = th12;
                                            synchronized (this.mPackages) {
                                                try {
                                                    this.mSettings.disableSystemPackageLPw(packageR.packageName, true);
                                                    this.mSettings.writeLPr();
                                                } catch (Throwable th13) {
                                                    th = th13;
                                                }
                                            }
                                            throw th;
                                        }
                                    }
                                }
                                throw th;
                            }
                            try {
                                synchronized (this.mPackages) {
                                }
                            } catch (Throwable th14) {
                                th = th14;
                                packageR = deletedPkg2;
                                throw th;
                            }
                        } catch (PackageManagerException e5) {
                            e2 = e5;
                            packageR = deletedPkg3;
                            file = deletedPkg;
                            packageSetting = componentName;
                            str = TAG;
                            stringBuilder = new StringBuilder();
                            stringBuilder.append("Failed to restore system package:");
                            stringBuilder.append(packageR.packageName);
                            Slog.w(str, stringBuilder.toString(), e2);
                            synchronized (this.mPackages) {
                            }
                            return;
                        } catch (Throwable th15) {
                            th = th15;
                            packageR = deletedPkg3;
                            file = deletedPkg;
                            packageSetting = componentName;
                            synchronized (this.mPackages) {
                            }
                            throw th;
                        }
                    } catch (Throwable th16) {
                        th = th16;
                        file = deletedPkg;
                        packageSetting = componentName;
                        packageR = deletedPkg;
                        throw th;
                    }
                }
            }
            Package pkg = componentName;
            try {
                clearAppDataLIF(pkg, -1, UsbTerminalTypes.TERMINAL_IN_PERSONAL_MIC);
                this.mDexManager.notifyPackageUpdated(pkg.packageName, pkg.baseCodePath, pkg.splitCodePaths);
                packageSetting = pkgSetting;
                packageR = deletedPkg;
                Package pkg2 = (i3 == 0 || i3 == 1) ? null : callingPackage;
                synchronized (this.mPackages) {
                    packageSetting.setEnabled(i3, i5, pkg2);
                }
                synchronized (this.mPackages) {
                    try {
                        scheduleWritePackageRestrictionsLocked(i5);
                        updateSequenceNumberLP(packageSetting, new int[]{i5});
                        long callingId = Binder.clearCallingIdentity();
                        try {
                            updateInstantAppInstallerLocked(packageName);
                            Binder.restoreCallingIdentity(callingId);
                            ArrayList<String> components = this.mPendingBroadcasts.get(i5, str2);
                            boolean newPackage = components == null;
                            if (newPackage) {
                                try {
                                    components = new ArrayList();
                                } catch (Throwable th17) {
                                    th = th17;
                                    packageR2 = pkg2;
                                    componentName = packageSetting;
                                    i = flags;
                                    throw th;
                                }
                            }
                            if (!components.contains(callingUid)) {
                                components.add(callingUid);
                            }
                            componentName = packageSetting;
                            i = flags;
                            boolean z;
                            if ((i & 1) == null) {
                                sendNow = true;
                                try {
                                    this.mPendingBroadcasts.remove(i5, str2);
                                    packageR2 = pkg2;
                                    z = true;
                                } catch (Throwable th18) {
                                    th = th18;
                                    packageR2 = pkg2;
                                    throw th;
                                }
                            }
                            if (newPackage) {
                                this.mPendingBroadcasts.put(i5, str2, components);
                            }
                            try {
                                z = true;
                                if (this.mHandler.hasMessages(1)) {
                                    packageR2 = pkg2;
                                } else {
                                    packageR2 = pkg2;
                                    this.mHandler.sendEmptyMessageDelayed(1, true);
                                }
                            } catch (Throwable th19) {
                                th = th19;
                                packageR2 = pkg2;
                                throw th;
                            }
                        } catch (Throwable th20) {
                            th = th20;
                            throw th;
                        }
                    } catch (Throwable th21) {
                        th = th21;
                        packageR2 = pkg2;
                        componentName = packageSetting;
                        i = flags;
                        throw th;
                    }
                }
            } catch (Throwable th22) {
                th = th22;
                file = codePath;
                packageSetting = pkgSetting;
                packageR = deletedPkg;
                throw th;
            }
        } catch (Throwable th23) {
            th = th23;
            throw th;
        }
    }

    public void flushPackageRestrictionsAsUser(int userId) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && sUserManager.exists(userId)) {
            this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "flushPackageRestrictions");
            synchronized (this.mPackages) {
                this.mSettings.writePackageRestrictionsLPr(userId);
                this.mDirtyUsers.remove(Integer.valueOf(userId));
                if (this.mDirtyUsers.isEmpty()) {
                    this.mHandler.removeMessages(14);
                }
            }
        }
    }

    protected void sendPackageChangedBroadcast(String packageName, boolean killFlag, ArrayList<String> componentNames, int packageUid) {
        String str = packageName;
        ArrayList<String> arrayList = componentNames;
        if (DEBUG_INSTALL) {
            String str2 = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Sending package changed: package=");
            stringBuilder.append(str);
            stringBuilder.append(" components=");
            stringBuilder.append(arrayList);
            Log.v(str2, stringBuilder.toString());
        }
        Bundle extras = new Bundle(4);
        extras.putString("android.intent.extra.changed_component_name", (String) arrayList.get(0));
        String[] nameList = new String[componentNames.size()];
        arrayList.toArray(nameList);
        extras.putStringArray("android.intent.extra.changed_component_name_list", nameList);
        extras.putBoolean("android.intent.extra.DONT_KILL_APP", killFlag);
        extras.putInt("android.intent.extra.UID", packageUid);
        int flags = !arrayList.contains(str) ? 1073741824 : 0;
        boolean isInstantApp = isInstantApp(str, UserHandle.getUserId(packageUid));
        sendPackageBroadcast("android.intent.action.PACKAGE_CHANGED", str, extras, flags, null, null, isInstantApp ? EMPTY_INT_ARRAY : new int[]{UserHandle.getUserId(packageUid)}, isInstantApp ? new int[]{UserHandle.getUserId(packageUid)} : EMPTY_INT_ARRAY);
    }

    /* JADX WARNING: Missing block: B:27:0x005d, code skipped:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void setPackageStoppedState(String packageName, boolean stopped, int userId) {
        Throwable th;
        int i;
        int i2 = userId;
        if (sUserManager.exists(i2)) {
            int callingUid = Binder.getCallingUid();
            if (getInstantAppPackageName(callingUid) == null) {
                boolean allowedByPermission = this.mContext.checkCallingOrSelfPermission("android.permission.CHANGE_COMPONENT_ENABLED_STATE") == 0;
                this.mPermissionManager.enforceCrossUserPermission(callingUid, i2, true, true, "stop package");
                synchronized (this.mPackages) {
                    String str;
                    try {
                        str = packageName;
                        try {
                            if (filterAppAccessLPr((PackageSetting) this.mSettings.mPackages.get(str), callingUid, i2)) {
                            } else {
                                if (this.mSettings.setPackageStoppedStateLPw(this, str, stopped, allowedByPermission, callingUid, i2)) {
                                    scheduleWritePackageRestrictionsLocked(i2);
                                }
                            }
                        } catch (Throwable th2) {
                            th = th2;
                            throw th;
                        }
                    } catch (Throwable th3) {
                        th = th3;
                        str = packageName;
                        i = callingUid;
                        throw th;
                    }
                }
            }
        }
    }

    public String getInstallerPackageName(String packageName) {
        int callingUid = Binder.getCallingUid();
        synchronized (this.mPackages) {
            if (filterAppAccessLPr((PackageSetting) this.mSettings.mPackages.get(packageName), callingUid, UserHandle.getUserId(callingUid))) {
                return null;
            }
            String installerPackageNameLPr = this.mSettings.getInstallerPackageNameLPr(packageName);
            return installerPackageNameLPr;
        }
    }

    public boolean isOrphaned(String packageName) {
        boolean isOrphaned;
        synchronized (this.mPackages) {
            isOrphaned = this.mSettings.isOrphaned(packageName);
        }
        return isOrphaned;
    }

    public int getApplicationEnabledSetting(String packageName, int userId) {
        if (!sUserManager.exists(userId)) {
            return 2;
        }
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get enabled");
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.getPackageLPr(packageName), callingUid, userId)) {
                return 2;
            }
            int applicationEnabledSettingLPr = this.mSettings.getApplicationEnabledSettingLPr(packageName, userId);
            return applicationEnabledSettingLPr;
        }
    }

    public int getComponentEnabledSetting(ComponentName component, int userId) {
        if (!sUserManager.exists(userId)) {
            return 2;
        }
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "getComponentEnabled");
        synchronized (this.mPackages) {
            if (component == null) {
                try {
                    return 2;
                } catch (Throwable th) {
                }
            } else {
                if (filterAppAccessLPr(this.mSettings.getPackageLPr(component.getPackageName()), callingUid, component, 0, userId)) {
                    return 2;
                }
                int componentEnabledSettingLPr = this.mSettings.getComponentEnabledSettingLPr(component, userId);
                return componentEnabledSettingLPr;
            }
        }
    }

    public void enterSafeMode() {
        enforceSystemOrRoot("Only the system can request entering safe mode");
        if (!this.mSystemReady) {
            this.mSafeMode = true;
        }
    }

    /* JADX WARNING: Missing block: B:39:0x0152, code skipped:
            sUserManager.systemReady();
            android.hwtheme.HwThemeManager.applyDefaultHwTheme(true, r15.mContext, 0);
            r0 = r10.length;
            r4 = 0;
     */
    /* JADX WARNING: Missing block: B:40:0x015e, code skipped:
            if (r4 >= r0) goto L_0x016a;
     */
    /* JADX WARNING: Missing block: B:41:0x0160, code skipped:
            r15.mDefaultPermissionPolicy.grantDefaultPermissions(r10[r4]);
            r4 = r4 + 1;
     */
    /* JADX WARNING: Missing block: B:43:0x016c, code skipped:
            if (r10 != EMPTY_INT_ARRAY) goto L_0x0173;
     */
    /* JADX WARNING: Missing block: B:44:0x016e, code skipped:
            r15.mDefaultPermissionPolicy.scheduleReadDefaultPermissionExceptions();
     */
    /* JADX WARNING: Missing block: B:45:0x0173, code skipped:
            r0 = com.android.server.pm.UserManagerService.getInstance().getUserIds();
            r4 = r0.length;
            r6 = 0;
     */
    /* JADX WARNING: Missing block: B:46:0x017d, code skipped:
            if (r6 >= r4) goto L_0x0189;
     */
    /* JADX WARNING: Missing block: B:47:0x017f, code skipped:
            r15.mDefaultPermissionPolicy.grantCustDefaultPermissions(r0[r6]);
            r6 = r6 + 1;
     */
    /* JADX WARNING: Missing block: B:48:0x0189, code skipped:
            r0 = r15.mPackages;
     */
    /* JADX WARNING: Missing block: B:49:0x018b, code skipped:
            monitor-enter(r0);
     */
    /* JADX WARNING: Missing block: B:51:?, code skipped:
            r15.mPermissionManager.updateAllPermissions(android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL, false, r15.mPackages.values(), r15.mPermissionCallback);
     */
    /* JADX WARNING: Missing block: B:52:0x019b, code skipped:
            monitor-exit(r0);
     */
    /* JADX WARNING: Missing block: B:54:0x019e, code skipped:
            if (r15.mPostSystemReadyMessages == null) goto L_0x01b9;
     */
    /* JADX WARNING: Missing block: B:55:0x01a0, code skipped:
            r0 = r15.mPostSystemReadyMessages.iterator();
     */
    /* JADX WARNING: Missing block: B:57:0x01aa, code skipped:
            if (r0.hasNext() == false) goto L_0x01b6;
     */
    /* JADX WARNING: Missing block: B:58:0x01ac, code skipped:
            ((android.os.Message) r0.next()).sendToTarget();
     */
    /* JADX WARNING: Missing block: B:59:0x01b6, code skipped:
            r15.mPostSystemReadyMessages = null;
     */
    /* JADX WARNING: Missing block: B:60:0x01b9, code skipped:
            ((android.os.storage.StorageManager) r15.mContext.getSystemService(android.os.storage.StorageManager.class)).registerListener(r15.mStorageListener);
            r15.mInstallerService.systemReady();
            r15.mDexManager.systemReady();
            r15.mPackageDexOptimizer.systemReady();
            r15.mHwPMSEx.systemReady();
            ((android.os.storage.StorageManagerInternal) com.android.server.LocalServices.getService(android.os.storage.StorageManagerInternal.class)).addExternalStoragePolicy(new com.android.server.pm.PackageManagerService.AnonymousClass26(r15));
            sUserManager.reconcileUsers(android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL);
            reconcileApps(android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL);
            r15.mPermissionManager.systemReady();
     */
    /* JADX WARNING: Missing block: B:61:0x01ff, code skipped:
            if (r15.mInstantAppResolverConnection == null) goto L_?;
     */
    /* JADX WARNING: Missing block: B:62:0x0201, code skipped:
            r15.mContext.registerReceiver(new com.android.server.pm.PackageManagerService.AnonymousClass27(r15), new android.content.IntentFilter("android.intent.action.BOOT_COMPLETED"));
     */
    /* JADX WARNING: Missing block: B:87:?, code skipped:
            return;
     */
    /* JADX WARNING: Missing block: B:88:?, code skipped:
            return;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void systemReady() {
        Throwable th;
        enforceSystemOrRoot("Only the system can claim the system is ready");
        this.mSystemReady = true;
        final ContentResolver resolver = this.mContext.getContentResolver();
        ContentObserver co = new ContentObserver(this.mHandler) {
            public void onChange(boolean selfChange) {
                PackageManagerService packageManagerService = PackageManagerService.this;
                boolean z = true;
                if (!(Global.getInt(resolver, "enable_ephemeral_feature", 1) == 0 || Secure.getInt(resolver, "instant_apps_enabled", 1) == 0)) {
                    z = false;
                }
                packageManagerService.mWebInstantAppsDisabled = z;
            }
        };
        this.mContext.getContentResolver().registerContentObserver(Global.getUriFor("enable_ephemeral_feature"), false, co, 0);
        this.mContext.getContentResolver().registerContentObserver(Secure.getUriFor("instant_apps_enabled"), false, co, 0);
        co.onChange(true);
        CarrierAppUtils.disableCarrierAppsUntilPrivileged(this.mContext.getOpPackageName(), this, this.mContext.getContentResolver(), 0);
        boolean compatibilityModeEnabled = Global.getInt(this.mContext.getContentResolver(), "compatibility_mode", 1) == 1;
        PackageParser.setCompatibilityModeEnabled(compatibilityModeEnabled);
        if (DEBUG_SETTINGS) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("compatibility mode:");
            stringBuilder.append(compatibilityModeEnabled);
            Log.d(str, stringBuilder.toString());
        }
        int[] grantPermissionsUserIds = EMPTY_INT_ARRAY;
        synchronized (this.mPackages) {
            try {
                String str2;
                StringBuilder stringBuilder2;
                ArrayList<PreferredActivity> removed = new ArrayList();
                for (int i = 0; i < this.mSettings.mPreferredActivities.size(); i++) {
                    PreferredActivity pa;
                    PreferredIntentResolver pir = (PreferredIntentResolver) this.mSettings.mPreferredActivities.valueAt(i);
                    removed.clear();
                    for (PreferredActivity pa2 : pir.filterSet()) {
                        if (this.mActivities.mActivities.get(pa2.mPref.mComponent) == null) {
                            removed.add(pa2);
                        }
                    }
                    if (removed.size() > 0) {
                        for (int r = 0; r < removed.size(); r++) {
                            pa2 = (PreferredActivity) removed.get(r);
                            str2 = TAG;
                            stringBuilder2 = new StringBuilder();
                            stringBuilder2.append("Removing dangling preferred activity: ");
                            stringBuilder2.append(pa2.mPref.mComponent);
                            Slog.w(str2, stringBuilder2.toString());
                            pir.removeFilter(pa2);
                        }
                        this.mSettings.writePackageRestrictionsLPr(this.mSettings.mPreferredActivities.keyAt(i));
                    }
                }
                int[] userIds = UserManagerService.getInstance().getUserIds();
                int length = userIds.length;
                int[] grantPermissionsUserIds2 = grantPermissionsUserIds;
                int grantPermissionsUserIds3 = 0;
                while (grantPermissionsUserIds3 < length) {
                    try {
                        int userId = userIds[grantPermissionsUserIds3];
                        str2 = TAG;
                        stringBuilder2 = new StringBuilder();
                        stringBuilder2.append("TO DO, pms system ready grant default permission for user ");
                        stringBuilder2.append(userId);
                        Slog.i(str2, stringBuilder2.toString());
                        if (!this.mSettings.areDefaultRuntimePermissionsGrantedLPr(userId)) {
                            str2 = TAG;
                            stringBuilder2 = new StringBuilder();
                            stringBuilder2.append("add user ");
                            stringBuilder2.append(userId);
                            Slog.i(str2, stringBuilder2.toString());
                            grantPermissionsUserIds2 = ArrayUtils.appendInt(grantPermissionsUserIds2, userId);
                        }
                        grantPermissionsUserIds3++;
                    } catch (Throwable th2) {
                        th = th2;
                        grantPermissionsUserIds = grantPermissionsUserIds2;
                        throw th;
                    }
                }
            } catch (Throwable th3) {
                th = th3;
                throw th;
            }
        }
    }

    public void waitForAppDataPrepared() {
        if (this.mPrepareAppDataFuture != null) {
            ConcurrentUtils.waitForFutureNoInterrupt(this.mPrepareAppDataFuture, "wait for prepareAppData");
            this.mPrepareAppDataFuture = null;
        }
    }

    public boolean isSafeMode() {
        return this.mSafeMode;
    }

    public boolean hasSystemUidErrors() {
        return this.mHasSystemUidErrors;
    }

    static String arrayToString(int[] array) {
        StringBuffer buf = new StringBuffer(128);
        buf.append('[');
        if (array != null) {
            for (int i = 0; i < array.length; i++) {
                if (i > 0) {
                    buf.append(", ");
                }
                buf.append(array[i]);
            }
        }
        buf.append(']');
        return buf.toString();
    }

    public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err, String[] args, ShellCallback callback, ResultReceiver resultReceiver) {
        new PackageManagerShellCommand(this).exec(this, in, out, err, args, callback, resultReceiver);
    }

    /* JADX WARNING: Removed duplicated region for block: B:585:0x0c9b A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:589:0x0cbe A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:588:0x0cb8 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:600:0x0ceb A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:604:0x0d0e A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:603:0x0d08 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:615:0x0d3c A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:619:0x0d50 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:628:0x0d87 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:635:0x0d9d A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:645:0x0dca A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:638:0x0da5 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:657:0x0ded  */
    /* JADX WARNING: Removed duplicated region for block: B:665:0x0e0e  */
    /* JADX WARNING: Removed duplicated region for block: B:487:0x0aca A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:476:0x0ab1  */
    /* JADX WARNING: Removed duplicated region for block: B:494:0x0aed A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:508:0x0b3c A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:543:0x0bd6  */
    /* JADX WARNING: Removed duplicated region for block: B:534:0x0bbd A:{SYNTHETIC, Splitter:B:534:0x0bbd} */
    /* JADX WARNING: Removed duplicated region for block: B:548:0x0be2 A:{SYNTHETIC, Splitter:B:548:0x0be2} */
    /* JADX WARNING: Removed duplicated region for block: B:554:0x0bf5 A:{SYNTHETIC, Splitter:B:554:0x0bf5} */
    /* JADX WARNING: Removed duplicated region for block: B:569:0x0c73  */
    /* JADX WARNING: Removed duplicated region for block: B:585:0x0c9b A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:588:0x0cb8 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:589:0x0cbe A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:600:0x0ceb A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:603:0x0d08 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:604:0x0d0e A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:615:0x0d3c A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:619:0x0d50 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:628:0x0d87 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:635:0x0d9d A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:638:0x0da5 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:645:0x0dca A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:657:0x0ded  */
    /* JADX WARNING: Removed duplicated region for block: B:665:0x0e0e  */
    /* JADX WARNING: Removed duplicated region for block: B:359:0x0770 A:{Catch:{ all -> 0x0748, all -> 0x0789 }} */
    /* JADX WARNING: Removed duplicated region for block: B:358:0x076d A:{Catch:{ all -> 0x0748, all -> 0x0789 }} */
    /* JADX WARNING: Removed duplicated region for block: B:362:0x0784 A:{Catch:{ all -> 0x0748, all -> 0x0789 }} */
    /* JADX WARNING: Removed duplicated region for block: B:372:0x07a7 A:{Catch:{ all -> 0x0748, all -> 0x0789 }} */
    /* JADX WARNING: Removed duplicated region for block: B:371:0x07a4 A:{Catch:{ all -> 0x0748, all -> 0x0789 }} */
    /* JADX WARNING: Removed duplicated region for block: B:375:0x07bb A:{Catch:{ all -> 0x0748, all -> 0x0789 }} */
    /* JADX WARNING: Removed duplicated region for block: B:386:0x07ed A:{Catch:{ all -> 0x0748, all -> 0x0789 }} */
    /* JADX WARNING: Removed duplicated region for block: B:377:0x07c1 A:{Catch:{ all -> 0x0748, all -> 0x0789 }} */
    /* JADX WARNING: Removed duplicated region for block: B:703:0x086b A:{SYNTHETIC, EDGE_INSN: B:703:0x086b->B:401:0x086b ?: BREAK  , EDGE_INSN: B:703:0x086b->B:401:0x086b ?: BREAK  } */
    /* JADX WARNING: Removed duplicated region for block: B:393:0x0805 A:{Catch:{ all -> 0x0748, all -> 0x0789 }} */
    /* JADX WARNING: Removed duplicated region for block: B:430:0x0901  */
    /* JADX WARNING: Removed duplicated region for block: B:476:0x0ab1  */
    /* JADX WARNING: Removed duplicated region for block: B:487:0x0aca A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:494:0x0aed A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:508:0x0b3c A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:534:0x0bbd A:{SYNTHETIC, Splitter:B:534:0x0bbd} */
    /* JADX WARNING: Removed duplicated region for block: B:543:0x0bd6  */
    /* JADX WARNING: Removed duplicated region for block: B:548:0x0be2 A:{SYNTHETIC, Splitter:B:548:0x0be2} */
    /* JADX WARNING: Removed duplicated region for block: B:554:0x0bf5 A:{SYNTHETIC, Splitter:B:554:0x0bf5} */
    /* JADX WARNING: Removed duplicated region for block: B:569:0x0c73  */
    /* JADX WARNING: Removed duplicated region for block: B:585:0x0c9b A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:589:0x0cbe A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:588:0x0cb8 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:600:0x0ceb A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:604:0x0d0e A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:603:0x0d08 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:615:0x0d3c A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:619:0x0d50 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:628:0x0d87 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:635:0x0d9d A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:645:0x0dca A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:638:0x0da5 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:657:0x0ded  */
    /* JADX WARNING: Removed duplicated region for block: B:665:0x0e0e  */
    /* JADX WARNING: Removed duplicated region for block: B:217:0x04e3  */
    /* JADX WARNING: Removed duplicated region for block: B:220:0x04ec A:{SYNTHETIC, Splitter:B:220:0x04ec} */
    /* JADX WARNING: Removed duplicated region for block: B:217:0x04e3  */
    /* JADX WARNING: Removed duplicated region for block: B:220:0x04ec A:{SYNTHETIC, Splitter:B:220:0x04ec} */
    /* JADX WARNING: Removed duplicated region for block: B:217:0x04e3  */
    /* JADX WARNING: Removed duplicated region for block: B:220:0x04ec A:{SYNTHETIC, Splitter:B:220:0x04ec} */
    /* JADX WARNING: Removed duplicated region for block: B:430:0x0901  */
    /* JADX WARNING: Removed duplicated region for block: B:487:0x0aca A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:476:0x0ab1  */
    /* JADX WARNING: Removed duplicated region for block: B:494:0x0aed A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:508:0x0b3c A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:543:0x0bd6  */
    /* JADX WARNING: Removed duplicated region for block: B:534:0x0bbd A:{SYNTHETIC, Splitter:B:534:0x0bbd} */
    /* JADX WARNING: Removed duplicated region for block: B:548:0x0be2 A:{SYNTHETIC, Splitter:B:548:0x0be2} */
    /* JADX WARNING: Removed duplicated region for block: B:554:0x0bf5 A:{SYNTHETIC, Splitter:B:554:0x0bf5} */
    /* JADX WARNING: Removed duplicated region for block: B:569:0x0c73  */
    /* JADX WARNING: Removed duplicated region for block: B:585:0x0c9b A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:588:0x0cb8 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:589:0x0cbe A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:600:0x0ceb A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:603:0x0d08 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:604:0x0d0e A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:615:0x0d3c A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:619:0x0d50 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:628:0x0d87 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:635:0x0d9d A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:638:0x0da5 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:645:0x0dca A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:657:0x0ded  */
    /* JADX WARNING: Removed duplicated region for block: B:665:0x0e0e  */
    /* JADX WARNING: Removed duplicated region for block: B:430:0x0901  */
    /* JADX WARNING: Removed duplicated region for block: B:476:0x0ab1  */
    /* JADX WARNING: Removed duplicated region for block: B:487:0x0aca A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:494:0x0aed A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:508:0x0b3c A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:534:0x0bbd A:{SYNTHETIC, Splitter:B:534:0x0bbd} */
    /* JADX WARNING: Removed duplicated region for block: B:543:0x0bd6  */
    /* JADX WARNING: Removed duplicated region for block: B:548:0x0be2 A:{SYNTHETIC, Splitter:B:548:0x0be2} */
    /* JADX WARNING: Removed duplicated region for block: B:554:0x0bf5 A:{SYNTHETIC, Splitter:B:554:0x0bf5} */
    /* JADX WARNING: Removed duplicated region for block: B:569:0x0c73  */
    /* JADX WARNING: Removed duplicated region for block: B:585:0x0c9b A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:589:0x0cbe A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:588:0x0cb8 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:600:0x0ceb A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:604:0x0d0e A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:603:0x0d08 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:615:0x0d3c A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:619:0x0d50 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:628:0x0d87 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:635:0x0d9d A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:645:0x0dca A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:638:0x0da5 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:657:0x0ded  */
    /* JADX WARNING: Removed duplicated region for block: B:665:0x0e0e  */
    /* JADX WARNING: Removed duplicated region for block: B:430:0x0901  */
    /* JADX WARNING: Removed duplicated region for block: B:487:0x0aca A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:476:0x0ab1  */
    /* JADX WARNING: Removed duplicated region for block: B:494:0x0aed A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:508:0x0b3c A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:543:0x0bd6  */
    /* JADX WARNING: Removed duplicated region for block: B:534:0x0bbd A:{SYNTHETIC, Splitter:B:534:0x0bbd} */
    /* JADX WARNING: Removed duplicated region for block: B:548:0x0be2 A:{SYNTHETIC, Splitter:B:548:0x0be2} */
    /* JADX WARNING: Removed duplicated region for block: B:554:0x0bf5 A:{SYNTHETIC, Splitter:B:554:0x0bf5} */
    /* JADX WARNING: Removed duplicated region for block: B:569:0x0c73  */
    /* JADX WARNING: Removed duplicated region for block: B:585:0x0c9b A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:588:0x0cb8 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:589:0x0cbe A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:600:0x0ceb A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:603:0x0d08 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:604:0x0d0e A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:615:0x0d3c A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:619:0x0d50 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:628:0x0d87 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:635:0x0d9d A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:638:0x0da5 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:645:0x0dca A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:657:0x0ded  */
    /* JADX WARNING: Removed duplicated region for block: B:665:0x0e0e  */
    /* JADX WARNING: Removed duplicated region for block: B:430:0x0901  */
    /* JADX WARNING: Removed duplicated region for block: B:476:0x0ab1  */
    /* JADX WARNING: Removed duplicated region for block: B:487:0x0aca A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:494:0x0aed A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:508:0x0b3c A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:534:0x0bbd A:{SYNTHETIC, Splitter:B:534:0x0bbd} */
    /* JADX WARNING: Removed duplicated region for block: B:543:0x0bd6  */
    /* JADX WARNING: Removed duplicated region for block: B:548:0x0be2 A:{SYNTHETIC, Splitter:B:548:0x0be2} */
    /* JADX WARNING: Removed duplicated region for block: B:554:0x0bf5 A:{SYNTHETIC, Splitter:B:554:0x0bf5} */
    /* JADX WARNING: Removed duplicated region for block: B:569:0x0c73  */
    /* JADX WARNING: Removed duplicated region for block: B:585:0x0c9b A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:589:0x0cbe A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:588:0x0cb8 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:600:0x0ceb A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:604:0x0d0e A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:603:0x0d08 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:615:0x0d3c A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:619:0x0d50 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:628:0x0d87 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:635:0x0d9d A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:645:0x0dca A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:638:0x0da5 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:657:0x0ded  */
    /* JADX WARNING: Removed duplicated region for block: B:665:0x0e0e  */
    /* JADX WARNING: Removed duplicated region for block: B:430:0x0901  */
    /* JADX WARNING: Removed duplicated region for block: B:487:0x0aca A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:476:0x0ab1  */
    /* JADX WARNING: Removed duplicated region for block: B:494:0x0aed A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:508:0x0b3c A:{Catch:{ all -> 0x0ac4, all -> 0x0ba0 }} */
    /* JADX WARNING: Removed duplicated region for block: B:543:0x0bd6  */
    /* JADX WARNING: Removed duplicated region for block: B:534:0x0bbd A:{SYNTHETIC, Splitter:B:534:0x0bbd} */
    /* JADX WARNING: Removed duplicated region for block: B:548:0x0be2 A:{SYNTHETIC, Splitter:B:548:0x0be2} */
    /* JADX WARNING: Removed duplicated region for block: B:554:0x0bf5 A:{SYNTHETIC, Splitter:B:554:0x0bf5} */
    /* JADX WARNING: Removed duplicated region for block: B:569:0x0c73  */
    /* JADX WARNING: Removed duplicated region for block: B:585:0x0c9b A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:588:0x0cb8 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:589:0x0cbe A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:600:0x0ceb A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:603:0x0d08 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:604:0x0d0e A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:615:0x0d3c A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:619:0x0d50 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:628:0x0d87 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:635:0x0d9d A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:638:0x0da5 A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:645:0x0dca A:{Catch:{ all -> 0x0e2e }} */
    /* JADX WARNING: Removed duplicated region for block: B:657:0x0ded  */
    /* JADX WARNING: Removed duplicated region for block: B:665:0x0e0e  */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
        String packageName;
        ArraySet<String> permissionNames;
        ArrayMap arrayMap;
        Throwable th;
        FileDescriptor fileDescriptor;
        ArraySet<String> permissionNames2;
        IllegalArgumentException e;
        IllegalStateException e2;
        StringBuilder stringBuilder;
        String packageName2;
        IndentingPrintWriter ipw;
        Iterator<ServiceIntentInfo> filterIterator;
        IOException e3;
        Object obj;
        PrintWriter printWriter = pw;
        String[] strArr = args;
        if (DumpUtils.checkDumpAndUsageStatsPermission(this.mContext, TAG, printWriter)) {
            String opt;
            boolean fullPreferred;
            String str = TAG;
            StringBuilder stringBuilder2 = new StringBuilder();
            stringBuilder2.append("Start dump, calling from : pid=");
            stringBuilder2.append(Binder.getCallingPid());
            stringBuilder2.append(", uid=");
            stringBuilder2.append(Binder.getCallingUid());
            Log.i(str, stringBuilder2.toString());
            DumpState dumpState = new DumpState();
            boolean checkin = false;
            int opti = 0;
            while (opti < strArr.length) {
                opt = strArr[opti];
                if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
                    break;
                }
                opti++;
                if (!"-a".equals(opt)) {
                    if ("-h".equals(opt)) {
                        printWriter.println("Package manager dump options:");
                        printWriter.println("  [-h] [-f] [--checkin] [cmd] ...");
                        printWriter.println("    --checkin: dump for a checkin");
                        printWriter.println("    -f: print details of intent filters");
                        printWriter.println("    -h: print this help");
                        printWriter.println("  cmd may be one of:");
                        printWriter.println("    l[ibraries]: list known shared libraries");
                        printWriter.println("    f[eatures]: list device features");
                        printWriter.println("    k[eysets]: print known keysets");
                        printWriter.println("    r[esolvers] [activity|service|receiver|content]: dump intent resolvers");
                        printWriter.println("    perm[issions]: dump permissions");
                        printWriter.println("    permission [name ...]: dump declaration and use of given permission");
                        printWriter.println("    pref[erred]: print preferred package settings");
                        printWriter.println("    preferred-xml [--full]: print preferred package settings as xml");
                        printWriter.println("    prov[iders]: dump content providers");
                        printWriter.println("    p[ackages]: dump installed packages");
                        printWriter.println("    s[hared-users]: dump shared user IDs");
                        printWriter.println("    m[essages]: print collected runtime messages");
                        printWriter.println("    h[andle]: dump message list");
                        printWriter.println("    v[erifiers]: print package verifier info");
                        printWriter.println("    d[omain-preferred-apps]: print domains preferred apps");
                        printWriter.println("    i[ntent-filter-verifiers]|ifv: print intent filter verifier info");
                        printWriter.println("    version: print database version info");
                        printWriter.println("    write: write current settings now");
                        printWriter.println("    installs: details about install sessions");
                        printWriter.println("    check-permission <permission> <package> [<user>]: does pkg hold perm?");
                        printWriter.println("    dexopt: dump dexopt state");
                        printWriter.println("    compiler-stats: dump compiler statistics");
                        printWriter.println("    service-permissions: dump permissions required by services");
                        printWriter.println("    <package.name>: info about given package");
                        return;
                    } else if ("--checkin".equals(opt)) {
                        checkin = true;
                    } else if ("-f".equals(opt)) {
                        dumpState.setOptionEnabled(1);
                    } else if (PriorityDump.PROTO_ARG.equals(opt)) {
                        dumpProto(fd);
                        return;
                    } else {
                        StringBuilder stringBuilder3 = new StringBuilder();
                        stringBuilder3.append("Unknown argument: ");
                        stringBuilder3.append(opt);
                        stringBuilder3.append("; use -h for help");
                        printWriter.println(stringBuilder3.toString());
                    }
                }
            }
            int i;
            if (opti < strArr.length) {
                opt = strArr[opti];
                int opti2 = opti + 1;
                StringBuilder stringBuilder4;
                if (PLATFORM_PACKAGE_NAME.equals(opt) || opt.contains(".")) {
                    i = 2097152;
                    opti = opt;
                    dumpState.setOptionEnabled(1);
                    packageName = opti;
                } else if (!"check-permission".equals(opt)) {
                    StringBuilder stringBuilder5;
                    int i2;
                    if ("l".equals(opt) || "libraries".equals(opt)) {
                        i = 2097152;
                        dumpState.setDump(1);
                    } else if ("f".equals(opt) || "features".equals(opt)) {
                        i = 2097152;
                        dumpState.setDump(2);
                    } else if ("r".equals(opt) || "resolvers".equals(opt)) {
                        i = 2097152;
                        if (opti2 >= strArr.length) {
                            dumpState.setDump(60);
                        } else {
                            opti = opti2;
                            while (opti < strArr.length) {
                                fullPreferred = strArr[opti];
                                if ("a".equals(fullPreferred) || "activity".equals(fullPreferred)) {
                                    dumpState.setDump(4);
                                } else if ("s".equals(fullPreferred) || "service".equals(fullPreferred)) {
                                    dumpState.setDump(8);
                                } else if ("r".equals(fullPreferred) || HwBroadcastRadarUtil.KEY_RECEIVER.equals(fullPreferred)) {
                                    dumpState.setDump(16);
                                } else if ("c".equals(fullPreferred) || "content".equals(fullPreferred)) {
                                    dumpState.setDump(32);
                                } else {
                                    stringBuilder5 = new StringBuilder();
                                    stringBuilder5.append("Error: unknown resolver table type: ");
                                    stringBuilder5.append(fullPreferred);
                                    printWriter.println(stringBuilder5.toString());
                                    return;
                                }
                                opti++;
                            }
                        }
                    } else if (TAG_PERMISSION.equals(opt) || "permissions".equals(opt)) {
                        i = 2097152;
                        dumpState.setDump(64);
                    } else if ("permission".equals(opt)) {
                        if (opti2 >= strArr.length) {
                            printWriter.println("Error: permission requires permission name");
                            return;
                        }
                        ArraySet<String> permissionNames3 = new ArraySet();
                        while (opti2 < strArr.length) {
                            permissionNames3.add(strArr[opti2]);
                            opti2++;
                        }
                        dumpState.setDump(448);
                        permissionNames = permissionNames3;
                        packageName = null;
                        i2 = opti2;
                        i = 2097152;
                        fullPreferred = false;
                        if (checkin) {
                            printWriter.println("vers,1");
                        }
                        arrayMap = this.mPackages;
                        synchronized (arrayMap) {
                            ArraySet<String> arraySet;
                            boolean z;
                            String str2;
                            try {
                                boolean printedHeader;
                                ActivityIntentResolver activityIntentResolver;
                                String packageName3;
                                ServiceIntentResolver serviceIntentResolver;
                                int i3;
                                int i4;
                                int i5;
                                if (dumpState.isDumping(32768) && packageName == null && !checkin) {
                                    try {
                                        if (dumpState.onTitlePrinted()) {
                                            pw.println();
                                        }
                                        printWriter.println("Database versions:");
                                        this.mSettings.dumpVersionLPr(new IndentingPrintWriter(printWriter, "  "));
                                    } catch (Throwable th2) {
                                        th = th2;
                                        fileDescriptor = fd;
                                        i = arrayMap;
                                        arraySet = permissionNames;
                                        z = fullPreferred;
                                        str2 = packageName;
                                    }
                                }
                                if (dumpState.isDumping(2048) && packageName == null) {
                                    if (!checkin) {
                                        if (dumpState.onTitlePrinted()) {
                                            pw.println();
                                        }
                                        printWriter.println("Verifiers:");
                                        printWriter.print("  Required: ");
                                        printWriter.print(this.mRequiredVerifierPackage);
                                        printWriter.print(" (uid=");
                                        printWriter.print(getPackageUid(this.mRequiredVerifierPackage, 268435456, 0));
                                        printWriter.println(")");
                                    } else if (this.mRequiredVerifierPackage != null) {
                                        printWriter.print("vrfy,");
                                        printWriter.print(this.mRequiredVerifierPackage);
                                        printWriter.print(",");
                                        printWriter.println(getPackageUid(this.mRequiredVerifierPackage, 268435456, 0));
                                    }
                                }
                                if (dumpState.isDumping(131072) && packageName == null) {
                                    if (this.mIntentFilterVerifierComponent != null) {
                                        str = this.mIntentFilterVerifierComponent.getPackageName();
                                        if (!checkin) {
                                            if (dumpState.onTitlePrinted()) {
                                                pw.println();
                                            }
                                            printWriter.println("Intent Filter Verifier:");
                                            printWriter.print("  Using: ");
                                            printWriter.print(str);
                                            printWriter.print(" (uid=");
                                            printWriter.print(getPackageUid(str, 268435456, 0));
                                            printWriter.println(")");
                                        } else if (str != null) {
                                            printWriter.print("ifv,");
                                            printWriter.print(str);
                                            printWriter.print(",");
                                            printWriter.println(getPackageUid(str, 268435456, 0));
                                        }
                                    } else {
                                        pw.println();
                                        printWriter.println("No Intent Filter Verifier available!");
                                    }
                                }
                                if (dumpState.isDumping(1) && packageName == null) {
                                    printedHeader = false;
                                    Iterator<String> it = this.mSharedLibraries.keySet().iterator();
                                    while (it.hasNext()) {
                                        str2 = (String) it.next();
                                        LongSparseArray<SharedLibraryEntry> versionedLib = (LongSparseArray) this.mSharedLibraries.get(str2);
                                        if (versionedLib != null) {
                                            int versionCount = versionedLib.size();
                                            boolean printedHeader2 = printedHeader;
                                            opti = 0;
                                            while (true) {
                                                i = versionCount;
                                                if (opti >= i) {
                                                    break;
                                                }
                                                Iterator<String> it2;
                                                String libName;
                                                SharedLibraryEntry libEntry = (SharedLibraryEntry) versionedLib.valueAt(opti);
                                                if (checkin) {
                                                    printWriter.print("lib,");
                                                } else {
                                                    if (!printedHeader2) {
                                                        if (dumpState.onTitlePrinted()) {
                                                            pw.println();
                                                        }
                                                        printWriter.println("Libraries:");
                                                        printedHeader2 = true;
                                                    }
                                                    printWriter.print("  ");
                                                }
                                                SharedLibraryEntry libEntry2 = libEntry;
                                                printWriter.print(libEntry2.info.getName());
                                                if (libEntry2.info.isStatic()) {
                                                    stringBuilder4 = new StringBuilder();
                                                    it2 = it;
                                                    stringBuilder4.append(" version=");
                                                    libName = str2;
                                                    stringBuilder4.append(libEntry2.info.getLongVersion());
                                                    printWriter.print(stringBuilder4.toString());
                                                } else {
                                                    it2 = it;
                                                    libName = str2;
                                                }
                                                if (!checkin) {
                                                    printWriter.print(" -> ");
                                                }
                                                if (libEntry2.path != null) {
                                                    printWriter.print(" (jar) ");
                                                    printWriter.print(libEntry2.path);
                                                } else {
                                                    printWriter.print(" (apk) ");
                                                    printWriter.print(libEntry2.apk);
                                                }
                                                pw.println();
                                                opti++;
                                                versionCount = i;
                                                it = it2;
                                                str2 = libName;
                                            }
                                            printedHeader = printedHeader2;
                                            i = 2097152;
                                        }
                                    }
                                }
                                if (dumpState.isDumping(2) && packageName == null) {
                                    if (dumpState.onTitlePrinted()) {
                                        pw.println();
                                    }
                                    if (!checkin) {
                                        printWriter.println("Features:");
                                    }
                                    synchronized (this.mAvailableFeatures) {
                                        for (FeatureInfo feat : this.mAvailableFeatures.values()) {
                                            if (checkin) {
                                                printWriter.print("feat,");
                                                printWriter.print(feat.name);
                                                printWriter.print(",");
                                                printWriter.println(feat.version);
                                            } else {
                                                printWriter.print("  ");
                                                printWriter.print(feat.name);
                                                if (feat.version > 0) {
                                                    printWriter.print(" version=");
                                                    printWriter.print(feat.version);
                                                }
                                                pw.println();
                                            }
                                        }
                                    }
                                }
                                if (!checkin) {
                                    try {
                                        if (dumpState.isDumping(4)) {
                                            int user;
                                            activityIntentResolver = this.mActivities;
                                            if (dumpState.getTitlePrinted()) {
                                                str = "\nActivity Resolver Table:";
                                            } else {
                                                str = "Activity Resolver Table:";
                                            }
                                            i = arrayMap;
                                            String str3 = str;
                                            permissionNames2 = permissionNames;
                                            packageName3 = packageName;
                                            opti = 8192;
                                            z = fullPreferred;
                                            if (activityIntentResolver.dump(printWriter, str3, "  ", packageName, dumpState.isOptionEnabled(1), true)) {
                                                dumpState.setTitlePrinted(true);
                                            }
                                            if (!checkin && dumpState.isDumping(16)) {
                                                activityIntentResolver = this.mReceivers;
                                                if (dumpState.getTitlePrinted()) {
                                                    str2 = "Receiver Resolver Table:";
                                                } else {
                                                    str2 = "\nReceiver Resolver Table:";
                                                }
                                                if (activityIntentResolver.dump(printWriter, str2, "  ", packageName3, dumpState.isOptionEnabled(1), true)) {
                                                    dumpState.setTitlePrinted(true);
                                                }
                                            }
                                            if (!checkin && dumpState.isDumping(8)) {
                                                serviceIntentResolver = this.mServices;
                                                if (dumpState.getTitlePrinted()) {
                                                    str2 = "Service Resolver Table:";
                                                } else {
                                                    str2 = "\nService Resolver Table:";
                                                }
                                                if (serviceIntentResolver.dump(printWriter, str2, "  ", packageName3, dumpState.isOptionEnabled(1), true)) {
                                                    dumpState.setTitlePrinted(true);
                                                }
                                            }
                                            if (checkin) {
                                                if (dumpState.isDumping(32)) {
                                                    ProviderIntentResolver providerIntentResolver = this.mProviders;
                                                    if (dumpState.getTitlePrinted()) {
                                                        str2 = "\nProvider Resolver Table:";
                                                    } else {
                                                        str2 = "Provider Resolver Table:";
                                                    }
                                                    if (providerIntentResolver.dump(printWriter, str2, "  ", packageName3, dumpState.isOptionEnabled(1), true)) {
                                                        dumpState.setTitlePrinted(true);
                                                    }
                                                }
                                            }
                                            if (!checkin && dumpState.isDumping(4096)) {
                                                i3 = 0;
                                                while (true) {
                                                    i4 = i3;
                                                    if (i4 < this.mSettings.mPreferredActivities.size()) {
                                                        break;
                                                    }
                                                    PreferredIntentResolver pir = (PreferredIntentResolver) this.mSettings.mPreferredActivities.valueAt(i4);
                                                    user = this.mSettings.mPreferredActivities.keyAt(i4);
                                                    StringBuilder stringBuilder6;
                                                    if (dumpState.getTitlePrinted()) {
                                                        stringBuilder6 = new StringBuilder();
                                                        stringBuilder6.append("\nPreferred Activities User ");
                                                        stringBuilder6.append(user);
                                                        stringBuilder6.append(":");
                                                        str2 = stringBuilder6.toString();
                                                    } else {
                                                        stringBuilder6 = new StringBuilder();
                                                        stringBuilder6.append("Preferred Activities User ");
                                                        stringBuilder6.append(user);
                                                        stringBuilder6.append(":");
                                                        str2 = stringBuilder6.toString();
                                                    }
                                                    i5 = i4;
                                                    if (pir.dump(printWriter, str2, "  ", packageName3, true, 0)) {
                                                        dumpState.setTitlePrinted(true);
                                                    }
                                                    i3 = i5 + 1;
                                                }
                                            }
                                            if (checkin && dumpState.isDumping(r0)) {
                                                pw.flush();
                                                try {
                                                    BufferedOutputStream str4 = new BufferedOutputStream(new FileOutputStream(fd));
                                                    FastXmlSerializer serializer = new FastXmlSerializer();
                                                    serializer.setOutput(str4, StandardCharsets.UTF_8.name());
                                                    serializer.startDocument(null, Boolean.valueOf(true));
                                                    serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
                                                    try {
                                                        this.mSettings.writePreferredActivitiesLPr(serializer, 0, z);
                                                        serializer.endDocument();
                                                        serializer.flush();
                                                    } catch (IllegalArgumentException e4) {
                                                        e = e4;
                                                    } catch (IllegalStateException e5) {
                                                        e2 = e5;
                                                        stringBuilder = new StringBuilder();
                                                        stringBuilder.append("Failed writing: ");
                                                        stringBuilder.append(e2);
                                                        printWriter.println(stringBuilder.toString());
                                                        if (!checkin) {
                                                        }
                                                        fullPreferred = packageName3;
                                                        if (checkin) {
                                                        }
                                                        printedHeader = false;
                                                        for (Provider p : this.mProviders.mProviders.values()) {
                                                        }
                                                        printedHeader = false;
                                                        for (Entry<String, Provider> entry : this.mProvidersByAuthority.entrySet()) {
                                                        }
                                                        this.mSettings.mKeySetManagerService.dumpLPr(printWriter, fullPreferred, dumpState);
                                                        if (dumpState.isDumping(128)) {
                                                        }
                                                        if (dumpState.isDumping(256)) {
                                                        }
                                                        if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                                                        }
                                                        if (!checkin) {
                                                        }
                                                        str2 = packageName2;
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                                        ipw.println();
                                                        ipw.println("Frozen packages:");
                                                        ipw.increaseIndent();
                                                        if (this.mFrozenPackages.size() == 0) {
                                                        }
                                                        ipw.decreaseIndent();
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                                        ipw.println();
                                                        ipw.println("Loaded volumes:");
                                                        ipw.increaseIndent();
                                                        if (this.mLoadedVolumes.size() != 0) {
                                                        }
                                                        ipw.decreaseIndent();
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        printWriter.println("Service permissions:");
                                                        filterIterator = this.mServices.filterIterator();
                                                        while (filterIterator.hasNext()) {
                                                        }
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        dumpDexoptStateLPr(printWriter, str2);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        dumpCompilerStatsLPr(printWriter, str2);
                                                        if (checkin) {
                                                        }
                                                        PackageManagerServiceUtils.dumpCriticalInfo(printWriter, "msg,");
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        this.mInstallerService.dump(new IndentingPrintWriter(printWriter, "  ", 120));
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        this.mHandler.dump(new PrintWriterPrinter(printWriter), " ");
                                                        return;
                                                    } catch (IOException e6) {
                                                        e3 = e6;
                                                        stringBuilder = new StringBuilder();
                                                        stringBuilder.append("Failed writing: ");
                                                        stringBuilder.append(e3);
                                                        printWriter.println(stringBuilder.toString());
                                                        if (checkin) {
                                                        }
                                                        fullPreferred = packageName3;
                                                        if (checkin) {
                                                        }
                                                        printedHeader = false;
                                                        for (Provider p2 : this.mProviders.mProviders.values()) {
                                                        }
                                                        printedHeader = false;
                                                        for (Entry<String, Provider> entry2 : this.mProvidersByAuthority.entrySet()) {
                                                        }
                                                        this.mSettings.mKeySetManagerService.dumpLPr(printWriter, fullPreferred, dumpState);
                                                        if (dumpState.isDumping(128)) {
                                                        }
                                                        if (dumpState.isDumping(256)) {
                                                        }
                                                        if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                                                        }
                                                        if (checkin) {
                                                        }
                                                        str2 = packageName2;
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                                        ipw.println();
                                                        ipw.println("Frozen packages:");
                                                        ipw.increaseIndent();
                                                        if (this.mFrozenPackages.size() == 0) {
                                                        }
                                                        ipw.decreaseIndent();
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                                        ipw.println();
                                                        ipw.println("Loaded volumes:");
                                                        ipw.increaseIndent();
                                                        if (this.mLoadedVolumes.size() != 0) {
                                                        }
                                                        ipw.decreaseIndent();
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        printWriter.println("Service permissions:");
                                                        filterIterator = this.mServices.filterIterator();
                                                        while (filterIterator.hasNext()) {
                                                        }
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        dumpDexoptStateLPr(printWriter, str2);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        dumpCompilerStatsLPr(printWriter, str2);
                                                        if (checkin) {
                                                        }
                                                        PackageManagerServiceUtils.dumpCriticalInfo(printWriter, "msg,");
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        this.mInstallerService.dump(new IndentingPrintWriter(printWriter, "  ", 120));
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        this.mHandler.dump(new PrintWriterPrinter(printWriter), " ");
                                                        return;
                                                    }
                                                } catch (IllegalArgumentException e7) {
                                                    e = e7;
                                                    stringBuilder = new StringBuilder();
                                                    stringBuilder.append("Failed writing: ");
                                                    stringBuilder.append(e);
                                                    printWriter.println(stringBuilder.toString());
                                                    if (checkin) {
                                                    }
                                                    fullPreferred = packageName3;
                                                    if (checkin) {
                                                    }
                                                    printedHeader = false;
                                                    for (Provider p22 : this.mProviders.mProviders.values()) {
                                                    }
                                                    printedHeader = false;
                                                    for (Entry<String, Provider> entry22 : this.mProvidersByAuthority.entrySet()) {
                                                    }
                                                    this.mSettings.mKeySetManagerService.dumpLPr(printWriter, fullPreferred, dumpState);
                                                    if (dumpState.isDumping(128)) {
                                                    }
                                                    if (dumpState.isDumping(256)) {
                                                    }
                                                    if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                                                    }
                                                    if (checkin) {
                                                    }
                                                    str2 = packageName2;
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                                    ipw.println();
                                                    ipw.println("Frozen packages:");
                                                    ipw.increaseIndent();
                                                    if (this.mFrozenPackages.size() == 0) {
                                                    }
                                                    ipw.decreaseIndent();
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                                    ipw.println();
                                                    ipw.println("Loaded volumes:");
                                                    ipw.increaseIndent();
                                                    if (this.mLoadedVolumes.size() != 0) {
                                                    }
                                                    ipw.decreaseIndent();
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    printWriter.println("Service permissions:");
                                                    filterIterator = this.mServices.filterIterator();
                                                    while (filterIterator.hasNext()) {
                                                    }
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    dumpDexoptStateLPr(printWriter, str2);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    dumpCompilerStatsLPr(printWriter, str2);
                                                    if (checkin) {
                                                    }
                                                    PackageManagerServiceUtils.dumpCriticalInfo(printWriter, "msg,");
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mInstallerService.dump(new IndentingPrintWriter(printWriter, "  ", 120));
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mHandler.dump(new PrintWriterPrinter(printWriter), " ");
                                                    return;
                                                } catch (IllegalStateException e8) {
                                                    e2 = e8;
                                                    stringBuilder = new StringBuilder();
                                                    stringBuilder.append("Failed writing: ");
                                                    stringBuilder.append(e2);
                                                    printWriter.println(stringBuilder.toString());
                                                    if (checkin) {
                                                    }
                                                    fullPreferred = packageName3;
                                                    if (checkin) {
                                                    }
                                                    printedHeader = false;
                                                    for (Provider p222 : this.mProviders.mProviders.values()) {
                                                    }
                                                    printedHeader = false;
                                                    for (Entry<String, Provider> entry222 : this.mProvidersByAuthority.entrySet()) {
                                                    }
                                                    this.mSettings.mKeySetManagerService.dumpLPr(printWriter, fullPreferred, dumpState);
                                                    if (dumpState.isDumping(128)) {
                                                    }
                                                    if (dumpState.isDumping(256)) {
                                                    }
                                                    if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                                                    }
                                                    if (checkin) {
                                                    }
                                                    str2 = packageName2;
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                                    ipw.println();
                                                    ipw.println("Frozen packages:");
                                                    ipw.increaseIndent();
                                                    if (this.mFrozenPackages.size() == 0) {
                                                    }
                                                    ipw.decreaseIndent();
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                                    ipw.println();
                                                    ipw.println("Loaded volumes:");
                                                    ipw.increaseIndent();
                                                    if (this.mLoadedVolumes.size() != 0) {
                                                    }
                                                    ipw.decreaseIndent();
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    printWriter.println("Service permissions:");
                                                    filterIterator = this.mServices.filterIterator();
                                                    while (filterIterator.hasNext()) {
                                                    }
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    dumpDexoptStateLPr(printWriter, str2);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    dumpCompilerStatsLPr(printWriter, str2);
                                                    if (checkin) {
                                                    }
                                                    PackageManagerServiceUtils.dumpCriticalInfo(printWriter, "msg,");
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mInstallerService.dump(new IndentingPrintWriter(printWriter, "  ", 120));
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mHandler.dump(new PrintWriterPrinter(printWriter), " ");
                                                    return;
                                                } catch (IOException e9) {
                                                    e3 = e9;
                                                    stringBuilder = new StringBuilder();
                                                    stringBuilder.append("Failed writing: ");
                                                    stringBuilder.append(e3);
                                                    printWriter.println(stringBuilder.toString());
                                                    if (checkin) {
                                                    }
                                                    fullPreferred = packageName3;
                                                    if (checkin) {
                                                    }
                                                    printedHeader = false;
                                                    for (Provider p2222 : this.mProviders.mProviders.values()) {
                                                    }
                                                    printedHeader = false;
                                                    for (Entry<String, Provider> entry2222 : this.mProvidersByAuthority.entrySet()) {
                                                    }
                                                    this.mSettings.mKeySetManagerService.dumpLPr(printWriter, fullPreferred, dumpState);
                                                    if (dumpState.isDumping(128)) {
                                                    }
                                                    if (dumpState.isDumping(256)) {
                                                    }
                                                    if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                                                    }
                                                    if (checkin) {
                                                    }
                                                    str2 = packageName2;
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                                    ipw.println();
                                                    ipw.println("Frozen packages:");
                                                    ipw.increaseIndent();
                                                    if (this.mFrozenPackages.size() == 0) {
                                                    }
                                                    ipw.decreaseIndent();
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                                    ipw.println();
                                                    ipw.println("Loaded volumes:");
                                                    ipw.increaseIndent();
                                                    if (this.mLoadedVolumes.size() != 0) {
                                                    }
                                                    ipw.decreaseIndent();
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    printWriter.println("Service permissions:");
                                                    filterIterator = this.mServices.filterIterator();
                                                    while (filterIterator.hasNext()) {
                                                    }
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    dumpDexoptStateLPr(printWriter, str2);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    dumpCompilerStatsLPr(printWriter, str2);
                                                    if (checkin) {
                                                    }
                                                    PackageManagerServiceUtils.dumpCriticalInfo(printWriter, "msg,");
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mInstallerService.dump(new IndentingPrintWriter(printWriter, "  ", 120));
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mHandler.dump(new PrintWriterPrinter(printWriter), " ");
                                                    return;
                                                } catch (Throwable th3) {
                                                    th = th3;
                                                    throw th;
                                                }
                                            }
                                            fileDescriptor = fd;
                                            if (checkin) {
                                                try {
                                                    if (dumpState.isDumping(262144)) {
                                                        int length;
                                                        int i6;
                                                        int N;
                                                        fullPreferred = packageName3;
                                                        if (!fullPreferred) {
                                                            try {
                                                                pw.println();
                                                                if (this.mSettings.mPackages.size() == 0) {
                                                                    printWriter.println("No applications!");
                                                                    pw.println();
                                                                } else {
                                                                    String prefix = "  ";
                                                                    Collection<PackageSetting> allPackageSettings = this.mSettings.mPackages.values();
                                                                    if (allPackageSettings.size() == 0) {
                                                                        printWriter.println("No domain preferred apps!");
                                                                        pw.println();
                                                                    } else {
                                                                        printWriter.println("App verification status:");
                                                                        pw.println();
                                                                        opti = 0;
                                                                        for (PackageSetting ps : allPackageSettings) {
                                                                            IntentFilterVerificationInfo ivi = ps.getIntentFilterVerificationInfo();
                                                                            if (ivi != null) {
                                                                                if (ivi.getPackageName() != null) {
                                                                                    StringBuilder stringBuilder7 = new StringBuilder();
                                                                                    stringBuilder7.append("  Package: ");
                                                                                    stringBuilder7.append(ivi.getPackageName());
                                                                                    printWriter.println(stringBuilder7.toString());
                                                                                    stringBuilder7 = new StringBuilder();
                                                                                    stringBuilder7.append("  Domains: ");
                                                                                    stringBuilder7.append(ivi.getDomainsString());
                                                                                    printWriter.println(stringBuilder7.toString());
                                                                                    stringBuilder7 = new StringBuilder();
                                                                                    stringBuilder7.append("  Status:  ");
                                                                                    stringBuilder7.append(ivi.getStatusString());
                                                                                    printWriter.println(stringBuilder7.toString());
                                                                                    pw.println();
                                                                                    opti++;
                                                                                }
                                                                            }
                                                                        }
                                                                        if (opti == 0) {
                                                                            printWriter.println("  No app verification established.");
                                                                            pw.println();
                                                                        }
                                                                        int[] userIds = sUserManager.getUserIds();
                                                                        length = userIds.length;
                                                                        opti = 0;
                                                                        while (opti < length) {
                                                                            Collection<PackageSetting> allPackageSettings2;
                                                                            int[] iArr;
                                                                            int i7;
                                                                            int userId = userIds[opti];
                                                                            stringBuilder4 = new StringBuilder();
                                                                            String prefix2 = prefix;
                                                                            stringBuilder4.append("App linkages for user ");
                                                                            stringBuilder4.append(userId);
                                                                            stringBuilder4.append(":");
                                                                            printWriter.println(stringBuilder4.toString());
                                                                            pw.println();
                                                                            i3 = 0;
                                                                            Iterator it3 = allPackageSettings.iterator();
                                                                            while (it3.hasNext()) {
                                                                                PackageSetting ps2 = (PackageSetting) it3.next();
                                                                                allPackageSettings2 = allPackageSettings;
                                                                                iArr = userIds;
                                                                                allPackageSettings = ps2.getDomainVerificationStatusForUser(userId);
                                                                                if ((allPackageSettings >> 32) != 0 || DEBUG_DOMAIN_VERIFICATION) {
                                                                                    i7 = length;
                                                                                    stringBuilder = new StringBuilder();
                                                                                    Iterator it4 = it3;
                                                                                    stringBuilder.append("  Package: ");
                                                                                    stringBuilder.append(ps2.name);
                                                                                    printWriter.println(stringBuilder.toString());
                                                                                    stringBuilder = new StringBuilder();
                                                                                    stringBuilder.append("  Domains: ");
                                                                                    stringBuilder.append(dumpDomainString(ps2.name));
                                                                                    printWriter.println(stringBuilder.toString());
                                                                                    opt = IntentFilterVerificationInfo.getStatusStringFromValue(allPackageSettings);
                                                                                    stringBuilder5 = new StringBuilder();
                                                                                    long status = allPackageSettings;
                                                                                    stringBuilder5.append("  Status:  ");
                                                                                    stringBuilder5.append(opt);
                                                                                    printWriter.println(stringBuilder5.toString());
                                                                                    pw.println();
                                                                                    i3++;
                                                                                    allPackageSettings = allPackageSettings2;
                                                                                    userIds = iArr;
                                                                                    length = i7;
                                                                                    it3 = it4;
                                                                                } else {
                                                                                    allPackageSettings = allPackageSettings2;
                                                                                    userIds = iArr;
                                                                                }
                                                                            }
                                                                            allPackageSettings2 = allPackageSettings;
                                                                            iArr = userIds;
                                                                            i7 = length;
                                                                            if (i3 == 0) {
                                                                                printWriter.println("  No configured app linkages.");
                                                                                pw.println();
                                                                            }
                                                                            opti++;
                                                                            user = i3;
                                                                            prefix = prefix2;
                                                                            allPackageSettings = allPackageSettings2;
                                                                            userIds = iArr;
                                                                            length = i7;
                                                                        }
                                                                    }
                                                                }
                                                            } catch (Throwable th4) {
                                                                th = th4;
                                                                obj = fullPreferred;
                                                                arraySet = permissionNames2;
                                                                throw th;
                                                            }
                                                        }
                                                        if (checkin) {
                                                            try {
                                                                if (dumpState.isDumping(64)) {
                                                                    arraySet = permissionNames2;
                                                                    this.mSettings.dumpPermissionsLPr(printWriter, fullPreferred, arraySet, dumpState);
                                                                } else {
                                                                    arraySet = permissionNames2;
                                                                }
                                                            } catch (Throwable th5) {
                                                                th = th5;
                                                                obj = fullPreferred;
                                                                throw th;
                                                            }
                                                        }
                                                        arraySet = permissionNames2;
                                                        if (!checkin && dumpState.isDumping(1024)) {
                                                            printedHeader = false;
                                                            for (Provider p22222 : this.mProviders.mProviders.values()) {
                                                                if (!fullPreferred || fullPreferred.equals(p22222.info.packageName)) {
                                                                    if (!printedHeader) {
                                                                        if (dumpState.onTitlePrinted()) {
                                                                            pw.println();
                                                                        }
                                                                        printWriter.println("Registered ContentProviders:");
                                                                        printedHeader = true;
                                                                    }
                                                                    printWriter.print("  ");
                                                                    p22222.printComponentShortName(printWriter);
                                                                    printWriter.println(":");
                                                                    printWriter.print("    ");
                                                                    printWriter.println(p22222.toString());
                                                                }
                                                            }
                                                            printedHeader = false;
                                                            for (Entry<String, Provider> entry22222 : this.mProvidersByAuthority.entrySet()) {
                                                                Provider p3 = (Provider) entry22222.getValue();
                                                                if (!fullPreferred || fullPreferred.equals(p3.info.packageName)) {
                                                                    if (!printedHeader) {
                                                                        if (dumpState.onTitlePrinted()) {
                                                                            pw.println();
                                                                        }
                                                                        printWriter.println("ContentProvider Authorities:");
                                                                        printedHeader = true;
                                                                    }
                                                                    printWriter.print("  [");
                                                                    printWriter.print((String) entry22222.getKey());
                                                                    printWriter.println("]:");
                                                                    printWriter.print("    ");
                                                                    printWriter.println(p3.toString());
                                                                    if (!(p3.info == null || p3.info.applicationInfo == null)) {
                                                                        opt = p3.info.applicationInfo.toString();
                                                                        printWriter.print("      applicationInfo=");
                                                                        printWriter.println(opt);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        if (!checkin && dumpState.isDumping(16384)) {
                                                            this.mSettings.mKeySetManagerService.dumpLPr(printWriter, fullPreferred, dumpState);
                                                        }
                                                        if (dumpState.isDumping(128)) {
                                                            try {
                                                                packageName2 = fullPreferred;
                                                                i6 = 0;
                                                            } catch (Throwable th6) {
                                                                th = th6;
                                                                obj = fullPreferred;
                                                                throw th;
                                                            }
                                                            try {
                                                                this.mSettings.dumpPackagesLPr(printWriter, fullPreferred, arraySet, dumpState, checkin);
                                                            } catch (Throwable th7) {
                                                                th = th7;
                                                                str2 = packageName2;
                                                            }
                                                        } else {
                                                            packageName2 = fullPreferred;
                                                            i6 = 0;
                                                        }
                                                        if (dumpState.isDumping(256)) {
                                                            this.mSettings.dumpSharedUsersLPr(printWriter, packageName2, arraySet, dumpState, checkin);
                                                        }
                                                        if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                                                            if (dumpState.onTitlePrinted()) {
                                                                pw.println();
                                                            }
                                                            printWriter.println("Package Changes:");
                                                            printWriter.print("  Sequence number=");
                                                            printWriter.println(this.mChangedPackagesSequenceNumber);
                                                            opti = this.mChangedPackages.size();
                                                            for (i3 = i6; i3 < opti; i3++) {
                                                                SparseArray<String> changes = (SparseArray) this.mChangedPackages.valueAt(i3);
                                                                printWriter.print("  User ");
                                                                printWriter.print(this.mChangedPackages.keyAt(i3));
                                                                printWriter.println(":");
                                                                N = changes.size();
                                                                if (N == 0) {
                                                                    printWriter.print("    ");
                                                                    printWriter.println("No packages changed");
                                                                } else {
                                                                    for (length = i6; length < N; length++) {
                                                                        String fullPreferred2 = (String) changes.valueAt(length);
                                                                        user = changes.keyAt(length);
                                                                        printWriter.print("    ");
                                                                        printWriter.print("seq=");
                                                                        printWriter.print(user);
                                                                        printWriter.print(", package=");
                                                                        printWriter.println(fullPreferred2);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        if (checkin) {
                                                            if (dumpState.isDumping(64)) {
                                                                str2 = packageName2;
                                                                if (str2 == null) {
                                                                    try {
                                                                        this.mSettings.dumpRestoredPermissionGrantsLPr(printWriter, dumpState);
                                                                    } catch (Throwable th8) {
                                                                        th = th8;
                                                                        throw th;
                                                                    }
                                                                }
                                                                if (!checkin && dumpState.isDumping(524288) && str2 == null) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                                                    ipw.println();
                                                                    ipw.println("Frozen packages:");
                                                                    ipw.increaseIndent();
                                                                    if (this.mFrozenPackages.size() == 0) {
                                                                        ipw.println("(none)");
                                                                    } else {
                                                                        for (N = i6; N < this.mFrozenPackages.size(); N++) {
                                                                            ipw.println((String) this.mFrozenPackages.valueAt(N));
                                                                        }
                                                                    }
                                                                    ipw.decreaseIndent();
                                                                }
                                                                if (!checkin && dumpState.isDumping(DumpState.DUMP_VOLUMES) && str2 == null) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                                                    ipw.println();
                                                                    ipw.println("Loaded volumes:");
                                                                    ipw.increaseIndent();
                                                                    if (this.mLoadedVolumes.size() != 0) {
                                                                        while (true) {
                                                                            N = i6;
                                                                            if (N >= this.mLoadedVolumes.size()) {
                                                                                break;
                                                                            }
                                                                            ipw.println((String) this.mLoadedVolumes.valueAt(N));
                                                                            i6 = N + 1;
                                                                        }
                                                                    } else {
                                                                        ipw.println("(none)");
                                                                    }
                                                                    ipw.decreaseIndent();
                                                                }
                                                                if (!checkin && dumpState.isDumping(DumpState.DUMP_SERVICE_PERMISSIONS) && str2 == null) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    printWriter.println("Service permissions:");
                                                                    filterIterator = this.mServices.filterIterator();
                                                                    while (filterIterator.hasNext()) {
                                                                        ServiceInfo serviceInfo = ((ServiceIntentInfo) filterIterator.next()).service.info;
                                                                        fullPreferred = serviceInfo.permission;
                                                                        if (fullPreferred) {
                                                                            printWriter.print("    ");
                                                                            printWriter.print(serviceInfo.getComponentName().flattenToShortString());
                                                                            printWriter.print(": ");
                                                                            printWriter.println(fullPreferred);
                                                                        }
                                                                    }
                                                                }
                                                                if (!checkin && dumpState.isDumping(1048576)) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    dumpDexoptStateLPr(printWriter, str2);
                                                                }
                                                                if (!checkin && dumpState.isDumping(2097152)) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    dumpCompilerStatsLPr(printWriter, str2);
                                                                }
                                                                if (checkin) {
                                                                    i3 = 512;
                                                                    if (dumpState.isDumping(512) && str2 == null) {
                                                                        if (dumpState.onTitlePrinted()) {
                                                                            pw.println();
                                                                        }
                                                                        this.mSettings.dumpReadMessagesLPr(printWriter, dumpState);
                                                                        pw.println();
                                                                        printWriter.println("Package warning messages:");
                                                                        PackageManagerServiceUtils.dumpCriticalInfo(printWriter, null);
                                                                    }
                                                                } else {
                                                                    i3 = 512;
                                                                }
                                                                if (checkin && dumpState.isDumping(r2)) {
                                                                    PackageManagerServiceUtils.dumpCriticalInfo(printWriter, "msg,");
                                                                }
                                                                if (!checkin && dumpState.isDumping(65536) && str2 == null) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    this.mInstallerService.dump(new IndentingPrintWriter(printWriter, "  ", 120));
                                                                }
                                                                if (!checkin && dumpState.isDumping(DumpState.DUMP_HANDLE) && str2 == null) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    this.mHandler.dump(new PrintWriterPrinter(printWriter), " ");
                                                                }
                                                                return;
                                                            }
                                                        }
                                                        str2 = packageName2;
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                                        ipw.println();
                                                        ipw.println("Frozen packages:");
                                                        ipw.increaseIndent();
                                                        if (this.mFrozenPackages.size() == 0) {
                                                        }
                                                        ipw.decreaseIndent();
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                                        ipw.println();
                                                        ipw.println("Loaded volumes:");
                                                        ipw.increaseIndent();
                                                        if (this.mLoadedVolumes.size() != 0) {
                                                        }
                                                        ipw.decreaseIndent();
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        printWriter.println("Service permissions:");
                                                        filterIterator = this.mServices.filterIterator();
                                                        while (filterIterator.hasNext()) {
                                                        }
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        dumpDexoptStateLPr(printWriter, str2);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        dumpCompilerStatsLPr(printWriter, str2);
                                                        if (checkin) {
                                                        }
                                                        PackageManagerServiceUtils.dumpCriticalInfo(printWriter, "msg,");
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        this.mInstallerService.dump(new IndentingPrintWriter(printWriter, "  ", 120));
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        this.mHandler.dump(new PrintWriterPrinter(printWriter), " ");
                                                        return;
                                                    }
                                                } catch (Throwable th9) {
                                                    th = th9;
                                                    arraySet = permissionNames2;
                                                    str2 = packageName3;
                                                    throw th;
                                                }
                                            }
                                            fullPreferred = packageName3;
                                            if (checkin) {
                                            }
                                            printedHeader = false;
                                            for (Provider p222222 : this.mProviders.mProviders.values()) {
                                            }
                                            printedHeader = false;
                                            for (Entry<String, Provider> entry222222 : this.mProvidersByAuthority.entrySet()) {
                                            }
                                            this.mSettings.mKeySetManagerService.dumpLPr(printWriter, fullPreferred, dumpState);
                                            if (dumpState.isDumping(128)) {
                                            }
                                            try {
                                                if (dumpState.isDumping(256)) {
                                                }
                                                if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                                                }
                                                if (checkin) {
                                                }
                                                str2 = packageName2;
                                                if (dumpState.onTitlePrinted()) {
                                                }
                                                ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                                ipw.println();
                                                ipw.println("Frozen packages:");
                                                ipw.increaseIndent();
                                                if (this.mFrozenPackages.size() == 0) {
                                                }
                                                ipw.decreaseIndent();
                                                if (dumpState.onTitlePrinted()) {
                                                }
                                                ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                                ipw.println();
                                                ipw.println("Loaded volumes:");
                                                ipw.increaseIndent();
                                                if (this.mLoadedVolumes.size() != 0) {
                                                }
                                                ipw.decreaseIndent();
                                                if (dumpState.onTitlePrinted()) {
                                                }
                                                printWriter.println("Service permissions:");
                                                filterIterator = this.mServices.filterIterator();
                                                while (filterIterator.hasNext()) {
                                                }
                                                if (dumpState.onTitlePrinted()) {
                                                }
                                                dumpDexoptStateLPr(printWriter, str2);
                                                if (dumpState.onTitlePrinted()) {
                                                }
                                                dumpCompilerStatsLPr(printWriter, str2);
                                                if (checkin) {
                                                }
                                                PackageManagerServiceUtils.dumpCriticalInfo(printWriter, "msg,");
                                                if (dumpState.onTitlePrinted()) {
                                                }
                                                this.mInstallerService.dump(new IndentingPrintWriter(printWriter, "  ", 120));
                                                if (dumpState.onTitlePrinted()) {
                                                }
                                                this.mHandler.dump(new PrintWriterPrinter(printWriter), " ");
                                                return;
                                            } catch (Throwable th10) {
                                                th = th10;
                                                str2 = packageName2;
                                                throw th;
                                            }
                                        }
                                    } catch (Throwable th11) {
                                        th = th11;
                                        fileDescriptor = fd;
                                        throw th;
                                    }
                                }
                                i = arrayMap;
                                permissionNames2 = permissionNames;
                                z = fullPreferred;
                                packageName3 = packageName;
                                opti = 8192;
                                activityIntentResolver = this.mReceivers;
                                if (dumpState.getTitlePrinted()) {
                                }
                                if (activityIntentResolver.dump(printWriter, str2, "  ", packageName3, dumpState.isOptionEnabled(1), true)) {
                                }
                                serviceIntentResolver = this.mServices;
                                if (dumpState.getTitlePrinted()) {
                                }
                                if (serviceIntentResolver.dump(printWriter, str2, "  ", packageName3, dumpState.isOptionEnabled(1), true)) {
                                }
                                if (checkin) {
                                }
                                i3 = 0;
                                while (true) {
                                    i4 = i3;
                                    if (i4 < this.mSettings.mPreferredActivities.size()) {
                                    }
                                    i3 = i5 + 1;
                                }
                                if (checkin) {
                                }
                                fileDescriptor = fd;
                                if (checkin) {
                                }
                                fullPreferred = packageName3;
                                if (checkin) {
                                }
                                printedHeader = false;
                                for (Provider p2222222 : this.mProviders.mProviders.values()) {
                                }
                                printedHeader = false;
                                for (Entry<String, Provider> entry2222222 : this.mProvidersByAuthority.entrySet()) {
                                }
                                this.mSettings.mKeySetManagerService.dumpLPr(printWriter, fullPreferred, dumpState);
                                try {
                                    if (dumpState.isDumping(128)) {
                                    }
                                    if (dumpState.isDumping(256)) {
                                    }
                                    if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                                    }
                                    if (checkin) {
                                    }
                                    str2 = packageName2;
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                    ipw.println();
                                    ipw.println("Frozen packages:");
                                    ipw.increaseIndent();
                                    if (this.mFrozenPackages.size() == 0) {
                                    }
                                    ipw.decreaseIndent();
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                    ipw.println();
                                    ipw.println("Loaded volumes:");
                                    ipw.increaseIndent();
                                    if (this.mLoadedVolumes.size() != 0) {
                                    }
                                    ipw.decreaseIndent();
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    printWriter.println("Service permissions:");
                                    filterIterator = this.mServices.filterIterator();
                                    while (filterIterator.hasNext()) {
                                    }
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    dumpDexoptStateLPr(printWriter, str2);
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    dumpCompilerStatsLPr(printWriter, str2);
                                    if (checkin) {
                                    }
                                    PackageManagerServiceUtils.dumpCriticalInfo(printWriter, "msg,");
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    this.mInstallerService.dump(new IndentingPrintWriter(printWriter, "  ", 120));
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    this.mHandler.dump(new PrintWriterPrinter(printWriter), " ");
                                    return;
                                } catch (Throwable th12) {
                                    th = th12;
                                    obj = fullPreferred;
                                    throw th;
                                }
                            } catch (Throwable th13) {
                                th = th13;
                                fileDescriptor = fd;
                                i = arrayMap;
                                arraySet = permissionNames;
                                z = fullPreferred;
                                str2 = packageName;
                                throw th;
                            }
                        }
                    } else if ("pref".equals(opt) || "preferred".equals(opt)) {
                        i = 2097152;
                        dumpState.setDump(4096);
                    } else {
                        if ("preferred-xml".equals(opt)) {
                            dumpState.setDump(8192);
                            if (opti2 < strArr.length && "--full".equals(strArr[opti2])) {
                                i2 = opti2 + 1;
                                fullPreferred = true;
                                packageName = null;
                                permissionNames = null;
                                i = 2097152;
                                if (checkin) {
                                }
                                arrayMap = this.mPackages;
                                synchronized (arrayMap) {
                                }
                            }
                        } else if ("d".equals(opt) || "domain-preferred-apps".equals(opt)) {
                            i = 2097152;
                            dumpState.setDump(262144);
                        } else if ("p".equals(opt) || "packages".equals(opt)) {
                            i = 2097152;
                            dumpState.setDump(128);
                        } else if ("s".equals(opt) || "shared-users".equals(opt)) {
                            i = 2097152;
                            dumpState.setDump(256);
                        } else if ("prov".equals(opt) || "providers".equals(opt)) {
                            i = 2097152;
                            dumpState.setDump(1024);
                        } else if ("m".equals(opt) || "messages".equals(opt)) {
                            i = 2097152;
                            dumpState.setDump(512);
                        } else if ("v".equals(opt) || "verifiers".equals(opt)) {
                            i = 2097152;
                            dumpState.setDump(2048);
                        } else if ("i".equals(opt) || "ifv".equals(opt) || "intent-filter-verifiers".equals(opt)) {
                            i = 2097152;
                            dumpState.setDump(131072);
                        } else if ("version".equals(opt)) {
                            dumpState.setDump(32768);
                        } else if ("k".equals(opt) || "keysets".equals(opt)) {
                            i = 2097152;
                            dumpState.setDump(16384);
                        } else if ("installs".equals(opt)) {
                            dumpState.setDump(65536);
                        } else if ("frozen".equals(opt)) {
                            dumpState.setDump(524288);
                        } else if ("volumes".equals(opt)) {
                            dumpState.setDump(DumpState.DUMP_VOLUMES);
                        } else if ("dexopt".equals(opt)) {
                            dumpState.setDump(1048576);
                        } else if ("compiler-stats".equals(opt)) {
                            i = 2097152;
                            dumpState.setDump(2097152);
                        } else {
                            i = 2097152;
                            if ("changes".equals(opt)) {
                                dumpState.setDump(DumpState.DUMP_CHANGES);
                            } else if ("service-permissions".equals(opt)) {
                                dumpState.setDump(DumpState.DUMP_SERVICE_PERMISSIONS);
                            } else if ("h".equals(opt) || "handle".equals(opt)) {
                                dumpState.setDump(DumpState.DUMP_HANDLE);
                            } else if ("write".equals(opt)) {
                                synchronized (this.mPackages) {
                                    this.mSettings.writeLPr();
                                    printWriter.println("Settings written.");
                                }
                                return;
                            }
                        }
                        i = 2097152;
                    }
                    packageName = null;
                } else if (opti2 >= strArr.length) {
                    printWriter.println("Error: check-permission missing permission argument");
                    return;
                } else {
                    packageName = strArr[opti2];
                    opti2++;
                    if (opti2 >= strArr.length) {
                        printWriter.println("Error: check-permission missing package argument");
                        return;
                    }
                    String pkg = strArr[opti2];
                    opti2++;
                    int user2 = UserHandle.getUserId(Binder.getCallingUid());
                    if (opti2 < strArr.length) {
                        try {
                            user2 = Integer.parseInt(strArr[opti2]);
                        } catch (NumberFormatException e10) {
                            stringBuilder4 = new StringBuilder();
                            stringBuilder4.append("Error: check-permission user argument is not a number: ");
                            stringBuilder4.append(strArr[opti2]);
                            printWriter.println(stringBuilder4.toString());
                            return;
                        }
                    }
                    printWriter.println(checkPermission(packageName, resolveInternalPackageNameLPr(pkg, -1), user2));
                    return;
                }
                permissionNames = null;
                fullPreferred = false;
                if (checkin) {
                }
                arrayMap = this.mPackages;
                synchronized (arrayMap) {
                }
            } else {
                i = 2097152;
            }
            fullPreferred = false;
            packageName = null;
            permissionNames = null;
            if (checkin) {
            }
            arrayMap = this.mPackages;
            synchronized (arrayMap) {
            }
        }
    }

    private void dumpProto(FileDescriptor fd) {
        ProtoOutputStream proto = new ProtoOutputStream(fd);
        synchronized (this.mPackages) {
            long requiredVerifierPackageToken = proto.start(1146756268033L);
            proto.write(1138166333441L, this.mRequiredVerifierPackage);
            proto.write(1120986464258L, getPackageUid(this.mRequiredVerifierPackage, 268435456, 0));
            proto.end(requiredVerifierPackageToken);
            if (this.mIntentFilterVerifierComponent != null) {
                String verifierPackageName = this.mIntentFilterVerifierComponent.getPackageName();
                long verifierPackageToken = proto.start(1146756268034L);
                proto.write(1138166333441L, verifierPackageName);
                proto.write(1120986464258L, getPackageUid(verifierPackageName, 268435456, 0));
                proto.end(verifierPackageToken);
            }
            dumpSharedLibrariesProto(proto);
            dumpFeaturesProto(proto);
            this.mSettings.dumpPackagesProto(proto);
            this.mSettings.dumpSharedUsersProto(proto);
            PackageManagerServiceUtils.dumpCriticalInfo(proto);
        }
        proto.flush();
    }

    private void dumpFeaturesProto(ProtoOutputStream proto) {
        synchronized (this.mAvailableFeatures) {
            int count = this.mAvailableFeatures.size();
            for (int i = 0; i < count; i++) {
                ((FeatureInfo) this.mAvailableFeatures.valueAt(i)).writeToProto(proto, 2246267895812L);
            }
        }
    }

    private void dumpSharedLibrariesProto(ProtoOutputStream proto) {
        int count = this.mSharedLibraries.size();
        for (int i = 0; i < count; i++) {
            LongSparseArray<SharedLibraryEntry> versionedLib = (LongSparseArray) this.mSharedLibraries.get((String) this.mSharedLibraries.keyAt(i));
            if (versionedLib != null) {
                int versionCount = versionedLib.size();
                for (int j = 0; j < versionCount; j++) {
                    SharedLibraryEntry libEntry = (SharedLibraryEntry) versionedLib.valueAt(j);
                    long sharedLibraryToken = proto.start(2246267895811L);
                    proto.write(1138166333441L, libEntry.info.getName());
                    boolean isJar = libEntry.path != null;
                    proto.write(1133871366146L, isJar);
                    if (isJar) {
                        proto.write(1138166333443L, libEntry.path);
                    } else {
                        proto.write(1138166333444L, libEntry.apk);
                    }
                    proto.end(sharedLibraryToken);
                }
            }
        }
    }

    private void dumpDexoptStateLPr(PrintWriter pw, String packageName) {
        IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
        ipw.println();
        ipw.println("Dexopt state:");
        ipw.increaseIndent();
        Collection<Package> packages;
        if (packageName != null) {
            Package targetPackage = (Package) this.mPackages.get(packageName);
            if (targetPackage != null) {
                packages = Collections.singletonList(targetPackage);
            } else {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Unable to find package: ");
                stringBuilder.append(packageName);
                ipw.println(stringBuilder.toString());
                return;
            }
        }
        packages = this.mPackages.values();
        for (Package pkg : packages) {
            StringBuilder stringBuilder2 = new StringBuilder();
            stringBuilder2.append("[");
            stringBuilder2.append(pkg.packageName);
            stringBuilder2.append("]");
            ipw.println(stringBuilder2.toString());
            ipw.increaseIndent();
            this.mPackageDexOptimizer.dumpDexoptState(ipw, pkg, this.mDexManager.getPackageUseInfoOrDefault(pkg.packageName));
            ipw.decreaseIndent();
        }
    }

    private void dumpCompilerStatsLPr(PrintWriter pw, String packageName) {
        IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
        ipw.println();
        ipw.println("Compiler stats:");
        ipw.increaseIndent();
        Collection<Package> packages;
        if (packageName != null) {
            Package targetPackage = (Package) this.mPackages.get(packageName);
            if (targetPackage != null) {
                packages = Collections.singletonList(targetPackage);
            } else {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Unable to find package: ");
                stringBuilder.append(packageName);
                ipw.println(stringBuilder.toString());
                return;
            }
        }
        packages = this.mPackages.values();
        for (Package pkg : packages) {
            StringBuilder stringBuilder2 = new StringBuilder();
            stringBuilder2.append("[");
            stringBuilder2.append(pkg.packageName);
            stringBuilder2.append("]");
            ipw.println(stringBuilder2.toString());
            ipw.increaseIndent();
            PackageStats stats = getCompilerPackageStats(pkg.packageName);
            if (stats == null) {
                ipw.println("(No recorded stats)");
            } else {
                stats.dump(ipw);
            }
            ipw.decreaseIndent();
        }
    }

    private String dumpDomainString(String packageName) {
        List<IntentFilterVerificationInfo> iviList = getIntentFilterVerifications(packageName).getList();
        List<IntentFilter> filters = getAllIntentFilters(packageName).getList();
        ArraySet<String> result = new ArraySet();
        if (iviList.size() > 0) {
            for (IntentFilterVerificationInfo ivi : iviList) {
                for (String host : ivi.getDomains()) {
                    result.add(host);
                }
            }
        }
        if (filters != null && filters.size() > 0) {
            for (IntentFilter filter : filters) {
                if (filter.hasCategory("android.intent.category.BROWSABLE") && (filter.hasDataScheme("http") || filter.hasDataScheme("https"))) {
                    result.addAll(filter.getHostsList());
                }
            }
        }
        StringBuilder sb = new StringBuilder(result.size() * 16);
        Iterator it = result.iterator();
        while (it.hasNext()) {
            String domain = (String) it.next();
            if (sb.length() > 0) {
                sb.append(" ");
            }
            sb.append(domain);
        }
        return sb.toString();
    }

    static String getEncryptKey() {
        String str;
        StringBuilder stringBuilder;
        try {
            String sdEncKey = SystemKeyStore.getInstance().retrieveKeyHexString(SD_ENCRYPTION_KEYSTORE_NAME);
            if (sdEncKey == null) {
                sdEncKey = SystemKeyStore.getInstance().generateNewKeyHexString(128, SD_ENCRYPTION_ALGORITHM, SD_ENCRYPTION_KEYSTORE_NAME);
                if (sdEncKey == null) {
                    Slog.e(TAG, "Failed to create encryption keys");
                    return null;
                }
            }
            return sdEncKey;
        } catch (NoSuchAlgorithmException nsae) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("Failed to create encryption keys with exception: ");
            stringBuilder.append(nsae);
            Slog.e(str, stringBuilder.toString());
            return null;
        } catch (IOException ioe) {
            str = TAG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("Failed to retrieve encryption keys with exception: ");
            stringBuilder.append(ioe);
            Slog.e(str, stringBuilder.toString());
            return null;
        }
    }

    private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, ArrayList<ApplicationInfo> infos, IIntentReceiver finishedReceiver) {
        int size = infos.size();
        String[] packageNames = new String[size];
        int[] packageUids = new int[size];
        for (int i = 0; i < size; i++) {
            ApplicationInfo info = (ApplicationInfo) infos.get(i);
            packageNames[i] = info.packageName;
            packageUids[i] = info.uid;
        }
        sendResourcesChangedBroadcast(mediaStatus, replacing, packageNames, packageUids, finishedReceiver);
    }

    private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, ArrayList<String> pkgList, int[] uidArr, IIntentReceiver finishedReceiver) {
        sendResourcesChangedBroadcast(mediaStatus, replacing, (String[]) pkgList.toArray(new String[pkgList.size()]), uidArr, finishedReceiver);
    }

    private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, String[] pkgList, int[] uidArr, IIntentReceiver finishedReceiver) {
        boolean z = replacing;
        String[] strArr = pkgList;
        int[] iArr = uidArr;
        if (strArr.length > 0) {
            String str;
            Bundle extras = new Bundle();
            extras.putStringArray("android.intent.extra.changed_package_list", strArr);
            if (iArr != null) {
                extras.putIntArray("android.intent.extra.changed_uid_list", iArr);
            }
            if (z) {
                extras.putBoolean("android.intent.extra.REPLACING", z);
            }
            if (mediaStatus) {
                str = "android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE";
            } else {
                str = "android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE";
            }
            sendPackageBroadcast(str, null, extras, 0, null, finishedReceiver, null, null);
        }
    }

    private void loadPrivatePackages(final VolumeInfo vol) {
        this.mHandler.post(new Runnable() {
            public void run() {
                PackageManagerService.this.loadPrivatePackagesInner(vol);
            }
        });
    }

    /* JADX WARNING: Removed duplicated region for block: B:34:0x00b7 A:{Catch:{ all -> 0x00c5, all -> 0x00ca }} */
    /* JADX WARNING: Removed duplicated region for block: B:34:0x00b7 A:{Catch:{ all -> 0x00c5, all -> 0x00ca }} */
    /* JADX WARNING: Missing block: B:61:0x0122, code skipped:
            r21 = r2;
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void loadPrivatePackagesInner(VolumeInfo vol) {
        VersionInfo ver;
        PackageSetting ps;
        PackageManagerException e;
        String str;
        StringBuilder stringBuilder;
        Throwable th;
        Iterator it;
        IllegalStateException e2;
        String volumeUuid = vol.fsUuid;
        if (TextUtils.isEmpty(volumeUuid)) {
            Slog.e(TAG, "Loading internal storage is probably a mistake; ignoring");
            return;
        }
        List<PackageSetting> packages;
        ArrayList<PackageFreezer> freezers = new ArrayList();
        ArrayList<ApplicationInfo> loaded = new ArrayList();
        int parseFlags = this.mDefParseFlags | 8;
        synchronized (this.mPackages) {
            ver = this.mSettings.findOrCreateVersion(volumeUuid);
            packages = this.mSettings.getVolumePackagesLPr(volumeUuid);
        }
        Iterator it2;
        for (Iterator it3 = packages.iterator(); it3.hasNext(); it3 = it2) {
            PackageSetting ps2 = (PackageSetting) it3.next();
            freezers.add(freezePackage(ps2.name, "loadPrivatePackagesInner"));
            Object obj = this.mInstallLock;
            synchronized (obj) {
                PackageSetting ps3;
                Object obj2;
                try {
                    ps3 = ps2;
                    obj2 = obj;
                    it2 = it3;
                    try {
                        loaded.add(scanPackageTracedLI(ps2.codePath, parseFlags, 512, 0, null).applicationInfo);
                        ps = ps3;
                    } catch (PackageManagerException e3) {
                        e = e3;
                        try {
                            str = TAG;
                            stringBuilder = new StringBuilder();
                            stringBuilder.append("Failed to scan ");
                            ps = ps3;
                            stringBuilder.append(ps.codePath);
                            stringBuilder.append(": ");
                            stringBuilder.append(e.getMessage());
                            Slog.w(str, stringBuilder.toString());
                            if (!Build.FINGERPRINT.equals(ver.fingerprint)) {
                            }
                        } catch (Throwable th2) {
                            th = th2;
                            throw th;
                        }
                    } catch (Throwable th3) {
                        th = th3;
                        ps = ps3;
                        throw th;
                    }
                } catch (PackageManagerException e4) {
                    e = e4;
                    ps3 = ps2;
                    obj2 = obj;
                    it2 = it3;
                    str = TAG;
                    stringBuilder = new StringBuilder();
                    stringBuilder.append("Failed to scan ");
                    ps = ps3;
                    stringBuilder.append(ps.codePath);
                    stringBuilder.append(": ");
                    stringBuilder.append(e.getMessage());
                    Slog.w(str, stringBuilder.toString());
                    if (Build.FINGERPRINT.equals(ver.fingerprint)) {
                    }
                } catch (Throwable th4) {
                    th = th4;
                    obj2 = obj;
                    ps = ps2;
                    throw th;
                }
                if (Build.FINGERPRINT.equals(ver.fingerprint)) {
                    clearAppDataLIF(ps.pkg, -1, UsbTerminalTypes.TERMINAL_IN_PERSONAL_MIC);
                }
            }
        }
        StorageManager sm = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        UserManager um = (UserManager) this.mContext.getSystemService(UserManager.class);
        UserManagerInternal umInternal = getUserManagerInternal();
        Iterator it4 = um.getUsers().iterator();
        while (it4.hasNext()) {
            int flags;
            UserInfo user = (UserInfo) it4.next();
            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
                flags = 3;
            } else if (umInternal.isUserRunning(user.id)) {
                flags = 1;
            }
            int flags2 = flags;
            try {
                sm.prepareUserStorage(volumeUuid, user.id, user.serialNumber, flags2);
                synchronized (this.mInstallLock) {
                    try {
                        it = it4;
                        reconcileAppsDataLI(volumeUuid, user.id, flags2, true);
                    } catch (Throwable th5) {
                        th = th5;
                        throw th;
                    }
                }
            } catch (IllegalStateException e5) {
                e2 = e5;
                it = it4;
                str = TAG;
                StringBuilder stringBuilder2 = new StringBuilder();
                StorageManager sm2 = sm;
                stringBuilder2.append("Failed to prepare storage: ");
                stringBuilder2.append(e2);
                Slog.w(str, stringBuilder2.toString());
                it4 = it;
                sm = sm2;
            }
        }
        synchronized (this.mPackages) {
            boolean sdkUpdated = ver.sdkVersion != this.mSdkVersion;
            if (sdkUpdated) {
                StringBuilder stringBuilder3 = new StringBuilder();
                stringBuilder3.append("Platform changed from ");
                stringBuilder3.append(ver.sdkVersion);
                stringBuilder3.append(" to ");
                stringBuilder3.append(this.mSdkVersion);
                stringBuilder3.append("; regranting permissions for ");
                stringBuilder3.append(volumeUuid);
                PackageManagerServiceUtils.logCriticalInfo(4, stringBuilder3.toString());
            }
            this.mPermissionManager.updateAllPermissions(volumeUuid, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
            ver.forceCurrent();
            this.mSettings.writeLPr();
        }
        Iterator it5 = freezers.iterator();
        while (it5.hasNext()) {
            ((PackageFreezer) it5.next()).close();
        }
        if (DEBUG_INSTALL) {
            String str2 = TAG;
            StringBuilder stringBuilder4 = new StringBuilder();
            stringBuilder4.append("Loaded packages ");
            stringBuilder4.append(loaded);
            Slog.d(str2, stringBuilder4.toString());
        }
        sendResourcesChangedBroadcast(true, false, loaded, null);
        this.mLoadedVolumes.add(vol.getId());
    }

    private void unloadPrivatePackages(final VolumeInfo vol) {
        this.mHandler.post(new Runnable() {
            public void run() {
                PackageManagerService.this.unloadPrivatePackagesInner(vol);
            }
        });
    }

    /* JADX WARNING: Removed duplicated region for block: B:66:0x0103 A:{SYNTHETIC, Splitter:B:66:0x0103} */
    /* JADX WARNING: Removed duplicated region for block: B:66:0x0103 A:{SYNTHETIC, Splitter:B:66:0x0103} */
    /* JADX WARNING: Removed duplicated region for block: B:66:0x0103 A:{SYNTHETIC, Splitter:B:66:0x0103} */
    /* JADX WARNING: Removed duplicated region for block: B:66:0x0103 A:{SYNTHETIC, Splitter:B:66:0x0103} */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void unloadPrivatePackagesInner(VolumeInfo vol) {
        Throwable th;
        Throwable th2;
        PackageFreezer freezer;
        Throwable th3;
        ApplicationInfo applicationInfo;
        String volumeUuid = vol.fsUuid;
        if (TextUtils.isEmpty(volumeUuid)) {
            Slog.e(TAG, "Unloading internal storage is probably a mistake; ignoring");
            return;
        }
        IIntentReceiver iIntentReceiver;
        ArrayList<ApplicationInfo> unloaded = new ArrayList();
        synchronized (this.mInstallLock) {
            synchronized (this.mPackages) {
                List<PackageSetting> packages;
                List<PackageSetting> packages2 = this.mSettings.getVolumePackagesLPr(volumeUuid);
                for (PackageSetting ps : packages2) {
                    if (ps.pkg != null) {
                        ApplicationInfo info = ps.pkg.applicationInfo;
                        PackageRemovedInfo outInfo = new PackageRemovedInfo(this);
                        PackageFreezer freezer2 = freezePackageForDelete(ps.name, 1, "unloadPrivatePackagesInner");
                        PackageSetting ps2;
                        try {
                            PackageFreezer freezer3 = freezer2;
                            ApplicationInfo info2 = info;
                            PackageSetting ps3 = ps;
                            packages = packages2;
                            try {
                                if (deletePackageLIF(ps.name, null, false, null, 1, outInfo, false, null)) {
                                    try {
                                        unloaded.add(info2);
                                        ps2 = ps3;
                                    } catch (Throwable th4) {
                                        th2 = th4;
                                        freezer = freezer3;
                                        ps2 = ps3;
                                        th3 = null;
                                        if (freezer != null) {
                                        }
                                        throw th2;
                                    }
                                }
                                String str;
                                StringBuilder stringBuilder;
                                try {
                                    str = TAG;
                                    stringBuilder = new StringBuilder();
                                    stringBuilder.append("Failed to unload ");
                                    ps2 = ps3;
                                } catch (Throwable th5) {
                                    th2 = th5;
                                    freezer = freezer3;
                                    ps2 = ps3;
                                    th3 = null;
                                    if (freezer != null) {
                                    }
                                    throw th2;
                                }
                                try {
                                    stringBuilder.append(ps2.codePath);
                                    Slog.w(str, stringBuilder.toString());
                                } catch (Throwable th6) {
                                    th2 = th6;
                                    freezer = freezer3;
                                    th3 = null;
                                    if (freezer != null) {
                                        $closeResource(th3, freezer);
                                    }
                                    throw th2;
                                }
                                freezer = freezer3;
                                if (freezer != null) {
                                    $closeResource(null, freezer);
                                }
                                AttributeCache.instance().removePackage(ps2.name);
                                packages2 = packages;
                            } catch (Throwable th7) {
                                th2 = th7;
                                freezer = freezer3;
                                applicationInfo = info2;
                                ps2 = ps3;
                                th3 = null;
                                if (freezer != null) {
                                }
                                throw th2;
                            }
                        } catch (Throwable th8) {
                            th2 = th8;
                            freezer = freezer2;
                            applicationInfo = info;
                            ps2 = ps;
                            th3 = null;
                            packages = packages2;
                            if (freezer != null) {
                            }
                            throw th2;
                        }
                    }
                }
                iIntentReceiver = null;
                packages = packages2;
                this.mSettings.writeLPr();
            }
        }
        if (DEBUG_INSTALL) {
            String str2 = TAG;
            StringBuilder stringBuilder2 = new StringBuilder();
            stringBuilder2.append("Unloaded packages ");
            stringBuilder2.append(unloaded);
            Slog.d(str2, stringBuilder2.toString());
        }
        int i = 0;
        sendResourcesChangedBroadcast(false, false, unloaded, iIntentReceiver);
        this.mLoadedVolumes.remove(vol.getId());
        ResourcesManager.getInstance().invalidatePath(vol.getPath().getAbsolutePath());
        while (i < 3) {
            System.gc();
            System.runFinalization();
            i++;
        }
    }

    private void assertPackageKnown(String volumeUuid, String packageName) throws PackageManagerException {
        synchronized (this.mPackages) {
            packageName = normalizePackageNameLPr(packageName);
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            StringBuilder stringBuilder;
            if (ps == null) {
                stringBuilder = new StringBuilder();
                stringBuilder.append("Package ");
                stringBuilder.append(packageName);
                stringBuilder.append(" is unknown");
                throw new PackageManagerException(stringBuilder.toString());
            } else if (TextUtils.equals(volumeUuid, ps.volumeUuid)) {
            } else {
                stringBuilder = new StringBuilder();
                stringBuilder.append("Package ");
                stringBuilder.append(packageName);
                stringBuilder.append(" found on unknown volume ");
                stringBuilder.append(volumeUuid);
                stringBuilder.append("; expected volume ");
                stringBuilder.append(ps.volumeUuid);
                throw new PackageManagerException(stringBuilder.toString());
            }
        }
    }

    private void assertPackageKnownAndInstalled(String volumeUuid, String packageName, int userId) throws PackageManagerException {
        synchronized (this.mPackages) {
            packageName = normalizePackageNameLPr(packageName);
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            StringBuilder stringBuilder;
            if (ps == null) {
                stringBuilder = new StringBuilder();
                stringBuilder.append("Package ");
                stringBuilder.append(packageName);
                stringBuilder.append(" is unknown");
                throw new PackageManagerException(stringBuilder.toString());
            } else if (!TextUtils.equals(volumeUuid, ps.volumeUuid)) {
                stringBuilder = new StringBuilder();
                stringBuilder.append("Package ");
                stringBuilder.append(packageName);
                stringBuilder.append(" found on unknown volume ");
                stringBuilder.append(volumeUuid);
                stringBuilder.append("; expected volume ");
                stringBuilder.append(ps.volumeUuid);
                throw new PackageManagerException(stringBuilder.toString());
            } else if (ps.getInstalled(userId)) {
            } else {
                stringBuilder = new StringBuilder();
                stringBuilder.append("Package ");
                stringBuilder.append(packageName);
                stringBuilder.append(" not installed for user ");
                stringBuilder.append(userId);
                throw new PackageManagerException(stringBuilder.toString());
            }
        }
    }

    private List<String> collectAbsoluteCodePaths() {
        List<String> codePaths;
        synchronized (this.mPackages) {
            codePaths = new ArrayList();
            int packageCount = this.mSettings.mPackages.size();
            for (int i = 0; i < packageCount; i++) {
                codePaths.add(((PackageSetting) this.mSettings.mPackages.valueAt(i)).codePath.getAbsolutePath());
            }
        }
        return codePaths;
    }

    private void reconcileApps(String volumeUuid) {
        int filesToDelete;
        int i;
        List<String> absoluteCodePaths = collectAbsoluteCodePaths();
        int i2 = 0;
        List<File> filesToDelete2 = null;
        for (File file : FileUtils.listFilesOrEmpty(Environment.getDataAppDirectory(volumeUuid))) {
            boolean isPackage = (PackageParser.isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName());
            if (isPackage) {
                String absolutePath = file.getAbsolutePath();
                boolean pathValid = false;
                int absoluteCodePathCount = absoluteCodePaths.size();
                for (int i3 = 0; i3 < absoluteCodePathCount; i3++) {
                    if (absolutePath.startsWith((String) absoluteCodePaths.get(i3))) {
                        pathValid = true;
                        break;
                    }
                }
                if (!pathValid) {
                    if (filesToDelete2 == null) {
                        filesToDelete2 = new ArrayList();
                    }
                    filesToDelete2.add(file);
                }
            }
        }
        if (filesToDelete2 != null) {
            filesToDelete = filesToDelete2.size();
            while (true) {
                i = i2;
                if (i < filesToDelete) {
                    File fileToDelete = (File) filesToDelete2.get(i);
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("Destroying orphaned");
                    stringBuilder.append(fileToDelete);
                    PackageManagerServiceUtils.logCriticalInfo(5, stringBuilder.toString());
                    synchronized (this.mInstallLock) {
                        removeCodePathLI(fileToDelete);
                    }
                    i2 = i + 1;
                } else {
                    return;
                }
            }
        }
    }

    void reconcileAppsData(int userId, int flags, boolean migrateAppsData) {
        for (VolumeInfo vol : ((StorageManager) this.mContext.getSystemService(StorageManager.class)).getWritablePrivateVolumes()) {
            String volumeUuid = vol.getFsUuid();
            synchronized (this.mInstallLock) {
                reconcileAppsDataLI(volumeUuid, userId, flags, migrateAppsData);
            }
        }
    }

    private void reconcileAppsDataLI(String volumeUuid, int userId, int flags, boolean migrateAppData) {
        reconcileAppsDataLI(volumeUuid, userId, flags, migrateAppData, false);
    }

    private List<String> reconcileAppsDataLI(String volumeUuid, int userId, int flags, boolean migrateAppData, boolean onlyCoreApps) {
        int i;
        StringBuilder stringBuilder;
        int i2;
        int i3;
        File[] files;
        File ceDir;
        int ceDir2;
        File deDir;
        InstallerException e2;
        int i4;
        File[] files2;
        String str = volumeUuid;
        int i5 = userId;
        int i6 = flags;
        boolean z = migrateAppData;
        String str2 = TAG;
        StringBuilder stringBuilder2 = new StringBuilder();
        stringBuilder2.append("reconcileAppsData for ");
        stringBuilder2.append(str);
        stringBuilder2.append(" u");
        stringBuilder2.append(i5);
        stringBuilder2.append(" 0x");
        stringBuilder2.append(Integer.toHexString(flags));
        stringBuilder2.append(" migrateAppData=");
        stringBuilder2.append(z);
        Slog.v(str2, stringBuilder2.toString());
        ArrayList result = onlyCoreApps ? new ArrayList() : null;
        File ceDir3 = Environment.getDataUserCeDirectory(volumeUuid, userId);
        File deDir2 = Environment.getDataUserDeDirectory(volumeUuid, userId);
        if ((i6 & 2) != 0) {
            if (!StorageManager.isFileEncryptedNativeOrEmulated() || StorageManager.isUserKeyUnlocked(userId)) {
                File[] files3 = FileUtils.listFilesOrEmpty(ceDir3);
                int length = files3.length;
                i = 0;
                while (i < length) {
                    File file = files3[i];
                    File deDir3 = deDir2;
                    String packageName = file.getName();
                    if (!(this.mIsUpgrade && this.mCustPms != null && this.mCustPms.isListedApp(packageName) == 1)) {
                        try {
                            assertPackageKnownAndInstalled(str, packageName, i5);
                        } catch (PackageManagerException e) {
                            PackageManagerException e3 = e;
                            if (this.mIsUpgrade && this.mCustPms != null && this.mCustPms.isListedApp(packageName) == 1) {
                                str2 = TAG;
                                StringBuilder stringBuilder3 = new StringBuilder();
                                stringBuilder3.append("Skip destroy ");
                                stringBuilder3.append(file);
                                stringBuilder3.append(" due to: ");
                                stringBuilder3.append(packageName);
                                Slog.w(str2, stringBuilder3.toString());
                            } else {
                                stringBuilder = new StringBuilder();
                                stringBuilder.append("Destroying ");
                                stringBuilder.append(file);
                                stringBuilder.append(" due to: ");
                                PackageManagerException e4 = e3;
                                stringBuilder.append(e4);
                                PackageManagerServiceUtils.logCriticalInfo(5, stringBuilder.toString());
                                try {
                                    i2 = i;
                                    i3 = length;
                                    files = files3;
                                    ceDir = ceDir3;
                                    ceDir2 = 5;
                                    deDir = deDir3;
                                    String deDir4 = packageName;
                                    try {
                                        this.mInstaller.destroyAppData(str, packageName, i5, 2, 0);
                                    } catch (InstallerException e5) {
                                        e2 = e5;
                                    }
                                } catch (InstallerException e6) {
                                    e2 = e6;
                                    File file2 = file;
                                    i2 = i;
                                    i3 = length;
                                    files = files3;
                                    PackageManagerException packageManagerException = e4;
                                    ceDir = ceDir3;
                                    deDir = deDir3;
                                    ceDir2 = 5;
                                    stringBuilder2 = new StringBuilder();
                                    stringBuilder2.append("Failed to destroy: ");
                                    stringBuilder2.append(e2);
                                    PackageManagerServiceUtils.logCriticalInfo(ceDir2, stringBuilder2.toString());
                                    i = i2 + 1;
                                    length = i3;
                                    files3 = files;
                                    ceDir3 = ceDir;
                                    deDir2 = deDir;
                                }
                            }
                        }
                    }
                    i2 = i;
                    i3 = length;
                    files = files3;
                    ceDir = ceDir3;
                    deDir = deDir3;
                    i = i2 + 1;
                    length = i3;
                    files3 = files;
                    ceDir3 = ceDir;
                    deDir2 = deDir;
                }
            } else {
                stringBuilder2 = new StringBuilder();
                stringBuilder2.append("Yikes, someone asked us to reconcile CE storage while ");
                stringBuilder2.append(i5);
                stringBuilder2.append(" was still locked; this would have caused massive data loss!");
                throw new RuntimeException(stringBuilder2.toString());
            }
        }
        deDir = deDir2;
        ceDir = ceDir3;
        ceDir3 = 5;
        if ((i6 & 1) != 0) {
            deDir2 = deDir;
            File[] files4 = FileUtils.listFilesOrEmpty(deDir2);
            int length2 = files4.length;
            int i7 = 0;
            while (i7 < length2) {
                File file3 = files4[i7];
                String packageName2 = file3.getName();
                try {
                    assertPackageKnownAndInstalled(str, packageName2, i5);
                    i4 = i7;
                    i2 = length2;
                    files2 = files4;
                    i = ceDir3;
                    ceDir3 = deDir2;
                } catch (PackageManagerException e7) {
                    PackageManagerException e8 = e7;
                    stringBuilder = new StringBuilder();
                    stringBuilder.append("Destroying ");
                    stringBuilder.append(file3);
                    stringBuilder.append(" due to: ");
                    stringBuilder.append(e8);
                    PackageManagerServiceUtils.logCriticalInfo(5, stringBuilder.toString());
                    try {
                        i4 = i7;
                        i2 = length2;
                        ceDir3 = deDir2;
                        files2 = files4;
                        try {
                            this.mInstaller.destroyAppData(str, packageName2, i5, 1, 0);
                            i = 5;
                        } catch (InstallerException e9) {
                            e2 = e9;
                            stringBuilder2 = new StringBuilder();
                            stringBuilder2.append("Failed to destroy: ");
                            stringBuilder2.append(e2);
                            i = 5;
                            PackageManagerServiceUtils.logCriticalInfo(5, stringBuilder2.toString());
                            i7 = i4 + 1;
                            deDir2 = ceDir3;
                            length2 = i2;
                            files4 = files2;
                            ceDir3 = i;
                        }
                    } catch (InstallerException e10) {
                        e2 = e10;
                        PackageManagerException packageManagerException2 = e8;
                        String str3 = packageName2;
                        File file4 = file3;
                        i4 = i7;
                        i2 = length2;
                        ceDir3 = deDir2;
                        files2 = files4;
                        stringBuilder2 = new StringBuilder();
                        stringBuilder2.append("Failed to destroy: ");
                        stringBuilder2.append(e2);
                        i = 5;
                        PackageManagerServiceUtils.logCriticalInfo(5, stringBuilder2.toString());
                        i7 = i4 + 1;
                        deDir2 = ceDir3;
                        length2 = i2;
                        files4 = files2;
                        ceDir3 = i;
                    }
                }
                i7 = i4 + 1;
                deDir2 = ceDir3;
                length2 = i2;
                files4 = files2;
                ceDir3 = i;
            }
        }
        synchronized (this.mPackages) {
            List<PackageSetting> packages = this.mSettings.getVolumePackagesLPr(str);
        }
        if ((i6 & 2) != 0) {
            try {
                UniPerf.getInstance().uniPerfEvent(4099, BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS, new int[0]);
            } catch (RuntimeException e11) {
                Slog.v(TAG, "raise cpu error!");
            }
        }
        int preparedCount = 0;
        for (PackageSetting ps : packages) {
            String packageName3 = ps.name;
            if (ps.pkg == null) {
                String str4 = TAG;
                StringBuilder stringBuilder4 = new StringBuilder();
                stringBuilder4.append("Odd, missing scanned package ");
                stringBuilder4.append(packageName3);
                Slog.w(str4, stringBuilder4.toString());
            } else if (onlyCoreApps && !ps.pkg.coreApp) {
                result.add(packageName3);
            } else if (ps.getInstalled(i5)) {
                prepareAppDataAndMigrateLIF(ps.pkg, i5, i6, z);
                preparedCount++;
            }
        }
        String str5 = TAG;
        StringBuilder stringBuilder5 = new StringBuilder();
        stringBuilder5.append("reconcileAppsData finished ");
        stringBuilder5.append(preparedCount);
        stringBuilder5.append(" packages");
        Slog.v(str5, stringBuilder5.toString());
        return result;
    }

    protected void prepareAppDataAfterInstallLIF(Package pkg) {
        PackageSetting ps;
        synchronized (this.mPackages) {
            ps = (PackageSetting) this.mSettings.mPackages.get(pkg.packageName);
            this.mSettings.writeKernelMappingLPr(ps);
        }
        UserManager um = (UserManager) this.mContext.getSystemService(UserManager.class);
        UserManagerInternal umInternal = getUserManagerInternal();
        for (UserInfo user : um.getUsers()) {
            int flags;
            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
                flags = 3;
            } else if (umInternal.isUserRunning(user.id)) {
                flags = 1;
            }
            if (ps != null && ps.getInstalled(user.id)) {
                prepareAppDataLIF(pkg, user.id, flags);
            }
        }
    }

    private void prepareAppDataLIF(Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        prepareAppDataLeafLIF(pkg, userId, flags);
        int i = 0;
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        while (i < childCount) {
            prepareAppDataLeafLIF((Package) pkg.childPackages.get(i), userId, flags);
            i++;
        }
    }

    private void prepareAppDataAndMigrateLIF(Package pkg, int userId, int flags, boolean maybeMigrateAppData) {
        prepareAppDataLIF(pkg, userId, flags);
        if (maybeMigrateAppData && maybeMigrateAppDataLIF(pkg, userId)) {
            prepareAppDataLIF(pkg, userId, flags);
        }
    }

    private void prepareAppDataLeafLIF(Package pkg, int userId, int flags) {
        PackageSetting ps;
        ApplicationInfo app;
        long ceDataInode;
        Package packageR = pkg;
        int i = userId;
        synchronized (this.mPackages) {
            ps = (PackageSetting) this.mSettings.mPackages.get(packageR.packageName);
        }
        String volumeUuid = packageR.volumeUuid;
        String packageName = packageR.packageName;
        if (ps == null) {
            app = packageR.applicationInfo;
        } else {
            app = PackageParser.generateApplicationInfo(packageR, 0, ps.readUserState(i), i);
        }
        if (app == null) {
            app = packageR.applicationInfo;
        }
        ApplicationInfo app2 = app;
        int appId = UserHandle.getAppId(app2.uid);
        Preconditions.checkNotNull(app2.seInfo);
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(app2.seInfo);
        stringBuilder.append(app2.seInfoUser != null ? app2.seInfoUser : BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS);
        long ceDataInode2 = -1;
        try {
            ceDataInode = this.mInstaller.createAppData(volumeUuid, packageName, i, flags, appId, stringBuilder.toString(), app2.targetSdkVersion);
        } catch (InstallerException e) {
            String str = TAG;
            StringBuilder stringBuilder2 = new StringBuilder();
            stringBuilder2.append("Failed to create app data for ");
            stringBuilder2.append(packageName);
            stringBuilder2.append(": ");
            stringBuilder2.append(e);
            Slog.e(str, stringBuilder2.toString());
            ceDataInode = ceDataInode2;
        }
        if (this.mIsUpgrade || this.mFirstBoot || i != 0) {
            this.mArtManagerService.prepareAppProfiles(packageR, i);
        }
        if (!((flags & 2) == 0 || ceDataInode == -1)) {
            synchronized (this.mPackages) {
                if (ps != null) {
                    try {
                        ps.setCeDataInode(ceDataInode, i);
                    } catch (Throwable th) {
                    }
                }
            }
        }
        prepareAppDataContentsLeafLIF(pkg, userId, flags);
    }

    private void prepareAppDataContentsLIF(Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        prepareAppDataContentsLeafLIF(pkg, userId, flags);
        int i = 0;
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        while (i < childCount) {
            prepareAppDataContentsLeafLIF((Package) pkg.childPackages.get(i), userId, flags);
            i++;
        }
    }

    private void prepareAppDataContentsLeafLIF(Package pkg, int userId, int flags) {
        String volumeUuid = pkg.volumeUuid;
        String packageName = pkg.packageName;
        ApplicationInfo app = pkg.applicationInfo;
        if ((flags & 2) != 0 && app.primaryCpuAbi != null && !VMRuntime.is64BitAbi(app.primaryCpuAbi)) {
            try {
                this.mInstaller.linkNativeLibraryDirectory(volumeUuid, packageName, app.nativeLibraryDir, userId);
            } catch (InstallerException e) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Failed to link native for ");
                stringBuilder.append(packageName);
                stringBuilder.append(": ");
                stringBuilder.append(e);
                Slog.e(str, stringBuilder.toString());
            }
        }
    }

    private boolean maybeMigrateAppDataLIF(Package pkg, int userId) {
        if (!pkg.isSystem() || StorageManager.isFileEncryptedNativeOrEmulated()) {
            return false;
        }
        try {
            this.mInstaller.migrateAppData(pkg.volumeUuid, pkg.packageName, userId, pkg.applicationInfo.isDefaultToDeviceProtectedStorage() ? 1 : 2);
        } catch (InstallerException e) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Failed to migrate ");
            stringBuilder.append(pkg.packageName);
            stringBuilder.append(": ");
            stringBuilder.append(e.getMessage());
            PackageManagerServiceUtils.logCriticalInfo(5, stringBuilder.toString());
        }
        return true;
    }

    public PackageFreezer freezePackage(String packageName, String killReason) {
        return freezePackage(packageName, -1, killReason);
    }

    public PackageFreezer freezePackage(String packageName, int userId, String killReason) {
        return new PackageFreezer(packageName, userId, killReason);
    }

    public PackageFreezer freezePackageForInstall(String packageName, int installFlags, String killReason) {
        return freezePackageForInstall(packageName, -1, installFlags, killReason);
    }

    public PackageFreezer freezePackageForInstall(String packageName, int userId, int installFlags, String killReason) {
        if ((installFlags & 4096) != 0) {
            return new PackageFreezer();
        }
        return freezePackage(packageName, userId, killReason);
    }

    public PackageFreezer freezePackageForDelete(String packageName, int deleteFlags, String killReason) {
        return freezePackageForDelete(packageName, -1, deleteFlags, killReason);
    }

    public PackageFreezer freezePackageForDelete(String packageName, int userId, int deleteFlags, String killReason) {
        if ((deleteFlags & 8) != 0) {
            return new PackageFreezer();
        }
        return freezePackage(packageName, userId, killReason);
    }

    private void checkPackageFrozen(String packageName) {
        synchronized (this.mPackages) {
            if (!this.mFrozenPackages.contains(packageName)) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Expected ");
                stringBuilder.append(packageName);
                stringBuilder.append(" to be frozen!");
                Slog.wtf(str, stringBuilder.toString(), new Throwable());
            }
        }
    }

    public int movePackage(String packageName, String volumeUuid) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOVE_PACKAGE", null);
        int callingUid = Binder.getCallingUid();
        final UserHandle user = new UserHandle(UserHandle.getUserId(callingUid));
        int moveId = this.mNextMoveId.getAndIncrement();
        final String str = packageName;
        final String str2 = volumeUuid;
        final int i = moveId;
        final int i2 = callingUid;
        this.mHandler.post(new Runnable() {
            public void run() {
                try {
                    PackageManagerService.this.movePackageInternal(str, str2, i, i2, user);
                } catch (PackageManagerException e) {
                    String str = PackageManagerService.TAG;
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("Failed to move ");
                    stringBuilder.append(str);
                    Slog.w(str, stringBuilder.toString(), e);
                    PackageManagerService.this.mMoveCallbacks.notifyStatusChanged(i, e.error);
                }
            }
        });
        return moveId;
    }

    /* JADX WARNING: Removed duplicated region for block: B:144:0x03a5 A:{Catch:{ all -> 0x03f8, all -> 0x0400 }} */
    /* JADX WARNING: Removed duplicated region for block: B:39:0x00b4 A:{Catch:{ all -> 0x03f8, all -> 0x0400 }} */
    /* JADX WARNING: Missing block: B:52:0x011a, code skipped:
            r33 = r5;
            r26 = r8;
            r8 = new android.os.Bundle();
            r8.putString("android.intent.extra.PACKAGE_NAME", r12);
            r8.putString("android.intent.extra.TITLE", r3);
            com.android.server.pm.PackageManagerService.MoveCallbacks.access$6900(r15.mMoveCallbacks, r10, r8);
     */
    /* JADX WARNING: Missing block: B:53:0x0139, code skipped:
            if (java.util.Objects.equals(android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL, r11) == null) goto L_0x0147;
     */
    /* JADX WARNING: Missing block: B:54:0x013b, code skipped:
            r0 = 16;
     */
    /* JADX WARNING: Missing block: B:55:0x013d, code skipped:
            if (r33 != false) goto L_0x0141;
     */
    /* JADX WARNING: Missing block: B:56:0x013f, code skipped:
            r5 = true;
     */
    /* JADX WARNING: Missing block: B:57:0x0141, code skipped:
            r5 = false;
     */
    /* JADX WARNING: Missing block: B:58:0x0142, code skipped:
            r17 = android.os.Environment.getDataAppDirectory(r50);
     */
    /* JADX WARNING: Missing block: B:60:0x014e, code skipped:
            if (java.util.Objects.equals("primary_physical", r11) == null) goto L_0x0160;
     */
    /* JADX WARNING: Missing block: B:61:0x0150, code skipped:
            r0 = 8;
            r5 = false;
            r17 = r13.getPrimaryPhysicalVolume().getPath();
     */
    /* JADX WARNING: Missing block: B:62:0x015b, code skipped:
            r18 = r0;
     */
    /* JADX WARNING: Missing block: B:63:0x015d, code skipped:
            r34 = r5;
     */
    /* JADX WARNING: Missing block: B:64:0x0160, code skipped:
            r0 = r13.findVolumeByUuid(r11);
     */
    /* JADX WARNING: Missing block: B:65:0x0166, code skipped:
            if (r15.mCustPms == null) goto L_0x017a;
     */
    /* JADX WARNING: Missing block: B:67:0x016e, code skipped:
            if (r15.mCustPms.canAppMoveToPublicSd(r0) == false) goto L_0x017a;
     */
    /* JADX WARNING: Missing block: B:68:0x0170, code skipped:
            r1 = 8;
            r5 = false;
            r17 = r0.getPath();
     */
    /* JADX WARNING: Missing block: B:69:0x0177, code skipped:
            r18 = r1;
     */
    /* JADX WARNING: Missing block: B:70:0x017a, code skipped:
            if (r0 == null) goto L_0x037b;
     */
    /* JADX WARNING: Missing block: B:72:0x0180, code skipped:
            if (r0.getType() != 1) goto L_0x037b;
     */
    /* JADX WARNING: Missing block: B:74:0x0186, code skipped:
            if (r0.isMountedWritable() == false) goto L_0x037b;
     */
    /* JADX WARNING: Missing block: B:75:0x0188, code skipped:
            if (r33 != false) goto L_0x018c;
     */
    /* JADX WARNING: Missing block: B:76:0x018a, code skipped:
            r1 = true;
     */
    /* JADX WARNING: Missing block: B:77:0x018c, code skipped:
            r1 = false;
     */
    /* JADX WARNING: Missing block: B:78:0x018d, code skipped:
            com.android.internal.util.Preconditions.checkState(r1);
            r1 = 16;
            r5 = true;
            r17 = android.os.Environment.getDataAppDirectory(r50);
     */
    /* JADX WARNING: Missing block: B:79:0x0198, code skipped:
            r5 = r17;
     */
    /* JADX WARNING: Missing block: B:80:0x019a, code skipped:
            if (r34 == false) goto L_0x01d9;
     */
    /* JADX WARNING: Missing block: B:81:0x019c, code skipped:
            r0 = r2.length;
            r1 = 0;
     */
    /* JADX WARNING: Missing block: B:82:0x019e, code skipped:
            if (r1 >= r0) goto L_0x01d9;
     */
    /* JADX WARNING: Missing block: B:83:0x01a0, code skipped:
            r4 = r2[r1];
     */
    /* JADX WARNING: Missing block: B:84:0x01a6, code skipped:
            if (android.os.storage.StorageManager.isFileEncryptedNativeOrEmulated() == false) goto L_0x01d3;
     */
    /* JADX WARNING: Missing block: B:86:0x01ac, code skipped:
            if (android.os.storage.StorageManager.isUserKeyUnlocked(r4) == false) goto L_0x01b1;
     */
    /* JADX WARNING: Missing block: B:87:0x01b1, code skipped:
            r1 = new java.lang.StringBuilder();
            r39 = r3;
            r1.append("User ");
            r1.append(r4);
            r1.append(" must be unlocked");
     */
    /* JADX WARNING: Missing block: B:88:0x01d0, code skipped:
            throw new com.android.server.pm.PackageManagerException(-10, r1.toString());
     */
    /* JADX WARNING: Missing block: B:89:0x01d3, code skipped:
            r1 = r1 + 1;
            r3 = r3;
     */
    /* JADX WARNING: Missing block: B:90:0x01d9, code skipped:
            r39 = r3;
            r4 = new android.content.pm.PackageStats(null, -1);
            r1 = r15.mInstaller;
     */
    /* JADX WARNING: Missing block: B:91:0x01e5, code skipped:
            monitor-enter(r1);
     */
    /* JADX WARNING: Missing block: B:93:?, code skipped:
            r0 = r2.length;
     */
    /* JADX WARNING: Missing block: B:94:0x01e7, code skipped:
            r3 = 0;
     */
    /* JADX WARNING: Missing block: B:95:0x01e8, code skipped:
            if (r3 >= r0) goto L_0x0233;
     */
    /* JADX WARNING: Missing block: B:97:?, code skipped:
            r41 = r0;
            r0 = r2[r3];
     */
    /* JADX WARNING: Missing block: B:98:0x01f6, code skipped:
            if (getPackageSizeInfoLI(r12, r0, r4) == false) goto L_0x01fd;
     */
    /* JADX WARNING: Missing block: B:99:0x01f8, code skipped:
            r3 = r3 + 1;
            r0 = r41;
     */
    /* JADX WARNING: Missing block: B:100:0x01fd, code skipped:
            r14.close();
            r42 = r0;
     */
    /* JADX WARNING: Missing block: B:101:0x0206, code skipped:
            r43 = r2;
     */
    /* JADX WARNING: Missing block: B:104:0x020c, code skipped:
            throw new com.android.server.pm.PackageManagerException(-6, "Failed to measure package size");
     */
    /* JADX WARNING: Missing block: B:105:0x020d, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:106:0x020e, code skipped:
            r42 = r4;
            r47 = r9;
            r7 = r11;
            r4 = r13;
            r2 = r14;
            r9 = r15;
            r38 = r39;
            r37 = r43;
            r39 = r5;
            r43 = r8;
     */
    /* JADX WARNING: Missing block: B:107:0x0220, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:108:0x0221, code skipped:
            r37 = r2;
            r42 = r4;
            r43 = r8;
            r47 = r9;
            r7 = r11;
            r4 = r13;
            r2 = r14;
            r9 = r15;
            r38 = r39;
            r39 = r5;
     */
    /* JADX WARNING: Missing block: B:109:0x0233, code skipped:
            r43 = r2;
     */
    /* JADX WARNING: Missing block: B:111:?, code skipped:
            monitor-exit(r1);
     */
    /* JADX WARNING: Missing block: B:113:0x0238, code skipped:
            if (DEBUG_INSTALL == null) goto L_0x025c;
     */
    /* JADX WARNING: Missing block: B:114:0x023a, code skipped:
            r0 = TAG;
            r1 = new java.lang.StringBuilder();
            r1.append("Measured code size ");
            r1.append(r4.codeSize);
            r1.append(", data size ");
            r1.append(r4.dataSize);
            android.util.Slog.d(r0, r1.toString());
     */
    /* JADX WARNING: Missing block: B:115:0x025c, code skipped:
            r35 = r5.getUsableSpace();
     */
    /* JADX WARNING: Missing block: B:116:0x0260, code skipped:
            if (r34 == false) goto L_0x0268;
     */
    /* JADX WARNING: Missing block: B:117:0x0262, code skipped:
            r0 = r4.codeSize + r4.dataSize;
     */
    /* JADX WARNING: Missing block: B:118:0x0268, code skipped:
            r0 = r4.codeSize;
     */
    /* JADX WARNING: Missing block: B:119:0x026a, code skipped:
            r40 = r0;
     */
    /* JADX WARNING: Missing block: B:120:0x0272, code skipped:
            if (r40 > r13.getStorageBytesUntilLow(r5)) goto L_0x0335;
     */
    /* JADX WARNING: Missing block: B:121:0x0274, code skipped:
            com.android.server.pm.PackageManagerService.MoveCallbacks.access$6800(r15.mMoveCallbacks, r10, 10);
            r0 = new java.util.concurrent.CountDownLatch(1);
            r3 = r14;
            r14 = new com.android.server.pm.PackageManagerService.AnonymousClass31(r15);
     */
    /* JADX WARNING: Missing block: B:122:0x0288, code skipped:
            if (r34 == false) goto L_0x02c7;
     */
    /* JADX WARNING: Missing block: B:123:0x028a, code skipped:
            r44 = r13;
            r37 = r43;
            r13 = r1;
            r45 = r3;
            r38 = r39;
            r3 = r0;
            r42 = r4;
            r4 = r35;
            r46 = r14;
            r14 = r6;
            r6 = r5;
            r43 = r8;
            r7 = r40;
            r47 = r9;
            r9 = r10;
            r1 = new com.android.server.pm.PackageManagerService.AnonymousClass32(r15);
            r13.start();
            r13 = new com.android.server.pm.PackageManagerService.MoveInfo(r10, r26, r11, r12, r14.getName(), r30, r31, r32);
     */
    /* JADX WARNING: Missing block: B:124:0x02c7, code skipped:
            r45 = r3;
            r42 = r4;
            r47 = r9;
            r44 = r13;
            r46 = r14;
            r38 = r39;
            r37 = r43;
            r39 = r5;
            r14 = r6;
            r43 = r8;
            r13 = null;
     */
    /* JADX WARNING: Missing block: B:125:0x02db, code skipped:
            r4 = r44;
            r1 = r18 | 2;
            r2 = r15.mHandler.obtainMessage(5);
            r7 = r11;
            r9 = r15;
            r6 = r14;
            r14 = r46;
            r10 = new com.android.server.pm.PackageManagerService.InstallParams(r15, com.android.server.pm.PackageManagerService.OriginInfo.fromExistingFile(r14), r13, r14, r1, r16, r7, null, r53, r20, null, android.content.pm.PackageParser.SigningDetails.UNKNOWN, 0);
            r10.setTraceMethod("movePackage").setTraceCookie(java.lang.System.identityHashCode(r10));
            r2.obj = r10;
            android.os.Trace.asyncTraceBegin(262144, "movePackage", java.lang.System.identityHashCode(r2.obj));
            android.os.Trace.asyncTraceBegin(262144, "queueInstall", java.lang.System.identityHashCode(r2.obj));
            r9.mHandler.sendMessage(r2);
     */
    /* JADX WARNING: Missing block: B:126:0x0334, code skipped:
            return;
     */
    /* JADX WARNING: Missing block: B:127:0x0335, code skipped:
            r42 = r4;
            r47 = r9;
            r7 = r11;
            r4 = r13;
            r9 = r15;
            r38 = r39;
            r37 = r43;
            r39 = r5;
            r43 = r8;
            r14.close();
     */
    /* JADX WARNING: Missing block: B:128:0x0353, code skipped:
            throw new com.android.server.pm.PackageManagerException(-6, "Not enough free space to move");
     */
    /* JADX WARNING: Missing block: B:129:0x0354, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:130:0x0355, code skipped:
            r42 = r4;
            r47 = r9;
            r7 = r11;
            r4 = r13;
            r2 = r14;
            r9 = r15;
            r38 = r39;
            r37 = r43;
            r39 = r5;
            r43 = r8;
     */
    /* JADX WARNING: Missing block: B:131:0x0366, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:132:0x0367, code skipped:
            r37 = r2;
            r42 = r4;
            r43 = r8;
            r47 = r9;
            r7 = r11;
            r4 = r13;
            r2 = r14;
            r9 = r15;
            r38 = r39;
            r39 = r5;
     */
    /* JADX WARNING: Missing block: B:134:?, code skipped:
            monitor-exit(r1);
     */
    /* JADX WARNING: Missing block: B:135:0x0378, code skipped:
            throw r0;
     */
    /* JADX WARNING: Missing block: B:136:0x0379, code skipped:
            r0 = th;
     */
    /* JADX WARNING: Missing block: B:138:0x037b, code skipped:
            r37 = r2;
            r38 = r3;
            r43 = r8;
            r47 = r9;
            r7 = r11;
            r4 = r13;
            r9 = r15;
            r14.close();
     */
    /* JADX WARNING: Missing block: B:139:0x0392, code skipped:
            throw new com.android.server.pm.PackageManagerException(true, "Move location not mounted private volume");
     */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void movePackageInternal(String packageName, String volumeUuid, int moveId, int callingUid, UserHandle user) throws PackageManagerException {
        Throwable th;
        String str = packageName;
        String str2 = volumeUuid;
        final int i = moveId;
        StorageManager storage = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        PackageManager pm = this.mContext.getPackageManager();
        synchronized (this.mPackages) {
            PackageManager packageManager;
            String str3;
            StorageManager storageManager;
            Package pkg = (Package) this.mPackages.get(str);
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(str);
            if (!(pkg == null || ps == null)) {
                if (!filterAppAccessLPr(ps, callingUid, user.getIdentifier())) {
                    if (pkg.applicationInfo.isSystemApp()) {
                        packageManager = pm;
                        str3 = str2;
                        storageManager = storage;
                        throw new PackageManagerException(-3, "Cannot move system application");
                    }
                    boolean isInternalStorage = "private".equals(str2);
                    boolean allow3rdPartyOnInternal = this.mContext.getResources().getBoolean(17956869);
                    if (!isInternalStorage || allow3rdPartyOnInternal) {
                        try {
                            String currentVolumeUuid;
                            boolean currentAsec;
                            if (pkg.applicationInfo.isExternalAsec()) {
                                currentAsec = true;
                                currentVolumeUuid = "primary_physical";
                            } else if (pkg.applicationInfo.isForwardLocked()) {
                                currentAsec = true;
                                currentVolumeUuid = "forward_locked";
                            } else {
                                boolean z;
                                currentAsec = false;
                                currentVolumeUuid = ps.volumeUuid;
                                File probe = new File(pkg.codePath);
                                boolean z2 = isInternalStorage;
                                File probeOat = new File(probe, "oat");
                                if (!(probe.isDirectory() && probeOat.isDirectory())) {
                                    z = allow3rdPartyOnInternal;
                                    packageManager = pm;
                                    str3 = str2;
                                    throw new PackageManagerException(-6, "Move only supported for modern cluster style installs");
                                }
                                if (Objects.equals(currentVolumeUuid, str2)) {
                                    if (pkg.applicationInfo.isInternal()) {
                                        if (isPackageDeviceAdminOnAnyUser(packageName)) {
                                            throw new PackageManagerException(-8, "Device admin cannot be moved");
                                        }
                                    }
                                    if (this.mFrozenPackages.contains(str)) {
                                        packageManager = pm;
                                        str3 = str2;
                                        allow3rdPartyOnInternal = storage;
                                        throw new PackageManagerException(-7, "Failed to move already frozen package");
                                    }
                                    probe = new File(pkg.codePath);
                                    String installerPackageName = ps.installerPackageName;
                                    String packageAbiOverride = ps.cpuAbiOverrideString;
                                    int appId = UserHandle.getAppId(pkg.applicationInfo.uid);
                                    String seinfo = pkg.applicationInfo.seInfo;
                                    String label = String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
                                    int targetSdkVersion = pkg.applicationInfo.targetSdkVersion;
                                    final PackageFreezer freezer = freezePackage(str, "movePackageInternal");
                                    boolean moveCompleteApp = pkg;
                                    int[] installedUserIds = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                                } else {
                                    z = allow3rdPartyOnInternal;
                                    packageManager = pm;
                                    str3 = str2;
                                    allow3rdPartyOnInternal = storage;
                                    probeOat = new StringBuilder();
                                    probeOat.append("Package already moved to ");
                                    probeOat.append(str3);
                                    throw new PackageManagerException(-6, probeOat.toString());
                                }
                            }
                            if (Objects.equals(currentVolumeUuid, str2)) {
                            }
                        } catch (Throwable th2) {
                            th = th2;
                            throw th;
                        }
                    }
                    try {
                        throw new PackageManagerException(-9, "3rd party apps are not allowed on internal storage");
                    } catch (Throwable th3) {
                        th = th3;
                        packageManager = pm;
                        str3 = str2;
                        storageManager = storage;
                    }
                }
            }
            packageManager = pm;
            str3 = str2;
            storageManager = storage;
            throw new PackageManagerException(-2, "Missing package");
        }
    }

    public int movePrimaryStorage(String volumeUuid) throws RemoteException {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOVE_PACKAGE", null);
        final int realMoveId = this.mNextMoveId.getAndIncrement();
        Bundle extras = new Bundle();
        extras.putString("android.os.storage.extra.FS_UUID", volumeUuid);
        this.mMoveCallbacks.notifyCreated(realMoveId, extras);
        ((StorageManager) this.mContext.getSystemService(StorageManager.class)).setPrimaryStorageUuid(volumeUuid, new IPackageMoveObserver.Stub() {
            public void onCreated(int moveId, Bundle extras) {
            }

            public void onStatusChanged(int moveId, int status, long estMillis) {
                PackageManagerService.this.mMoveCallbacks.notifyStatusChanged(realMoveId, status, estMillis);
            }
        });
        return realMoveId;
    }

    public int getMoveStatus(int moveId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOUNT_UNMOUNT_FILESYSTEMS", null);
        return this.mMoveCallbacks.mLastStatus.get(moveId);
    }

    public void registerMoveCallback(IPackageMoveObserver callback) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOUNT_UNMOUNT_FILESYSTEMS", null);
        this.mMoveCallbacks.register(callback);
    }

    public void unregisterMoveCallback(IPackageMoveObserver callback) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOUNT_UNMOUNT_FILESYSTEMS", null);
        this.mMoveCallbacks.unregister(callback);
    }

    public boolean setInstallLocation(int loc) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.WRITE_SECURE_SETTINGS", null);
        if (getInstallLocation() == loc) {
            return true;
        }
        if (loc != 0 && loc != 1 && loc != 2) {
            return false;
        }
        Global.putInt(this.mContext.getContentResolver(), "default_install_location", loc);
        return true;
    }

    public int getInstallLocation() {
        return Global.getInt(this.mContext.getContentResolver(), "default_install_location", 0);
    }

    void cleanUpUser(UserManagerService userManager, int userHandle) {
        synchronized (this.mPackages) {
            this.mDirtyUsers.remove(Integer.valueOf(userHandle));
            this.mUserNeedsBadging.delete(userHandle);
            this.mSettings.removeUserLPw(userHandle);
            this.mPendingBroadcasts.remove(userHandle);
            this.mInstantAppRegistry.onUserRemovedLPw(userHandle);
            removeUnusedPackagesLPw(userManager, userHandle);
        }
    }

    private void removeUnusedPackagesLPw(UserManagerService userManager, final int userHandle) {
        int[] users = userManager.getUserIds();
        for (PackageSetting ps : this.mSettings.mPackages.values()) {
            if (ps.pkg != null) {
                final String packageName = ps.pkg.packageName;
                boolean z = true;
                int i = 0;
                if ((ps.pkgFlags & 1) != 0) {
                    if (ps.pkg.applicationInfo == null || ((ps.pkg.applicationInfo.hwFlags & DumpState.DUMP_HANDLE) == 0 && (ps.pkg.applicationInfo.hwFlags & 67108864) == 0)) {
                        z = false;
                    }
                    if (!z) {
                    }
                }
                boolean keep = shouldKeepUninstalledPackageLPr(packageName);
                if (!keep) {
                    while (true) {
                        int i2 = i;
                        if (i2 < users.length) {
                            if (users[i2] != userHandle && ps.getInstalled(users[i2])) {
                                keep = true;
                                break;
                            }
                            i = i2 + 1;
                        } else {
                            break;
                        }
                    }
                }
                if (!keep) {
                    this.mHandler.post(new Runnable() {
                        public void run() {
                            PackageManagerService.this.deletePackageX(packageName, -1, userHandle, 0);
                        }
                    });
                }
            }
        }
    }

    void createNewUser(int userId, String[] disallowedPackages) {
        synchronized (this.mInstallLock) {
            this.mSettings.createNewUserLI(this, this.mInstaller, userId, disallowedPackages);
        }
        synchronized (this.mPackages) {
            scheduleWritePackageRestrictionsLocked(userId);
            scheduleWritePackageListLocked(userId);
            applyFactoryDefaultBrowserLPw(userId);
            primeDomainVerificationsLPw(userId);
        }
    }

    void onNewUserCreated(int userId) {
        this.mDefaultPermissionPolicy.grantDefaultPermissions(userId);
        synchronized (this.mPackages) {
            if (this.mSettings.mPermissions.mPermissionReviewRequired) {
                this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, true, this.mPackages.values(), this.mPermissionCallback);
            }
        }
    }

    public VerifierDeviceIdentity getVerifierDeviceIdentity() throws RemoteException {
        VerifierDeviceIdentity verifierDeviceIdentityLPw;
        this.mContext.enforceCallingOrSelfPermission("android.permission.PACKAGE_VERIFICATION_AGENT", "Only package verification agents can read the verifier device identity");
        synchronized (this.mPackages) {
            verifierDeviceIdentityLPw = this.mSettings.getVerifierDeviceIdentityLPw();
        }
        return verifierDeviceIdentityLPw;
    }

    public void setPermissionEnforced(String permission, boolean enforced) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.GRANT_RUNTIME_PERMISSIONS", "setPermissionEnforced");
        if ("android.permission.READ_EXTERNAL_STORAGE".equals(permission)) {
            synchronized (this.mPackages) {
                if (this.mSettings.mReadExternalStorageEnforced == null || this.mSettings.mReadExternalStorageEnforced.booleanValue() != enforced) {
                    this.mSettings.mReadExternalStorageEnforced = enforced ? Boolean.TRUE : Boolean.FALSE;
                    this.mSettings.writeLPr();
                }
            }
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                long token = Binder.clearCallingIdentity();
                try {
                    am.killProcessesBelowForeground("setPermissionEnforcement");
                } catch (RemoteException e) {
                } catch (Throwable th) {
                    Binder.restoreCallingIdentity(token);
                }
                Binder.restoreCallingIdentity(token);
                return;
            }
            return;
        }
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("No selective enforcement for ");
        stringBuilder.append(permission);
        throw new IllegalArgumentException(stringBuilder.toString());
    }

    @Deprecated
    public boolean isPermissionEnforced(String permission) {
        return true;
    }

    public boolean isStorageLow() {
        long token = Binder.clearCallingIdentity();
        try {
            DeviceStorageMonitorInternal dsm = (DeviceStorageMonitorInternal) LocalServices.getService(DeviceStorageMonitorInternal.class);
            if (dsm != null) {
                boolean isMemoryLow = dsm.isMemoryLow();
                return isMemoryLow;
            }
            Binder.restoreCallingIdentity(token);
            return false;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public IPackageInstaller getPackageInstaller() {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        return this.mInstallerService;
    }

    public IArtManager getArtManager() {
        return this.mArtManagerService;
    }

    private boolean userNeedsBadging(int userId) {
        int index = this.mUserNeedsBadging.indexOfKey(userId);
        if (index >= 0) {
            return this.mUserNeedsBadging.valueAt(index);
        }
        long token = Binder.clearCallingIdentity();
        try {
            boolean b;
            UserInfo userInfo = sUserManager.getUserInfo(userId);
            if (userInfo == null || !userInfo.isManagedProfile()) {
                b = false;
            } else {
                b = true;
            }
            this.mUserNeedsBadging.put(userId, b);
            return b;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public KeySet getKeySetByAlias(String packageName, String alias) {
        if (packageName == null || alias == null) {
            return null;
        }
        KeySet keySet;
        synchronized (this.mPackages) {
            Package pkg = (Package) this.mPackages.get(packageName);
            if (pkg == null) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("KeySet requested for unknown package: ");
                stringBuilder.append(packageName);
                Slog.w(str, stringBuilder.toString());
                stringBuilder = new StringBuilder();
                stringBuilder.append("Unknown package: ");
                stringBuilder.append(packageName);
                throw new IllegalArgumentException(stringBuilder.toString());
            } else if (filterAppAccessLPr(pkg.mExtras, Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                String str2 = TAG;
                StringBuilder stringBuilder2 = new StringBuilder();
                stringBuilder2.append("KeySet requested for filtered package: ");
                stringBuilder2.append(packageName);
                Slog.w(str2, stringBuilder2.toString());
                stringBuilder2 = new StringBuilder();
                stringBuilder2.append("Unknown package: ");
                stringBuilder2.append(packageName);
                throw new IllegalArgumentException(stringBuilder2.toString());
            } else {
                keySet = new KeySet(this.mSettings.mKeySetManagerService.getKeySetByAliasAndPackageNameLPr(packageName, alias));
            }
        }
        return keySet;
    }

    public KeySet getSigningKeySet(String packageName) {
        if (packageName == null) {
            return null;
        }
        KeySet keySet;
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            Package pkg = (Package) this.mPackages.get(packageName);
            if (pkg == null) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("KeySet requested for unknown package: ");
                stringBuilder.append(packageName);
                Slog.w(str, stringBuilder.toString());
                stringBuilder = new StringBuilder();
                stringBuilder.append("Unknown package: ");
                stringBuilder.append(packageName);
                throw new IllegalArgumentException(stringBuilder.toString());
            } else if (filterAppAccessLPr(pkg.mExtras, callingUid, callingUserId)) {
                String str2 = TAG;
                StringBuilder stringBuilder2 = new StringBuilder();
                stringBuilder2.append("KeySet requested for filtered package: ");
                stringBuilder2.append(packageName);
                stringBuilder2.append(", uid:");
                stringBuilder2.append(callingUid);
                Slog.w(str2, stringBuilder2.toString());
                stringBuilder2 = new StringBuilder();
                stringBuilder2.append("Unknown package: ");
                stringBuilder2.append(packageName);
                throw new IllegalArgumentException(stringBuilder2.toString());
            } else {
                if (pkg.applicationInfo.uid != callingUid) {
                    if (1000 != callingUid) {
                        throw new SecurityException("May not access signing KeySet of other apps.");
                    }
                }
                keySet = new KeySet(this.mSettings.mKeySetManagerService.getSigningKeySetByPackageNameLPr(packageName));
            }
        }
        return keySet;
    }

    public boolean isPackageSignedByKeySet(String packageName, KeySet ks) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null || packageName == null || ks == null) {
            return false;
        }
        synchronized (this.mPackages) {
            Package pkg = (Package) this.mPackages.get(packageName);
            if (pkg == null || filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, UserHandle.getUserId(callingUid))) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("KeySet requested for unknown package: ");
                stringBuilder.append(packageName);
                Slog.w(str, stringBuilder.toString());
                stringBuilder = new StringBuilder();
                stringBuilder.append("Unknown package: ");
                stringBuilder.append(packageName);
                throw new IllegalArgumentException(stringBuilder.toString());
            }
            IBinder ksh = ks.getToken();
            if (ksh instanceof KeySetHandle) {
                boolean packageIsSignedByLPr = this.mSettings.mKeySetManagerService.packageIsSignedByLPr(packageName, (KeySetHandle) ksh);
                return packageIsSignedByLPr;
            }
            return false;
        }
    }

    public boolean isPackageSignedByKeySetExactly(String packageName, KeySet ks) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null || packageName == null || ks == null) {
            return false;
        }
        synchronized (this.mPackages) {
            Package pkg = (Package) this.mPackages.get(packageName);
            if (pkg == null || filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, UserHandle.getUserId(callingUid))) {
                String str = TAG;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("KeySet requested for unknown package: ");
                stringBuilder.append(packageName);
                Slog.w(str, stringBuilder.toString());
                stringBuilder = new StringBuilder();
                stringBuilder.append("Unknown package: ");
                stringBuilder.append(packageName);
                throw new IllegalArgumentException(stringBuilder.toString());
            }
            IBinder ksh = ks.getToken();
            if (ksh instanceof KeySetHandle) {
                boolean packageIsSignedByExactlyLPr = this.mSettings.mKeySetManagerService.packageIsSignedByExactlyLPr(packageName, (KeySetHandle) ksh);
                return packageIsSignedByExactlyLPr;
            }
            return false;
        }
    }

    private static String getParam(String params, String prefix, String separator) {
        int left = params.indexOf(prefix);
        if (left < 0) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(params);
            stringBuilder.append(" not contains ");
            stringBuilder.append(prefix);
            Log.e(str, stringBuilder.toString());
            return null;
        }
        left += prefix.length();
        int right = params.indexOf(separator, left);
        if (right >= 0) {
            return params.substring(left, right);
        }
        String str2 = TAG;
        StringBuilder stringBuilder2 = new StringBuilder();
        stringBuilder2.append(params);
        stringBuilder2.append(" not contains ");
        stringBuilder2.append(separator);
        Log.e(str2, stringBuilder2.toString());
        return null;
    }

    private static void saveDex2oatList(List<String> list) {
        BufferedWriter fout = null;
        try {
            fout = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("/data/system/dex2oat.list"), "UTF-8"));
            for (String i : list) {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(i);
                stringBuilder.append("\n");
                fout.write(stringBuilder.toString());
            }
            try {
                fout.close();
            } catch (IOException e) {
            }
        } catch (IOException e2) {
            Log.e(TAG, "saveDex2oatList error: ", e2);
            if (fout != null) {
                fout.close();
            }
        } catch (Throwable th) {
            if (fout != null) {
                try {
                    fout.close();
                } catch (IOException e3) {
                }
            }
        }
    }

    private void deletePackageIfUnusedLPr(final String packageName) {
        PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
        if (!(ps == null || ps.isAnyInstalled(sUserManager.getUserIds()))) {
            this.mHandler.post(new Runnable() {
                public void run() {
                    PackageManagerService.this.deletePackageX(packageName, -1, 0, 2);
                }
            });
        }
    }

    private static void checkDowngrade(Package before, PackageInfoLite after) throws PackageManagerException {
        StringBuilder stringBuilder;
        if (after.getLongVersionCode() < before.getLongVersionCode()) {
            stringBuilder = new StringBuilder();
            stringBuilder.append("Update version code ");
            stringBuilder.append(after.versionCode);
            stringBuilder.append(" is older than current ");
            stringBuilder.append(before.getLongVersionCode());
            throw new PackageManagerException(-25, stringBuilder.toString());
        } else if (after.getLongVersionCode() != before.getLongVersionCode()) {
        } else {
            if (after.baseRevisionCode < before.baseRevisionCode) {
                stringBuilder = new StringBuilder();
                stringBuilder.append("Update base revision code ");
                stringBuilder.append(after.baseRevisionCode);
                stringBuilder.append(" is older than current ");
                stringBuilder.append(before.baseRevisionCode);
                throw new PackageManagerException(-25, stringBuilder.toString());
            } else if (!ArrayUtils.isEmpty(after.splitNames)) {
                int i = 0;
                while (i < after.splitNames.length) {
                    String splitName = after.splitNames[i];
                    int j = ArrayUtils.indexOf(before.splitNames, splitName);
                    if (j == -1 || after.splitRevisionCodes[i] >= before.splitRevisionCodes[j]) {
                        i++;
                    } else {
                        StringBuilder stringBuilder2 = new StringBuilder();
                        stringBuilder2.append("Update split ");
                        stringBuilder2.append(splitName);
                        stringBuilder2.append(" revision code ");
                        stringBuilder2.append(after.splitRevisionCodes[i]);
                        stringBuilder2.append(" is older than current ");
                        stringBuilder2.append(before.splitRevisionCodes[j]);
                        throw new PackageManagerException(-25, stringBuilder2.toString());
                    }
                }
            }
        }
    }

    public void grantDefaultPermissionsToEnabledCarrierApps(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("grantPermissionsToEnabledCarrierApps");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToEnabledCarrierApps(packageNames, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public void grantDefaultPermissionsToEnabledImsServices(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("grantDefaultPermissionsToEnabledImsServices");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToEnabledImsServices(packageNames, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public void grantDefaultPermissionsToEnabledTelephonyDataServices(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("grantDefaultPermissionsToEnabledTelephonyDataServices");
        synchronized (this.mPackages) {
            Binder.withCleanCallingIdentity(new -$$Lambda$PackageManagerService$yfOQ0T-7_IM-V0KeaeTUW5KgZRQ(this, packageNames, userId));
        }
    }

    public void revokeDefaultPermissionsFromDisabledTelephonyDataServices(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("revokeDefaultPermissionsFromDisabledTelephonyDataServices");
        synchronized (this.mPackages) {
            Binder.withCleanCallingIdentity(new -$$Lambda$PackageManagerService$1IFDaSQRqG4pqlUtBm87Yzturic(this, packageNames, userId));
        }
    }

    public void grantDefaultPermissionsToActiveLuiApp(String packageName, int userId) {
        enforceSystemOrPhoneCaller("grantDefaultPermissionsToActiveLuiApp");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToActiveLuiApp(packageName, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public void revokeDefaultPermissionsFromLuiApps(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("revokeDefaultPermissionsFromLuiApps");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.revokeDefaultPermissionsFromLuiApps(packageNames, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    private static void enforceSystemOrPhoneCaller(String tag) {
        int callingUid = Binder.getCallingUid();
        if (callingUid != 1001 && callingUid != 1000) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Cannot call ");
            stringBuilder.append(tag);
            stringBuilder.append(" from UID ");
            stringBuilder.append(callingUid);
            throw new SecurityException(stringBuilder.toString());
        }
    }

    boolean isHistoricalPackageUsageAvailable() {
        return this.mPackageUsage.isHistoricalPackageUsageAvailable();
    }

    Collection<Package> getPackages() {
        ArrayList arrayList;
        synchronized (this.mPackages) {
            arrayList = new ArrayList(this.mPackages.values());
        }
        return arrayList;
    }

    public void logAppProcessStartIfNeeded(String processName, int uid, String seinfo, String apkFile, int pid) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && SecurityLog.isLoggingEnabled()) {
            Bundle data = new Bundle();
            data.putLong("startTimestamp", System.currentTimeMillis());
            data.putString(IZRHungService.PARA_PROCNAME, processName);
            data.putInt("uid", uid);
            data.putString("seinfo", seinfo);
            data.putString("apkFile", apkFile);
            data.putInt(IZRHungService.PARAM_PID, pid);
            Message msg = this.mProcessLoggingHandler.obtainMessage(1);
            msg.setData(data);
            this.mProcessLoggingHandler.sendMessage(msg);
        }
    }

    public PackageStats getCompilerPackageStats(String pkgName) {
        return this.mCompilerStats.getPackageStats(pkgName);
    }

    public PackageStats getOrCreateCompilerPackageStats(Package pkg) {
        return getOrCreateCompilerPackageStats(pkg.packageName);
    }

    public PackageStats getOrCreateCompilerPackageStats(String pkgName) {
        return this.mCompilerStats.getOrCreatePackageStats(pkgName);
    }

    public void deleteCompilerPackageStats(String pkgName) {
        this.mCompilerStats.deletePackageStats(pkgName);
    }

    public int getInstallReason(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "get install reason");
        synchronized (this.mPackages) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (filterAppAccessLPr(ps, callingUid, userId)) {
                return 0;
            } else if (ps != null) {
                int installReason = ps.getInstallReason(userId);
                return installReason;
            } else {
                return 0;
            }
        }
    }

    public boolean canRequestPackageInstalls(String packageName, int userId) {
        return canRequestPackageInstallsInternal(packageName, 0, userId, true);
    }

    private boolean canRequestPackageInstallsInternal(String packageName, int flags, int userId, boolean throwIfPermNotDeclared) {
        int callingUid = Binder.getCallingUid();
        boolean z = false;
        int uid = getPackageUid(packageName, 0, userId);
        if (callingUid == uid || callingUid == 0 || callingUid == 1000) {
            ApplicationInfo info = getApplicationInfo(packageName, flags, userId);
            if (info == null || info.targetSdkVersion < 26 || isInstantApp(packageName, userId)) {
                return false;
            }
            String appOpPermission = "android.permission.REQUEST_INSTALL_PACKAGES";
            if (ArrayUtils.contains(getAppOpPermissionPackages(appOpPermission), packageName)) {
                if (sUserManager.hasUserRestriction("no_install_unknown_sources", userId)) {
                    return false;
                }
                if (this.mExternalSourcesPolicy != null) {
                    int isTrusted = this.mExternalSourcesPolicy.getPackageTrustedToInstallApps(packageName, uid);
                    if (isTrusted != 2) {
                        if (isTrusted == 0) {
                            z = true;
                        }
                        return z;
                    }
                }
                if (checkUidPermission(appOpPermission, uid) == 0) {
                    z = true;
                }
                return z;
            } else if (throwIfPermNotDeclared) {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Need to declare ");
                stringBuilder.append(appOpPermission);
                stringBuilder.append(" to call this api");
                throw new SecurityException(stringBuilder.toString());
            } else {
                String str = TAG;
                StringBuilder stringBuilder2 = new StringBuilder();
                stringBuilder2.append("Need to declare ");
                stringBuilder2.append(appOpPermission);
                stringBuilder2.append(" to call this api");
                Slog.e(str, stringBuilder2.toString());
                return false;
            }
        }
        StringBuilder stringBuilder3 = new StringBuilder();
        stringBuilder3.append("Caller uid ");
        stringBuilder3.append(callingUid);
        stringBuilder3.append(" does not own package ");
        stringBuilder3.append(packageName);
        throw new SecurityException(stringBuilder3.toString());
    }

    private void parseInstalledPkgInfo(InstallArgs args, PackageInstalledInfo res) {
        StringBuilder pkgPath = new StringBuilder(100);
        int pkgInstallResult = 0;
        int pkgVersionCode = 0;
        String pkgVersionName = BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS;
        String pkgName = BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS;
        boolean pkgUpdate = false;
        if (!(args == null || args.origin == null || args.origin.file == null)) {
            pkgPath.append(args.origin.file.toString());
            pkgPath.append(";");
        }
        if (!(args == null || args.installerPackageName == null)) {
            pkgPath.append(args.installerPackageName);
        }
        if (res != null) {
            pkgInstallResult = res.returnCode;
            if (res.pkg != null) {
                pkgVersionCode = res.pkg.mVersionCode;
                pkgVersionName = res.pkg.mVersionName;
                if (res.pkg.applicationInfo != null) {
                    pkgName = res.pkg.applicationInfo.packageName;
                }
            }
            if (res.removedInfo != null) {
                pkgUpdate = res.removedInfo.removedPackage != null;
            }
        }
        parseInstalledPkgInfo(pkgPath.toString(), pkgName, pkgVersionName, pkgVersionCode, pkgInstallResult, pkgUpdate);
    }

    protected boolean isAppInstallAllowed(String installer, String appName) {
        return true;
    }

    protected boolean isUnAppInstallAllowed(String originPath) {
        return false;
    }

    public void loadSysWhitelist() {
    }

    public void checkIllegalSysApk(Package pkg, int hwFlags) throws PackageManagerException {
    }

    protected void addGrantedInstalledPkg(String pkgName, boolean grant) {
    }

    protected Signature[] getRealSignature(Package pkg) {
        if (pkg == null || !pkg.mRealSigningDetails.hasSignatures()) {
            return new Signature[0];
        }
        return pkg.mRealSigningDetails.signatures;
    }

    protected void setRealSigningDetails(Package pkg, SigningDetails real) {
        if (real != null) {
            pkg.mRealSigningDetails = real;
        }
    }

    private void uploadInstallErrRadar(String reason) {
        Bundle data = new Bundle();
        data.putString("package", "PMS");
        data.putString(HwBroadcastRadarUtil.KEY_VERSION_NAME, "0");
        data.putString("extra", reason);
        if (this.mMonitor != null) {
            this.mMonitor.monitor(907400000, data);
        }
    }

    private void writeNetQinFlag(String pkgName) {
        if ("com.nqmobile.antivirus20.hw".equalsIgnoreCase(pkgName)) {
            File file = new File(new File(Environment.getDataDirectory(), "system"), "netqin.tmp");
            synchronized (this.mPackages) {
                if (file.exists()) {
                    return;
                }
                try {
                    if (file.createNewFile()) {
                        FileUtils.setPermissions(file.getPath(), 416, -1, -1);
                        Log.i(TAG, "Create netqin flag successfully");
                    }
                } catch (IOException e) {
                    Log.i(TAG, "Fail to create netqin flag");
                }
            }
        } else {
            return;
        }
    }

    public static String getCallingAppName(Context context, Package pkg) {
        PackageManager pm = context.getPackageManager();
        String displayName = pkg.packageName;
        if (pm != null) {
            return String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
        }
        return displayName;
    }

    private void connectBootAnimation() {
        IBinder binder = ServiceManager.getService("BootAnimationBinderServer");
        if (binder != null) {
            this.mIBootAnmation = IBootAnmation.Stub.asInterface(binder);
        } else {
            Slog.w(TAG, "BootAnimationBinderServer not found; can not display dexoat process!");
        }
    }

    public ComponentName getInstantAppResolverSettingsComponent() {
        return this.mInstantAppResolverSettingsComponent;
    }

    public ComponentName getInstantAppInstallerComponent() {
        ComponentName componentName = null;
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        if (this.mInstantAppInstallerActivity != null) {
            componentName = this.mInstantAppInstallerActivity.getComponentName();
        }
        return componentName;
    }

    public String getInstantAppAndroidId(String packageName, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS", "getInstantAppAndroidId");
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getInstantAppAndroidId");
        if (!isInstantApp(packageName, userId)) {
            return null;
        }
        String instantAppAndroidIdLPw;
        synchronized (this.mPackages) {
            instantAppAndroidIdLPw = this.mInstantAppRegistry.getInstantAppAndroidIdLPw(packageName, userId);
        }
        return instantAppAndroidIdLPw;
    }

    boolean canHaveOatDir(String packageName) {
        synchronized (this.mPackages) {
            Package p = (Package) this.mPackages.get(packageName);
            if (p == null) {
                return false;
            }
            boolean canHaveOatDir = p.canHaveOatDir();
            return canHaveOatDir;
        }
    }

    private String getOatDir(Package pkg) {
        if (!pkg.canHaveOatDir()) {
            return null;
        }
        File codePath = new File(pkg.codePath);
        if (codePath.isDirectory()) {
            return PackageDexOptimizer.getOatDir(codePath).getAbsolutePath();
        }
        return null;
    }

    void deleteOatArtifactsOfPackage(String packageName) {
        Package pkg;
        synchronized (this.mPackages) {
            pkg = (Package) this.mPackages.get(packageName);
        }
        String[] instructionSets = InstructionSets.getAppDexInstructionSets(pkg.applicationInfo);
        List<String> codePaths = pkg.getAllCodePaths();
        String oatDir = getOatDir(pkg);
        for (String codePath : codePaths) {
            for (String isa : instructionSets) {
                try {
                    this.mInstaller.deleteOdex(codePath, isa, oatDir);
                } catch (InstallerException e) {
                    String str = TAG;
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("Failed deleting oat files for ");
                    stringBuilder.append(codePath);
                    Log.e(str, stringBuilder.toString(), e);
                }
            }
        }
    }

    Set<String> getUnusedPackages(long downgradeTimeThresholdMillis) {
        Throwable th;
        HashSet unusedPackages = new HashSet();
        long currentTimeInMillis = System.currentTimeMillis();
        ArrayMap arrayMap = this.mPackages;
        synchronized (arrayMap) {
            ArrayMap arrayMap2;
            try {
                Iterator it = this.mPackages.values().iterator();
                while (it.hasNext()) {
                    Package pkg = (Package) it.next();
                    PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(pkg.packageName);
                    if (ps != null) {
                        PackageUseInfo packageUseInfo = getDexManager().getPackageUseInfoOrDefault(pkg.packageName);
                        Iterator it2 = it;
                        arrayMap2 = arrayMap;
                        Package pkg2 = pkg;
                        if (PackageManagerServiceUtils.isUnusedSinceTimeInMillis(ps.firstInstallTime, currentTimeInMillis, downgradeTimeThresholdMillis, packageUseInfo, pkg.getLatestPackageUseTimeInMills(), pkg.getLatestForegroundPackageUseTimeInMills())) {
                            unusedPackages.add(pkg2.packageName);
                        }
                        arrayMap = arrayMap2;
                        it = it2;
                    }
                }
                return unusedPackages;
            } catch (Throwable th2) {
                th = th2;
                throw th;
            }
        }
    }

    public void setHarmfulAppWarning(String packageName, CharSequence warning, int userId) {
        int callingUid = Binder.getCallingUid();
        int callingAppId = UserHandle.getAppId(callingUid);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, true, "setHarmfulAppInfo");
        if (callingAppId == 1000 || callingAppId == 0 || checkUidPermission("android.permission.SET_HARMFUL_APP_WARNINGS", callingUid) == 0) {
            synchronized (this.mPackages) {
                this.mSettings.setHarmfulAppWarningLPw(packageName, warning, userId);
                scheduleWritePackageRestrictionsLocked(userId);
            }
            return;
        }
        throw new SecurityException("Caller must have the android.permission.SET_HARMFUL_APP_WARNINGS permission.");
    }

    public CharSequence getHarmfulAppWarning(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        int callingAppId = UserHandle.getAppId(callingUid);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, true, "getHarmfulAppInfo");
        if (callingAppId == 1000 || callingAppId == 0 || checkUidPermission("android.permission.SET_HARMFUL_APP_WARNINGS", callingUid) == 0) {
            String harmfulAppWarningLPr;
            synchronized (this.mPackages) {
                harmfulAppWarningLPr = this.mSettings.getHarmfulAppWarningLPr(packageName, userId);
            }
            return harmfulAppWarningLPr;
        }
        throw new SecurityException("Caller must have the android.permission.SET_HARMFUL_APP_WARNINGS permission.");
    }

    public boolean isPackageStateProtected(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        int callingAppId = UserHandle.getAppId(callingUid);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, true, "isPackageStateProtected");
        if (callingAppId == 1000 || callingAppId == 0 || checkUidPermission("android.permission.MANAGE_DEVICE_ADMINS", callingUid) == 0) {
            return this.mProtectedPackages.isPackageStateProtected(userId, packageName);
        }
        throw new SecurityException("Caller must have the android.permission.MANAGE_DEVICE_ADMINS permission.");
    }

    public ArrayMap<String, Package> getPackagesLock() {
        return this.mPackages;
    }

    public Settings getSettings() {
        return this.mSettings;
    }

    public IBinder getHwInnerService() {
        return this.mHwInnerService;
    }

    private long printClearDataTimeoutLogs(String type, long start, String packageName) {
        long end = SystemClock.uptimeMillis();
        if (end - start > 1000) {
            String str = TAG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("printClearDataTimeoutLogs type: ");
            stringBuilder.append(type);
            stringBuilder.append(",cost: ");
            stringBuilder.append(end - start);
            stringBuilder.append("ms for packageName: ");
            stringBuilder.append(packageName);
            Slog.i(str, stringBuilder.toString());
        }
        return end;
    }

    public boolean getHwCertPermission(boolean allowed, Package pkg, String perm) {
        return this.mHwPMSEx.getHwCertPermission(allowed, pkg, perm);
    }

    public int getSdkVersion() {
        return this.tSdkVersion;
    }

    public Handler getPackageHandler() {
        return this.mHandler;
    }

    public PermissionManagerInternal getPermissionManager() {
        return this.mPermissionManager;
    }

    public InstallParams createInstallParams(OriginInfo origin, MoveInfo move, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, String volumeUuid, VerificationInfo verificationInfo, UserHandle user, String packageAbiOverride, String[] grantedPermissions, SigningDetails signingDetails, int installReason) {
        return new InstallParams(origin, move, observer, installFlags, installerPackageName, volumeUuid, verificationInfo, user, packageAbiOverride, grantedPermissions, signingDetails, installReason);
    }

    public HashMap<String, HashSet<String>> getHwPMSMultiInstallMap() {
        return getMultiInstallMap();
    }

    public HashMap<String, HashSet<String>> getHwPMSDelMultiInstallMap() {
        return getDelMultiInstallMap();
    }
}
